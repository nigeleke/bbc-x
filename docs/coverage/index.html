<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","bbc-x","bbc-x","src","args.rs"],"content":"#[cfg(test)]\nuse clap::error::Error as ClapError;\nuse clap::{Parser as ClapParser, ValueEnum};\n\nuse std::path::PathBuf;\n\n#[derive(Clone, Copy, Debug, PartialEq, ValueEnum)]\npub enum Language {\n    Bbc3,\n    BbcX,\n}\n\n#[derive(Clone, Debug, ClapParser, PartialEq)]\n#[command(version, about, long_about = None)]\n///\n/// Resurrection of the educational BBC-X assembler language used at Hatfield Polytechnic.\n///\npub struct Args {\n    /// Specify the source file language. It is expected that all source files are in the same\n    /// language.\n    #[arg(long, visible_alias=\"lang\", value_enum, default_value_t=Language::BbcX)]\n    language: Language,\n\n    /// Create listing files during compilation. The list files will be named '\u003cFILE\u003e.lst'.\n    /// See also [list-path].\n    #[arg(short, long, required(false))]\n    list: bool,\n\n    /// The folder where the list files will be written. If not specified then they will be\n    /// written to the same folder as the input file. Implies '--list'.\n    #[arg(long)]\n    list_path: Option\u003cPathBuf\u003e,\n\n    /// Run the file(s) following successfully compillation. If more than one file is provided\n    /// then each will be run sequentially.\n    #[arg(short, long, required(false))]\n    run: bool,\n\n    /// Trace a file when it is executed. The trace files will be named '\u003cFILE\u003e.out'\n    /// See also [trace-path]. Implies '--run'.\n    #[arg(short, long, required(false))]\n    trace: bool,\n\n    /// The folder where the trace output files will be written. If not specified then they will\n    /// be written to same folder as the input file. Implies '--trace'.\n    #[arg(long)]\n    trace_path: Option\u003cPathBuf\u003e,\n\n    /// The source file(s) to be compiled and / or run.\n    #[arg(required(true))]\n    files: Vec\u003cPathBuf\u003e,\n}\n\nimpl Args {\n    pub fn from(args: Vec\u003cString\u003e) -\u003e Self {\n        Args::parse_from(args)\n    }\n\n    pub fn language(\u0026self) -\u003e Language {\n        self.language\n    }\n\n    #[inline]\n    pub fn list(\u0026self) -\u003e bool {\n        self.list\n    }\n\n    #[inline]\n    pub fn list_path(\u0026self) -\u003e Option\u003cPathBuf\u003e {\n        self.list_path.clone()\n    }\n\n    #[inline]\n    pub fn files(\u0026self) -\u003e impl Iterator\u003cItem = PathBuf\u003e + '_ {\n        self.files.iter().cloned()\n    }\n\n    #[inline]\n    pub fn run(\u0026self) -\u003e bool {\n        self.run\n    }\n\n    #[cfg(test)]\n    pub fn try_from(args: \u0026str) -\u003e Result\u003cSelf, ClapError\u003e {\n        let args = Vec::from_iter(args.split(' ').map(String::from));\n        Args::try_parse_from(\u0026args)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use clap::error::ErrorKind;\n    use pretty_assertions::assert_eq;\n\n    #[test]\n    fn error_with_zero_args() {\n        let args = \"bbc-x\";\n        let result = Args::try_from(\u0026args).map_err(|e| e.kind());\n        assert_eq!(result, Err(ErrorKind::MissingRequiredArgument))\n    }\n\n    #[test]\n    fn use_source_files_1() {\n        let args = \"bbc-x infile1.bbc\";\n        let result = Args::try_from(\u0026args).expect(\"Expected successful parse\");\n        let files = result.files;\n        assert_eq!(files.len(), 1);\n        assert_eq!(files[0], PathBuf::new().join(\"infile1.bbc\"));\n        assert!(!result.list);\n        assert_eq!(result.list_path, None);\n        assert!(!result.run);\n        assert!(!result.trace);\n        assert_eq!(result.trace_path, None);\n    }\n\n    #[test]\n    fn use_source_files_n() {\n        let args = \"bbc-x infile1.bbc infile2.bbc infile3.bbc\";\n        let result = Args::try_from(\u0026args).expect(\"Expected successful parse\");\n        let files = result.files;\n        assert_eq!(files.len(), 3);\n        assert_eq!(files[0], PathBuf::new().join(\"infile1.bbc\"));\n        assert_eq!(files[1], PathBuf::new().join(\"infile2.bbc\"));\n        assert_eq!(files[2], PathBuf::new().join(\"infile3.bbc\"));\n        assert!(!result.list);\n        assert_eq!(result.list_path, None);\n        assert!(!result.run);\n        assert!(!result.trace);\n        assert_eq!(result.trace_path, None);\n    }\n\n    #[test]\n    fn use_list() {\n        let args = \"bbc-x --list infile1.bbc\";\n        let result = Args::try_from(\u0026args).expect(\"Expected successful parse\");\n        assert!(result.list)\n    }\n\n    #[test]\n    fn use_list_path() {\n        let args = \"bbc-x --list-path my/list/path/ infile1.bbc\";\n        let result = Args::try_from(\u0026args).expect(\"Expected successful parse\");\n        assert_eq!(result.list_path, Some(PathBuf::new().join(\"my/list/path/\")))\n    }\n\n    #[test]\n    fn use_run() {\n        let args = \"bbc-x --run infile1.bbc\";\n        let result = Args::try_from(\u0026args).expect(\"Expected successful parse\");\n        assert!(result.run)\n    }\n\n    #[test]\n    fn use_trace() {\n        let args = \"bbc-x --trace infile1.bbc\";\n        let result = Args::try_from(\u0026args).expect(\"Expected successful parse\");\n        assert!(result.trace)\n    }\n\n    #[test]\n    fn use_trace_path() {\n        let args = \"bbc-x --trace-path my/trace/path/ infile1.bbc\";\n        let result = Args::try_from(\u0026args).expect(\"Expected successful parse\");\n        assert_eq!(\n            result.trace_path,\n            Some(PathBuf::new().join(\"my/trace/path/\"))\n        )\n    }\n}\n","traces":[{"line":55,"address":[1539056],"length":1,"stats":{"Line":3}},{"line":56,"address":[1539064],"length":1,"stats":{"Line":3}},{"line":59,"address":[1539088],"length":1,"stats":{"Line":3}},{"line":60,"address":[1539093],"length":1,"stats":{"Line":3}},{"line":64,"address":[1539104],"length":1,"stats":{"Line":1}},{"line":65,"address":[1539109],"length":1,"stats":{"Line":1}},{"line":69,"address":[1539120],"length":1,"stats":{"Line":1}},{"line":70,"address":[1539137],"length":1,"stats":{"Line":1}},{"line":74,"address":[1539168],"length":1,"stats":{"Line":3}},{"line":75,"address":[1539173],"length":1,"stats":{"Line":3}},{"line":79,"address":[1539216],"length":1,"stats":{"Line":1}},{"line":80,"address":[1539221],"length":1,"stats":{"Line":1}},{"line":84,"address":[1539232,1539411],"length":1,"stats":{"Line":2}},{"line":85,"address":[1539265],"length":1,"stats":{"Line":1}},{"line":86,"address":[1539342],"length":1,"stats":{"Line":3}}],"covered":15,"coverable":15},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbc3","assembler.rs"],"content":"use super::assembly::{Assembly, Code};\nuse super::ast::SourceProgramLine;\n\nuse crate::result::{Error, Result};\n\nuse std::collections::HashMap;\n\n// DEFINITION OF THE ASSEMBLER\n// The assembler is a program which accepts as data\n// source code in the form of source program lines. Each\n// source program line corresponds to one main word of\n// object code and translation is strictly on a line-by-line\n// basis. Sometimes the translation of a source program\n// line causes the compilation of a subsidiary word of\n// object code and sometimes it causes a value to be assigned\n// to, or a modification of, an index register.\n\n#[derive(Debug, PartialEq)]\npub struct Assembler {}\n\nimpl Assembler {\n    pub fn assemble(ast: \u0026[SourceProgramLine]) -\u003e Result\u003cAssembly\u003e {\n        validate_ast(ast)?;\n        let code = generate_code(ast);\n        let assembly = Assembly::new(\u0026code);\n        Ok(assembly)\n    }\n}\n\nfn validate_ast(ast: \u0026[SourceProgramLine]) -\u003e Result\u003c()\u003e {\n    let mut invalid_locations = ast\n        .iter()\n        .fold(HashMap::new(), |mut counts, line| {\n            *counts.entry(line.location()).or_insert(0) += 1;\n            counts\n        })\n        .into_iter()\n        .filter(|\u0026(_key, value)| (value \u003e 1))\n        .map(|(key, _value)| key)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    if invalid_locations.is_empty() {\n        Ok(())\n    } else {\n        invalid_locations.sort();\n        let invalid_locations = invalid_locations\n            .into_iter()\n            .map(|l| l.to_string())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\", \");\n        let error = format!(\n            \"Same location(s) used multiple times: {}\",\n            invalid_locations\n        );\n        Err(Error::FailedToAssemble(error))\n    }\n}\n\nfn generate_code(ast: \u0026[SourceProgramLine]) -\u003e Code {\n    ast.iter()\n        .map(|line| (*line.location(), line.source_program_word().clone()))\n        .collect::\u003cCode\u003e()\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::bbc3::{ast::*, Parser};\n    use pretty_assertions::assert_eq;\n\n    type SourceProgram = Vec\u003cSourceProgramLine\u003e;\n\n    fn parse(input: \u0026str) -\u003e SourceProgram {\n        input\n            .to_string()\n            .lines()\n            .map(|l| Parser::parse_line(l))\n            .filter_map(Result::ok)\n            .collect::\u003cSourceProgram\u003e()\n    }\n\n    #[test]\n    fn requires_unique_locations() {\n        let program = r#\"\n0001    JUMP    0001\n0002    JUMP    HERE\n\"#;\n        let program = parse(program);\n        let assembly = Assembler::assemble(\u0026program).unwrap();\n        assert_eq!(assembly.content(0), None);\n        assert_eq!(\n            assembly.content(1),\n            Some(SourceProgramWord::PWord(PWord::PutType(\n                Mnemonic::JUMP,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::NumericAddress(\n                        NumericAddress::AbsoluteAddress(1)\n                    )),\n                    None\n                )\n            )))\n        );\n        assert_eq!(\n            assembly.content(2),\n            Some(SourceProgramWord::PWord(PWord::PutType(\n                Mnemonic::JUMP,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"HERE\".into())),\n                    None\n                )\n            )))\n        );\n    }\n\n    #[test]\n    fn fails_when_location_not_unique() {\n        let program = r#\"\n0001    JUMP    0001\n0001    JUMP    HERE\n0002    JUMP    0002\n0002    JUMP    THERE\n\"#;\n        let program = parse(program);\n        let result = Assembler::assemble(\u0026program).err().unwrap();\n        assert_eq!(\n            result,\n            Error::FailedToAssemble(\"Same location(s) used multiple times: 1, 2\".into())\n        );\n    }\n\n    #[test]\n    fn will_create_intermediate_code_representation() {\n        let program = r#\"\n0001    JUMP    ALPHA\n0002    JUMP    EPSILON\n\"#;\n        let program = parse(program);\n        let assembly = Assembler::assemble(\u0026program).unwrap();\n        assert_eq!(assembly.content(0), None);\n        assert_eq!(\n            assembly.content(1),\n            Some(SourceProgramWord::PWord(PWord::PutType(\n                Mnemonic::JUMP,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ALPHA\".into())),\n                    None\n                )\n            )))\n        );\n        assert_eq!(\n            assembly.content(2),\n            Some(SourceProgramWord::PWord(PWord::PutType(\n                Mnemonic::JUMP,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"EPSILON\".into())),\n                    None\n                )\n            )))\n        );\n        assert_eq!(assembly.content(3), None);\n    }\n}\n","traces":[{"line":22,"address":[1811792,1812081],"length":1,"stats":{"Line":3}},{"line":23,"address":[1811819,1811929],"length":1,"stats":{"Line":4}},{"line":24,"address":[1811905],"length":1,"stats":{"Line":2}},{"line":25,"address":[1811922],"length":1,"stats":{"Line":2}},{"line":26,"address":[1812021],"length":1,"stats":{"Line":2}},{"line":30,"address":[1812112,1813165,1813120],"length":1,"stats":{"Line":3}},{"line":31,"address":[1812171,1812240],"length":1,"stats":{"Line":6}},{"line":33,"address":[1812207],"length":1,"stats":{"Line":6}},{"line":34,"address":[1527354,1527412,1527497],"length":1,"stats":{"Line":6}},{"line":35,"address":[1527477],"length":1,"stats":{"Line":3}},{"line":38,"address":[1527536,1527546],"length":1,"stats":{"Line":6}},{"line":39,"address":[1527584,1527601],"length":1,"stats":{"Line":2}},{"line":42,"address":[1812455,1812350,1812412],"length":1,"stats":{"Line":6}},{"line":43,"address":[1812448],"length":1,"stats":{"Line":2}},{"line":45,"address":[1812426,1812470],"length":1,"stats":{"Line":2}},{"line":46,"address":[1812477,1812667],"length":1,"stats":{"Line":2}},{"line":48,"address":[1527616,1527651],"length":1,"stats":{"Line":2}},{"line":51,"address":[1812872],"length":1,"stats":{"Line":1}},{"line":55,"address":[1812998],"length":1,"stats":{"Line":1}},{"line":59,"address":[1813200],"length":1,"stats":{"Line":2}},{"line":60,"address":[1813250],"length":1,"stats":{"Line":2}},{"line":61,"address":[1527715,1527680],"length":1,"stats":{"Line":4}}],"covered":22,"coverable":22},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbc3","assembly.rs"],"content":"use super::ast::{Location as AstLocation, SourceProgramWord as AstSourceProgramWord};\n\nuse std::collections::HashMap;\n\npub type Location = AstLocation;\npub type Content = AstSourceProgramWord;\n\npub type Code = HashMap\u003cLocation, Content\u003e;\n\npub struct Assembly {\n    _code: Code,\n}\n\nimpl Assembly {\n    pub fn new(code: \u0026Code) -\u003e Self {\n        let code = code.clone();\n        Self { _code: code }\n    }\n\n    #[cfg(test)]\n    pub fn content(\u0026self, location: Location) -\u003e Option\u003cContent\u003e {\n        self._code.get(\u0026location).map(|w| w.clone())\n    }\n}\n","traces":[{"line":15,"address":[770160],"length":1,"stats":{"Line":2}},{"line":16,"address":[770178],"length":1,"stats":{"Line":2}},{"line":21,"address":[770224],"length":1,"stats":{"Line":2}},{"line":22,"address":[770259],"length":1,"stats":{"Line":6}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbc3","ast.rs"],"content":"#[derive(Clone, Debug, PartialEq)]\npub struct SourceProgramLine {\n    location: Location,\n    source_program_word: SourceProgramWord,\n    comment: Comment\n}\n\nimpl SourceProgramLine {\n    pub fn new(\n        location: Location,\n        source_program_word: SourceProgramWord,\n        comment: Comment) -\u003e Self {\n        Self { location, source_program_word, comment }\n    }\n\n    pub fn location(\u0026self) -\u003e \u0026Location {\n        \u0026self.location\n    }\n\n    pub fn source_program_word(\u0026self) -\u003e \u0026SourceProgramWord {\n        \u0026self.source_program_word\n    }\n}\n\nimpl std::fmt::Display for SourceProgramLine {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        let location = format!(\"{:04}\", self.location);\n        let source_program_word = self.source_program_word.to_string();\n        let comment = self.comment.to_string();\n\n        write!(f, \"{:\u003c8}{:\u003c42}{}\", location, source_program_word, comment)\n    }\n}\n\npub type Location = AddressRef;\n\npub type Identifier = String;\n\n#[derive(Clone, Debug, PartialEq)]\npub enum SourceProgramWord {\n    SWord(SWord),\n    PWord(PWord),\n    FWord(FWord),\n    IWord(IWord),\n    Octal(Octal),\n}\n\nimpl std::fmt::Display for SourceProgramWord {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            SourceProgramWord::SWord(sword) =\u003e write!(f, \"\u003c{}\u003e\", sword),\n            SourceProgramWord::PWord(pword) =\u003e write!(f, \"{}\", pword),\n            SourceProgramWord::FWord(fword) =\u003e write!(f, \"{}\", fword),\n            SourceProgramWord::IWord(iword) =\u003e write!(f, \"{}\", iword),\n            SourceProgramWord::Octal(octal) =\u003e write!(f, \"{}\", octal),\n        }\n    }\n}\n\npub type SWord = String;\n\n#[derive(Clone, Debug, PartialEq)]\npub enum PWord {\n    TakeType(Mnemonic, Acc, GeneralOperand),\n    PutType(Mnemonic, Acc, AddressOperand),\n    LoadN(Acc, SimpleAddressOperand, Index),\n    LoadRConst(Acc, ConstOperand, Index),\n    LoadR(Acc, SimpleAddressOperand, Index),\n    LibraryMnemonic(Mnemonic),\n}\n\nimpl std::fmt::Display for PWord {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            PWord::TakeType(inst, acc, operand) =\u003e write!(f, \"{:\u003c8}{:\u003e2} {}\", inst.to_string(), acc.to_string(), operand),\n            PWord::PutType(inst, acc, operand) =\u003e write!(f, \"{:\u003c8}{:\u003e2} {}\", inst.to_string(), acc.to_string(), operand),\n            PWord::LoadN(acc, operand, index) =\u003e write!(f, \"{:\u003c8}{:\u003e2} {}:{}\", Mnemonic::LDN.to_string(), acc.to_string(), operand, index),\n            PWord::LoadRConst(acc, operand, index) =\u003e write!(f, \"{:\u003c8}{:\u003e2} {}:{}\", Mnemonic::LDR.to_string(), acc.to_string(), operand, index),\n            PWord::LoadR(acc, operand, index) =\u003e write!(f, \"{:\u003c8}{:\u003e2} {}:{}\", Mnemonic::LDR.to_string(), acc.to_string(), operand, index),\n            PWord::LibraryMnemonic(inst) =\u003e write!(f, \"{:\u003c8}\", inst.to_string()),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct Acc(Option\u003cchar\u003e);\n\nimpl From\u003cchar\u003e for Acc {\n    fn from(a: char) -\u003e Self {\n        Self(Some(a))\n     }\n}\n\nimpl From\u003cOption\u003cchar\u003e\u003e for Acc {\n    fn from(a: Option\u003cchar\u003e) -\u003e Self {\n        Self(a)\n     }\n}\n\nimpl std::fmt::Display for Acc {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{}\", self.0.map_or(\"\".into(), |a| a.to_string()))\n    }\n}\n\npub type FWord = FloatType;\n\npub type IWord = IntType;\n\npub type Comment = String;\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Octal {\n    S(WordValue),\n    P(WordValue),\n    F(WordValue),\n    I(WordValue),\n}\n\nimpl std::fmt::Display for Octal {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            Octal::S(value) =\u003e write!(f, \"(S{:08o})\", value),\n            Octal::P(value) =\u003e write!(f, \"(P{:08o})\", value),\n            Octal::F(value) =\u003e write!(f, \"(F{:08o})\", value),\n            Octal::I(value) =\u003e write!(f, \"(I{:08o})\", value),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum GeneralOperand {\n    AddressOperand(AddressOperand),\n    ConstOperand(ConstOperand),\n}\n\nimpl std::fmt::Display for GeneralOperand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            GeneralOperand::AddressOperand(o) =\u003e write!(f, \"{}\", o),\n            GeneralOperand::ConstOperand(o) =\u003e write!(f, \"{}\", o),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct AddressOperand {\n    address: SimpleAddressOperand,\n    index: Option\u003cIndex\u003e,\n}\n\nimpl AddressOperand {\n    pub fn new(\n        address: SimpleAddressOperand,\n        index:  Option\u003cIndex\u003e) -\u003e Self {\n        Self { address, index }\n    }\n}\n\nimpl std::fmt::Display for AddressOperand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        let index = self.index.map(|i| format!(\":{}\", i)).unwrap_or(\"\".into());\n        write!(f, \"{}{}\", self.address, index)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum ConstOperand {\n    SignedInteger(IntType),\n    SignedFWord(FloatType),\n    Octal(Octal),\n    SWord(SWord)\n}\n\nimpl std::fmt::Display for ConstOperand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            ConstOperand::SignedInteger(c) =\u003e write!(f, \"{:+}\", c),\n            ConstOperand::SignedFWord(c) =\u003e write!(f, \"{:+}\", c), \n            ConstOperand::Octal(c) =\u003e write!(f, \"{}\", c),\n            ConstOperand::SWord(c) =\u003e write!(f, \"\u003c{}\u003e\", c),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum SimpleAddressOperand {\n    DirectAddress(Address),\n    IndirectAddress(Address)\n}\n\nimpl std::fmt::Display for SimpleAddressOperand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            SimpleAddressOperand::DirectAddress(a) =\u003e write!(f, \"{}\", a),\n            SimpleAddressOperand::IndirectAddress(a) =\u003e write!(f, \"*{}\", a), \n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Address {\n    Identifier(Identifier),\n    NumericAddress(NumericAddress),\n}\n\nimpl std::fmt::Display for Address {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            Address::Identifier(i) =\u003e write!(f, \"{}\", i),\n            Address::NumericAddress(a) =\u003e write!(f, \"{}\", a),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum NumericAddress {\n    AbsoluteAddress(AddressRef),\n    RelativeAddress(RelativeRef),\n}\n\nimpl std::fmt::Display for NumericAddress {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            NumericAddress::AbsoluteAddress(a) =\u003e write!(f, \"{}\", a),\n            NumericAddress::RelativeAddress(a) =\u003e write!(f, \"{}+\", a),\n        }\n    }\n}\n\npub type TypeDesignator = char;\npub type Character = char;\npub type NumericCharacter = char;\npub type Punctuation = char;\npub type IntType = i32;\npub type FloatType = f32;\npub type AddressRef = usize;\npub type RelativeRef = usize; // TODO: Implies forward addressing only...\npub type Index = usize;\npub type WordValue = u32;\n\n#[derive(Clone, Debug, PartialEq)]\n#[allow(clippy::upper_case_acronyms)]\npub enum Mnemonic {\n    LDN,\n    LDR,\n    // 0-15 mnemonic\n    NTHG,\n    ADD,\n    SUBT,\n    MPLY,\n    DVD,\n    TAKE,\n    NEG,\n    MOD,\n    CLR,\n    AND,\n    OR,\n    NEQV,\n    NOT,\n    SHFR,\n    CYCR,\n    OPUT,\n    // X 0-15 mnemonic\n    XNTHG,\n    XADD,\n    XSUBT,\n    XMPLY,\n    XDVD,\n    XTAKE,\n    XNEG,\n    XMOD,\n    XCLR,\n    XAND,\n    XOR,\n    XNEQV,\n    XNOT,\n    XSHFR,\n    XCYCR,\n    XOPUT,\n    // 16-22 mnemonic\n    IPUT,\n    PUT,\n    INCR,\n    DECR,\n    TYPE,\n    CHYP,\n    EXEC,\n    // X 16-22 mnemonic\n    XIPUT,\n    XPUT,\n    XINCR,\n    XDECR,\n    XTYPE,\n    XCHYP,\n    XEXEC,\n    // skip mnemonic\n    SKET,\n    SKAE,\n    SKAN,\n    SKAL,\n    SKAG,\n    // jump mnemonic\n    LIBR,\n    JLIK,\n    JUMP,\n    JEZ,\n    JNZ,\n    JLZ,\n    JGZ,\n    JOI,\n    SLIK,\n    SNLZ,\n    // library mnemonic\n    SQRT,\n    LN,\n    EXP,\n    READ,\n    PRINT,\n    SIN,\n    COS,\n    TAN,\n    ARCTAN,\n    STOP,\n    LINE,\n    INT,\n    FRAC,\n    FLOAT,\n    CAPTN,\n}\n\nimpl std::fmt::Display for Mnemonic {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{:?}\", self)\n    }\n}\n","traces":[{"line":9,"address":[1291552],"length":1,"stats":{"Line":4}},{"line":16,"address":[1291664],"length":1,"stats":{"Line":3}},{"line":17,"address":[1291672],"length":1,"stats":{"Line":3}},{"line":20,"address":[1291680],"length":1,"stats":{"Line":2}},{"line":21,"address":[1291688],"length":1,"stats":{"Line":2}},{"line":26,"address":[1291696,1293703],"length":1,"stats":{"Line":1}},{"line":27,"address":[1291796,1291729,1292044],"length":1,"stats":{"Line":3}},{"line":28,"address":[1292205],"length":1,"stats":{"Line":1}},{"line":29,"address":[1292278],"length":1,"stats":{"Line":1}},{"line":31,"address":[1292693],"length":1,"stats":{"Line":1}},{"line":49,"address":[1293728],"length":1,"stats":{"Line":1}},{"line":50,"address":[1293761],"length":1,"stats":{"Line":1}},{"line":51,"address":[1293916,1293812],"length":1,"stats":{"Line":2}},{"line":52,"address":[1293990,1294108],"length":1,"stats":{"Line":2}},{"line":53,"address":[1294325,1294203],"length":1,"stats":{"Line":2}},{"line":54,"address":[1294420,1294542],"length":1,"stats":{"Line":2}},{"line":55,"address":[1294637,1294759],"length":1,"stats":{"Line":2}},{"line":73,"address":[1297325,1294864],"length":1,"stats":{"Line":1}},{"line":74,"address":[1294912],"length":1,"stats":{"Line":1}},{"line":75,"address":[1296887,1296327,1297107,1296006,1296182,1296655,1294948],"length":1,"stats":{"Line":5}},{"line":76,"address":[1297674,1297520,1297347,1295125,1298002,1298234,1298454],"length":1,"stats":{"Line":5}},{"line":77,"address":[1298845,1299109,1299701,1298669,1300141,1299921,1299469,1295305],"length":1,"stats":{"Line":6}},{"line":78,"address":[1300389,1301861,1301189,1300829,1301421,1295492,1301641,1300565],"length":1,"stats":{"Line":6}},{"line":79,"address":[1303361,1302285,1302109,1295679,1302909,1302549,1303141,1303581],"length":1,"stats":{"Line":6}},{"line":80,"address":[1295866,1303829,1304137],"length":1,"stats":{"Line":2}},{"line":89,"address":[1304288],"length":1,"stats":{"Line":1}},{"line":90,"address":[1304292],"length":1,"stats":{"Line":1}},{"line":95,"address":[1304304],"length":1,"stats":{"Line":4}},{"line":101,"address":[1304320,1304625],"length":1,"stats":{"Line":1}},{"line":102,"address":[1304348,1304541],"length":1,"stats":{"Line":4}},{"line":121,"address":[1304656],"length":1,"stats":{"Line":1}},{"line":122,"address":[1304689],"length":1,"stats":{"Line":1}},{"line":123,"address":[1304724,1304828,1305080],"length":1,"stats":{"Line":3}},{"line":124,"address":[1305572,1305186,1305308],"length":1,"stats":{"Line":3}},{"line":125,"address":[1305809,1306073,1305687],"length":1,"stats":{"Line":3}},{"line":126,"address":[1306574,1306188,1306310],"length":1,"stats":{"Line":3}},{"line":138,"address":[1306704],"length":1,"stats":{"Line":1}},{"line":139,"address":[1306736],"length":1,"stats":{"Line":1}},{"line":140,"address":[1306865,1306765],"length":1,"stats":{"Line":2}},{"line":141,"address":[1307048,1306938],"length":1,"stats":{"Line":2}},{"line":153,"address":[1307152],"length":1,"stats":{"Line":2}},{"line":161,"address":[1307216,1307740],"length":1,"stats":{"Line":1}},{"line":162,"address":[1307762,1307249],"length":1,"stats":{"Line":4}},{"line":163,"address":[1307631],"length":1,"stats":{"Line":1}},{"line":176,"address":[1307792],"length":1,"stats":{"Line":1}},{"line":177,"address":[1307825],"length":1,"stats":{"Line":1}},{"line":178,"address":[1308234,1307890,1307994],"length":1,"stats":{"Line":3}},{"line":179,"address":[1308712,1308460,1308338],"length":1,"stats":{"Line":3}},{"line":180,"address":[1308825,1308947],"length":1,"stats":{"Line":2}},{"line":181,"address":[1309160,1309042],"length":1,"stats":{"Line":2}},{"line":193,"address":[1309264],"length":1,"stats":{"Line":1}},{"line":194,"address":[1309296],"length":1,"stats":{"Line":1}},{"line":195,"address":[1309414,1309310],"length":1,"stats":{"Line":2}},{"line":196,"address":[1309597,1309487],"length":1,"stats":{"Line":2}},{"line":208,"address":[1309696],"length":1,"stats":{"Line":1}},{"line":209,"address":[1309728],"length":1,"stats":{"Line":1}},{"line":210,"address":[1309766,1309866],"length":1,"stats":{"Line":2}},{"line":211,"address":[1309939,1310049],"length":1,"stats":{"Line":2}},{"line":223,"address":[1310144],"length":1,"stats":{"Line":1}},{"line":224,"address":[1310176],"length":1,"stats":{"Line":1}},{"line":225,"address":[1310294,1310190],"length":1,"stats":{"Line":2}},{"line":226,"address":[1310367,1310477],"length":1,"stats":{"Line":2}},{"line":333,"address":[1310576],"length":1,"stats":{"Line":1}},{"line":334,"address":[1310681],"length":1,"stats":{"Line":1}}],"covered":64,"coverable":64},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbc3","grammar.rs"],"content":"use super::ast::*;\n\nuse pom::utf8::*;\n\nuse std::str::FromStr;\n\n// ****************************************************************************\n// Pom representation of section 5 of\n// https://spiral.imperial.ac.uk/bitstream/10044/1/21019/2/Tagg-W-1971-PhD-Thesis.pdf.\n//\n// \"DEFINITION OF THE ASSEMBLER\".\n//\n// The [BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) style comments\n// are from the thesis; Changes from that original are commented.\n\npub struct Grammar;\n\nimpl Grammar {\n    pub fn bbc3_line\u003c'a\u003e() -\u003e Parser\u003c'a, SourceProgramLine\u003e {\n        source_program_line()\n    }\n}\n\n// ****************************************************************************\n// \u003csource program line\u003e ::= \u003clocation\u003e\u003csource program word\u003e\n//                           \u003ccomment\u003e\u003cnew line\u003e\n// Note: This implementation removes newlines.\nfn source_program_line\u003c'a\u003e() -\u003e Parser\u003c'a, SourceProgramLine\u003e {\n    let as_source_program_line = |((l, w), c)| SourceProgramLine::new(l, w, c);\n\n    (location() + source_program_word() + comment() - end())\n        .map(as_source_program_line)\n        .name(\"source_program_line\")\n}\n\n// \u003clocation\u003e ::= \u003cnumeric address\u003e\u003cspace\u003e\n// Amended: Changed to absolute address.\nfn location\u003c'a\u003e() -\u003e Parser\u003c'a, Location\u003e {\n    (absolute_address() - inline_ws()).name(\"location\")\n}\n\n// \u003csource program word\u003e ::= \u003cS-word\u003e | \u003cP-word\u003e | \u003cF-word\u003e |\n//                           \u003cI-word\u003e | \u003coctal\u003e\nfn source_program_word\u003c'a\u003e() -\u003e Parser\u003c'a, SourceProgramWord\u003e {\n    (sword().map(SourceProgramWord::SWord)\n        | pword().map(SourceProgramWord::PWord)\n        | fword().map(SourceProgramWord::FWord)\n        | iword().map(SourceProgramWord::IWord)\n        | octal().map(SourceProgramWord::Octal))\n    .name(\"source_program_word\")\n}\n\n// \u003ccomment\u003e ::= \u003cno character\u003e | \u003cspace\u003e\u003cstring\u003e\nfn comment\u003c'a\u003e() -\u003e Parser\u003c'a, Comment\u003e {\n    let actual = || inline_ws() * none_of(\"\\n\").repeat(0..).map(String::from_iter);\n    (actual() | empty().map(|_| \"\".to_string())).name(\"comment\")\n}\n\n// ****************************************************************************\n// \u003cS-word\u003e ::= \u003cquote\u003e\u003cactual character\u003e\u003ccharacter\u003e\u003ccharacter\u003e\n//              \u003ccharacter\u003e\u003cunquote\u003e\nfn sword\u003c'a\u003e() -\u003e Parser\u003c'a, SWord\u003e {\n    (sym('\u003c') + actual_character().repeat(1..=4) + sym('\u003e'))\n        .map(|((_, cs), _)| SWord::from_iter(cs.iter()))\n        .name(\"sword\")\n}\n\n// \u003cP-word\u003e ::= \u003ctake type mnemonic\u003e\u003cacc\u003e\u003cgeneral operand\u003e |\n//              \u003cput type mnemonic\u003e‹acc\u003e\u003caddress operand\u003e |\n//              LDN\u003cacc\u003e\u003csimple address operand\u003e:\u003cindex\u003e|\n//              LDR\u003cacc\u003e\u003cconst. operand\u003e:‹index\u003e|\n//              LDR\u003cacc\u003e\u003csimple address operand\u003e:\u003cindex\u003e|\n//              \u003clibrary mnemonic\u003e\n// Amended: Added optional whitespace between mnemonic, acc and operand.\nfn pword\u003c'a\u003e() -\u003e Parser\u003c'a, PWord\u003e {\n    (take_type_pword()\n        | put_type_pword()\n        | loadn_pword()\n        | loadr_const_pword()\n        | loadr_pword()\n        | library_mnemonic_pword())\n    .name(\"pword\")\n}\n\nfn take_type_pword\u003c'a\u003e() -\u003e Parser\u003c'a, PWord\u003e {\n    let as_take_type = |((m, a), o)| PWord::TakeType(m, a, o);\n\n    (take_type_mnemonic() - inline_ws().opt() + acc() - inline_ws().opt() + general_operand())\n        .map(as_take_type)\n        .name(\"take_type_pword\")\n}\n\nfn put_type_pword\u003c'a\u003e() -\u003e Parser\u003c'a, PWord\u003e {\n    let as_put_type = |((m, a), o)| PWord::PutType(m, a, o);\n\n    (put_type_mnemonic() - inline_ws().opt() + acc() - inline_ws().opt() + address_operand())\n        .map(as_put_type)\n        .name(\"put_type_pword\")\n}\n\nfn loadn_pword\u003c'a\u003e() -\u003e Parser\u003c'a, PWord\u003e {\n    let as_loadn = |((a, o), i)| PWord::LoadN(a, o, i);\n\n    (ldn_mnemonic() * inline_ws().opt() * acc() - inline_ws().opt()\n        + simple_address_operand()\n        + index_ref())\n    .map(as_loadn)\n    .name(\"loadn_pword\")\n}\n\nfn loadr_const_pword\u003c'a\u003e() -\u003e Parser\u003c'a, PWord\u003e {\n    let as_loadr_const = |((a, o), i)| PWord::LoadRConst(a, o, i);\n\n    (ldr_mnemonic() * inline_ws().opt() * acc() - inline_ws().opt() + const_operand() + index_ref())\n        .map(as_loadr_const)\n        .name(\"loadr_const_pword\")\n}\n\nfn loadr_pword\u003c'a\u003e() -\u003e Parser\u003c'a, PWord\u003e {\n    let as_loadr = |((a, o), i)| PWord::LoadR(a, o, i);\n\n    (ldr_mnemonic() * inline_ws().opt() * acc() - inline_ws().opt()\n        + simple_address_operand()\n        + index_ref())\n    .map(as_loadr)\n    .name(\"loadr_pword\")\n}\n\nfn library_mnemonic_pword\u003c'a\u003e() -\u003e Parser\u003c'a, PWord\u003e {\n    library_mnemonic()\n        .map(PWord::LibraryMnemonic)\n        .name(\"library_mnemonic_pword\")\n}\n\n// \u003cF-word\u003e ::= \u003cunsigned F-word\u003e | \u003csigned F-word\u003e\nfn fword\u003c'a\u003e() -\u003e Parser\u003c'a, FWord\u003e {\n    (unsigned_fword() | signed_fword()).name(\"fword\")\n}\n\n// \u003cI-word\u003e ::= \u003cunsigned integer\u003e | \u003csigned integer\u003e\nfn iword\u003c'a\u003e() -\u003e Parser\u003c'a, IWord\u003e {\n    (unsigned_integer() | signed_integer()).name(\"iword\")\n}\n\n// \u003coctal\u003e ::= \u003ctype designator\u003e\u003coct.dig\u003e\u003coct.dig\u003e‹oct.dig\u003e\n//             \u003coct.dig\u003e\u003coct.dig\u003e\u003coct.dig\u003e\u003coct.dig\u003e\u003coct.dig\u003e\nfn octal\u003c'a\u003e() -\u003e Parser\u003c'a, Octal\u003e {\n    let as_enum = |(t, value)| match t {\n        'S' =\u003e Octal::S(value),\n        'P' =\u003e Octal::P(value),\n        'F' =\u003e Octal::F(value),\n        'I' =\u003e Octal::I(value),\n        _ =\u003e unreachable!(),\n    };\n\n    (sym('(') * type_designator() + octal_word() - sym(')'))\n        .map(as_enum)\n        .name(\"octal\")\n}\n\nfn octal_word\u003c'a\u003e() -\u003e Parser\u003c'a, WordValue\u003e {\n    oct_dig()\n        .repeat(8)\n        .map(String::from_iter)\n        .convert(|s| WordValue::from_str_radix(\u0026s, 8))\n        .name(\"octal_word\")\n}\n\n// ****************************************************************************\n// \u003cstring\u003e ::= \u003ccharacter\u003e | \u003ccharacter\u003e\u003cstring\u003e\n// Amended: Definition not required.\n\n// \u003ccharacter\u003e ::= \u003cno character\u003e | \u003cactual character\u003e\n// Amended: Definition not required.\n\n// \u003cactual character\u003e ::= \u003calpha character\u003e | \u003cnumeric character\u003e |\n//                        \u003cpunctuation\u003e\nfn actual_character\u003c'a\u003e() -\u003e Parser\u003c'a, Character\u003e {\n    (alpha_character() | numeric_character() | punctuation()).name(\"actual_character\")\n}\n\n// \u003calpha character\u003e ::= A | B | C | D | E | F | G | H | I | J | K| L |M | N | O | P |\n//                       Q | R | S | T | V | W | X | Y | Z\nfn alpha_character\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    one_of(\u0026('A'..='Z'))\n}\n\n// \u003cnumeric character\u003e ::= \u003cdigit\u003e | + | - | \u003csubscript 10\u003e | .\nfn numeric_character\u003c'a\u003e() -\u003e Parser\u003c'a, NumericCharacter\u003e {\n    (digit() | sym('+') | sym('-') | subscript10() | sym('.')).name(\"numeric_character\")\n}\n\n// \u003cpunctuation\u003e ::= ( | \u003cquote\u003e | \u003cunquote\u003e | \u003capostrophe\u003e | * | / |\n//                   : | ) | = | ? | ^ | ~ | # | ; | , | \u003cspace\u003e\nfn punctuation\u003c'a\u003e() -\u003e Parser\u003c'a, Punctuation\u003e {\n    one_of(\"\u003c\u003e'*/:)=?^~#;. \").name(\"punctuation\")\n}\n\n// \u003cdigit\u003e ::= \u003coct.dig\u003e | 8 | 9\nfn digit\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    oct_dig() | one_of(\"89\")\n}\n\n// \u003coct.dig\u003e ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7\nfn oct_dig\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    one_of(\u0026('0'..='7'))\n}\n\n// Added: ++\n// Represents 'space()' in description\nfn inline_ws\u003c'a\u003e() -\u003e Parser\u003c'a, String\u003e {\n    one_of(\" \\t\")\n        .repeat(1..)\n        .map(String::from_iter)\n        .name(\"inline_ws\")\n}\n// Added: --\n\n// ****************************************************************************\n// Amended: Most definitions not directly required....\n// \u003cno character\u003e\n// \u003cquote\u003e        .\u003c.\n// \u003cunquote\u003e        .\u003c.\n// \u003capostrophe\u003e   .'.\n// \u003cspace\u003e        . .\n// \u003cnew line\u003e     .\n// .\n// \u003csubscript 10\u003e .@.\nfn subscript10\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    sym('@')\n}\n\n// ****************************************************************************\n// \u003cgeneral operand\u003e ::= \u003caddress operand\u003e | \u003cconst. operand\u003e\nfn general_operand\u003c'a\u003e() -\u003e Parser\u003c'a, GeneralOperand\u003e {\n    (const_operand().map(GeneralOperand::ConstOperand)\n        | address_operand().map(GeneralOperand::AddressOperand))\n    .name(\"general_operand\")\n}\n\n// \u003caddress operand\u003e ::= \u003csimple address operand\u003e | \u003csimple address operand\u003e\n//                       \":\" \u003cindex\u003e\nfn address_operand\u003c'a\u003e() -\u003e Parser\u003c'a, AddressOperand\u003e {\n    (simple_address_operand() + index_ref().opt())\n        .map(|(o, i)| AddressOperand::new(o, i))\n        .name(\"address_operand\")\n}\n\n// \u003cconst. operand\u003e ::= \u003csigned integer\u003e | \u003csigned F-word\u003e !\n//                      \u003coctal\u003e | \u003cS-word\u003e\nfn const_operand\u003c'a\u003e() -\u003e Parser\u003c'a, ConstOperand\u003e {\n    inline_ws().opt()\n        * (signed_fword().map(ConstOperand::SignedFWord)\n            | signed_integer().map(ConstOperand::SignedInteger)\n            | octal().map(ConstOperand::Octal)\n            | sword().map(ConstOperand::SWord))\n        .name(\"const_operand\")\n}\n\n// \u003csimple address operand\u003e ::= \u003cspace\u003e\u003caddress\u003e | *\u003caddress\u003e\n// Amended: \u003cspace\u003e handled elsewhere.\nfn simple_address_operand\u003c'a\u003e() -\u003e Parser\u003c'a, SimpleAddressOperand\u003e {\n    (address().map(SimpleAddressOperand::DirectAddress)\n        | (sym('*') * address()).map(SimpleAddressOperand::IndirectAddress))\n    .name(\"simple_address_operand\")\n}\n\n// \u003caddress\u003e ::= \u003cidentifier\u003e | \u003cnumeric address\u003e\nfn address\u003c'a\u003e() -\u003e Parser\u003c'a, Address\u003e {\n    (identifier().map(Address::Identifier) | numeric_address().map(Address::NumericAddress))\n        .name(\"address\")\n}\n\n// \u003cidentifier\u003e ::= \u003calpha char.\u003e | \u003cidentifier\u003e\u003calpha char.\u003e !\n//                  \u003cidentifier\u003e\u003cdigit\u003e\nfn identifier\u003c'a\u003e() -\u003e Parser\u003c'a, Identifier\u003e {\n    let concat = |a: char, ans: \u0026[char]| {\n        let mut id = Vec::from(ans);\n        id.insert(0, a);\n        String::from_iter(id)\n    };\n\n    (alpha_character() + alpha_numeric().repeat(0..))\n        .map(move |ans| concat(ans.0, \u0026ans.1))\n        .name(\"identifier\")\n}\n\nfn alpha_numeric\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    alpha_character() | digit()\n}\n\n// \u003cnumeric address\u003e ::= \u003cabsolute address\u003e | \u003crelative address\u003e\nfn numeric_address\u003c'a\u003e() -\u003e Parser\u003c'a, NumericAddress\u003e {\n    (relative_address().map(NumericAddress::RelativeAddress)\n        | absolute_address().map(NumericAddress::AbsoluteAddress))\n    .name(\"numeric_address\")\n}\n\n// \u003cabsolute address\u003e ::= \u003cUnsigned integer\u003e\nfn absolute_address\u003c'a\u003e() -\u003e Parser\u003c'a, AddressRef\u003e {\n    unsigned_integer()\n        .map(|i| i as AddressRef)\n        .name(\"absolute_address\")\n}\n\n// \u003crelative address\u003e ::= \u003cabsolute address\u003e+\nfn relative_address\u003c'a\u003e() -\u003e Parser\u003c'a, RelativeRef\u003e {\n    (absolute_address() - sym('+')).name(\"relative_address\")\n}\n\n// \u003cindex\u003e ::= \u003cdigit\u003e | \u003cdigit\u003e\u003cdigit\u003e\nfn index\u003c'a\u003e() -\u003e Parser\u003c'a, Index\u003e {\n    digit()\n        .repeat(1..=2)\n        .map(String::from_iter)\n        .convert(|s| Index::from_str(\u0026s))\n        .name(\"index\")\n}\n\nfn index_ref\u003c'a\u003e() -\u003e Parser\u003c'a, Index\u003e {\n    (sym(':') * index()).map(|i| i).name(\"index_ref\")\n}\n\n// \u003cacc\u003e ::= \u003cno character\u003e | 2\nfn acc\u003c'a\u003e() -\u003e Parser\u003c'a, Acc\u003e {\n    (sym('2').map(Acc::from) | empty().map(|_| Acc::from(None))).name(\"acc\")\n}\n\n// ****************************************************************************\n// \u003csigned F-word\u003e ::= +\u003cunsigned F-word\u003e | -\u003cunsigned F-word\u003e\nfn signed_fword\u003c'a\u003e() -\u003e Parser\u003c'a, FWord\u003e {\n    let negate = |f: FloatType| -f;\n\n    ((sym('+') * unsigned_fword()) | (sym('-') * unsigned_fword().map(negate))).name(\"signed_fword\")\n}\n\n// \u003cunsigned F-word\u003e ::= \u003cdecimal part\u003e | \u003cdecimal part\u003e\n//                       \u003cexponent part\u003e | \u003cunsigned integer\u003e\n//                       \u003cexponent part\u003e\nfn unsigned_fword\u003c'a\u003e() -\u003e Parser\u003c'a, FWord\u003e {\n    let de_to_float1 = |(d, e)| FloatType::from_str(\u0026format!(\"{}e{}\", d, e));\n    let de_to_float2 = |(d, e)| FloatType::from_str(\u0026format!(\"{}e{}\", d, e));\n\n    (decimal_part().convert(|s| FloatType::from_str(\u0026s))\n        | (decimal_part() + exponent_part()).convert(de_to_float1)\n        | (unsigned_integer() + exponent_part()).convert(de_to_float2))\n    .name(\"unsigned_fword\")\n}\n\n// \u003cdecimal part\u003e ::= \u003cunsigned integer\u003e.\u003cunsigned integer\u003e |\n//                    .\u003cunsigned integer\u003e\nfn decimal_part\u003c'a\u003e() -\u003e Parser\u003c'a, String\u003e {\n    let if_to_string = |(i, f): (IntType, IntType)| format!(\"{}.{}\", i, f);\n    let f_to_string = |f: IntType| format!(\"0.{}\", f);\n\n    ((unsigned_integer() - sym('.').discard() + unsigned_integer()).map(if_to_string)\n        | (sym('.').discard() * unsigned_integer()).map(f_to_string))\n    .name(\"decimal_part\")\n}\n\n// \u003cexponent part\u003e ::= \u003csubscript 10\u003e\u003csign\u003e\u003cdigit\u003e |\n//                     \u003csubscript 10\u003e\u003csign\u003e\u003cdigit\u003e\u003cdigit\u003e\nfn exponent_part\u003c'a\u003e() -\u003e Parser\u003c'a, String\u003e {\n    let sd_to_string = |(s, d): (String, char)| format!(\"{}{}\", s, d);\n    let sdd_to_string = |((s, d1), d2): ((String, char), char)| format!(\"{}{}{}\", s, d1, d2);\n\n    ((subscript10().discard() * sign() + digit()).map(sd_to_string)\n        | (subscript10().discard() * sign() + digit() + digit()).map(sdd_to_string))\n    .name(\"exponent_part\")\n}\n\n// \u003csign\u003e ::= \u003cno character\u003e | + | -\nfn sign\u003c'a\u003e() -\u003e Parser\u003c'a, String\u003e {\n    (sym('+') | sym('-'))\n        .repeat(..=1)\n        .map(String::from_iter)\n        .name(\"sign\")\n}\n\n// \u003csigned integer\u003e ::= +\u003cunsigned integer\u003e | -\u003cunsigned integer\u003e\nfn signed_integer\u003c'a\u003e() -\u003e Parser\u003c'a, IntType\u003e {\n    let negate = |i: IntType| -i;\n\n    ((sym('+') * unsigned_integer()) | (sym('-') * unsigned_integer().map(negate)))\n        .name(\"signed_integer\")\n}\n\n// \u003cunsigned integer\u003e ::= \u003cdigit\u003e | \u003cdigit\u003e\u003cunsigned integer\u003e\nfn unsigned_integer\u003c'a\u003e() -\u003e Parser\u003c'a, IntType\u003e {\n    digit()\n        .repeat(1..)\n        .map(String::from_iter)\n        .convert(|s| IntType::from_str(\u0026s))\n        .name(\"unsigned_integer\")\n}\n\n// \u003ctype designator\u003e ::= S | P | F | I\nfn type_designator\u003c'a\u003e() -\u003e Parser\u003c'a, TypeDesignator\u003e {\n    one_of(\"SPFI\").name(\"type_designator\")\n}\n\n// ****************************************************************************\n// \u003cmnemonic\u003e ::= \u003ctake type mnemonic\u003e | \u003cput type mnemonic\u003e |\n//                LDN | LDR\n// Not required in grammar...\n\n// \u003ctake type mnemonic\u003e ::= \u003c0-15 mnemonic\u003e | \u003cskip mnemonic\u003e\nfn take_type_mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    (n0_15_mnemonc() | skip_mnemonic()).name(\"take_type_mnemonic\")\n}\n\n// \u003cput type mnemonic\u003e ::= X\u003c0-15 mnemonic\u003e | \u003c16-22 mnemonic\u003e |\n//                         X\u003c16-22 mnemonic\u003e | \u003cjump mnemonic\u003e\nfn put_type_mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    (n0_15_xmnemonic() | n16_22_mnemonic() | n16_22_xmnemonic() | jump_mnemonic())\n        .name(\"put_type_mnemonic\")\n}\n\n// \u003c0-15 mnemonic\u003e ::= NTHG | ADD | SUBT | MPLY | DVD | TAKE | NEG | MOD |\n//                     CLR | AND | OR | NEQV | NOT | SHFR | CYCR | OPUT\nfn n0_15_mnemonc\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    (exact(\"NTHG\").map(|_| Mnemonic::NTHG)\n        | exact(\"ADD\").map(|_| Mnemonic::ADD)\n        | exact(\"SUBT\").map(|_| Mnemonic::SUBT)\n        | exact(\"MPLY\").map(|_| Mnemonic::MPLY)\n        | exact(\"DVD\").map(|_| Mnemonic::DVD)\n        | exact(\"TAKE\").map(|_| Mnemonic::TAKE)\n        | exact(\"NEG\").map(|_| Mnemonic::NEG)\n        | exact(\"MOD\").map(|_| Mnemonic::MOD)\n        | exact(\"CLR\").map(|_| Mnemonic::CLR)\n        | exact(\"AND\").map(|_| Mnemonic::AND)\n        | exact(\"OR\").map(|_| Mnemonic::OR)\n        | exact(\"NEQV\").map(|_| Mnemonic::NEQV)\n        | exact(\"NOT\").map(|_| Mnemonic::NOT)\n        | exact(\"SHFR\").map(|_| Mnemonic::SHFR)\n        | exact(\"CYCR\").map(|_| Mnemonic::CYCR)\n        | exact(\"OPUT\").map(|_| Mnemonic::OPUT))\n    .name(\"n0_15_mnemonic\")\n}\n\nfn n0_15_xmnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    let as_x = |m| match m {\n        Mnemonic::NTHG =\u003e Mnemonic::XNTHG,\n        Mnemonic::ADD =\u003e Mnemonic::XADD,\n        Mnemonic::SUBT =\u003e Mnemonic::XSUBT,\n        Mnemonic::MPLY =\u003e Mnemonic::XMPLY,\n        Mnemonic::DVD =\u003e Mnemonic::XDVD,\n        Mnemonic::TAKE =\u003e Mnemonic::XTAKE,\n        Mnemonic::NEG =\u003e Mnemonic::XNEG,\n        Mnemonic::MOD =\u003e Mnemonic::XMOD,\n        Mnemonic::CLR =\u003e Mnemonic::XCLR,\n        Mnemonic::AND =\u003e Mnemonic::XAND,\n        Mnemonic::OR =\u003e Mnemonic::XOR,\n        Mnemonic::NEQV =\u003e Mnemonic::XNEQV,\n        Mnemonic::NOT =\u003e Mnemonic::XNOT,\n        Mnemonic::SHFR =\u003e Mnemonic::XSHFR,\n        Mnemonic::CYCR =\u003e Mnemonic::XCYCR,\n        Mnemonic::OPUT =\u003e Mnemonic::XOPUT,\n        _ =\u003e unreachable!(),\n    };\n\n    (sym('X') * n0_15_mnemonc().map(as_x)).name(\"n0_15_xmnemonic\")\n}\n\n// \u003c16-22 mnemonic\u003e ::= IPUT | PUT | INCR | DECR | TYPE | CHYP | EXEC\nfn n16_22_mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    (exact(\"IPUT\").map(|_| Mnemonic::IPUT)\n        | exact(\"PUT\").map(|_| Mnemonic::PUT)\n        | exact(\"INCR\").map(|_| Mnemonic::INCR)\n        | exact(\"DECR\").map(|_| Mnemonic::DECR)\n        | exact(\"TYPE\").map(|_| Mnemonic::TYPE)\n        | exact(\"CHYP\").map(|_| Mnemonic::CHYP)\n        | exact(\"EXEC\").map(|_| Mnemonic::EXEC))\n    .name(\"n16_22_mnemonic\")\n}\n\nfn n16_22_xmnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    let as_x = |m| match m {\n        Mnemonic::IPUT =\u003e Mnemonic::XIPUT,\n        Mnemonic::PUT =\u003e Mnemonic::XPUT,\n        Mnemonic::INCR =\u003e Mnemonic::XINCR,\n        Mnemonic::DECR =\u003e Mnemonic::XDECR,\n        Mnemonic::TYPE =\u003e Mnemonic::XTYPE,\n        Mnemonic::CHYP =\u003e Mnemonic::XCHYP,\n        Mnemonic::EXEC =\u003e Mnemonic::XEXEC,\n        _ =\u003e unreachable!(),\n    };\n    sym('X') * n16_22_mnemonic().map(as_x).name(\"n16_22_xmnemonic\")\n}\n\n// \u003cskip mnemonic\u003e::= SKET | SKAE | SKAN | SKAL | SKAG\nfn skip_mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    (exact(\"SKET\").map(|_| Mnemonic::SKET)\n        | exact(\"SKAE\").map(|_| Mnemonic::SKAE)\n        | exact(\"SKAN\").map(|_| Mnemonic::SKAN)\n        | exact(\"SKAL\").map(|_| Mnemonic::SKAL)\n        | exact(\"SKAG\").map(|_| Mnemonic::SKAG))\n    .name(\"skip_mnemonic\")\n}\n\n// \u003cjump mnemonic\u003e ::= LIBR | JLIK | JUMP | JEZ | JNZ | JLZ | JGZ | JOI |\n//                     SLIK | SNLZ\nfn jump_mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    (exact(\"LIBR\").map(|_| Mnemonic::LIBR)\n        | exact(\"JLIK\").map(|_| Mnemonic::JLIK)\n        | exact(\"JUMP\").map(|_| Mnemonic::JUMP)\n        | exact(\"JEZ\").map(|_| Mnemonic::JEZ)\n        | exact(\"JNZ\").map(|_| Mnemonic::JNZ)\n        | exact(\"JLZ\").map(|_| Mnemonic::JLZ)\n        | exact(\"JGZ\").map(|_| Mnemonic::JGZ)\n        | exact(\"JOI\").map(|_| Mnemonic::JOI)\n        | exact(\"SLIK\").map(|_| Mnemonic::SLIK)\n        | exact(\"SNLZ\").map(|_| Mnemonic::SNLZ))\n    .name(\"jump_mnemonic\")\n}\n\n// \u003clibrary mnemonic\u003e ::= SQRT | LN | EXP | READ | PRINT | SIN | COS | TAN |\n//                        ARCTAN | STOP | LINE | INT | FRAC | FLOAT | CAPTN\nfn library_mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    (exact(\"SQRT\").map(|_| Mnemonic::SQRT)\n        | exact(\"LN\").map(|_| Mnemonic::LN)\n        | exact(\"EXP\").map(|_| Mnemonic::EXP)\n        | exact(\"READ\").map(|_| Mnemonic::READ)\n        | exact(\"PRINT\").map(|_| Mnemonic::PRINT)\n        | exact(\"SIN\").map(|_| Mnemonic::SIN)\n        | exact(\"COS\").map(|_| Mnemonic::COS)\n        | exact(\"TAN\").map(|_| Mnemonic::TAN)\n        | exact(\"ARCTAN\").map(|_| Mnemonic::ARCTAN)\n        | exact(\"STOP\").map(|_| Mnemonic::STOP)\n        | exact(\"LINE\").map(|_| Mnemonic::LINE)\n        | exact(\"INT\").map(|_| Mnemonic::INT)\n        | exact(\"FRAC\").map(|_| Mnemonic::FRAC)\n        | exact(\"FLOAT\").map(|_| Mnemonic::FLOAT)\n        | exact(\"CAPTN\").map(|_| Mnemonic::CAPTN))\n    .name(\"library_mnemonocic\")\n}\n\nfn ldn_mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    exact(\"LDN\").map(|_| Mnemonic::LDN).name(\"ldn_mnemonic\")\n}\n\nfn ldr_mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    exact(\"LDR\").map(|_| Mnemonic::LDR).name(\"ldr_mnemonic\")\n}\n\n// Utility parsers\nfn exact(tag: \u0026str) -\u003e Parser\u003c'_, String\u003e {\n    let assert_tag = move |s| {\n        (s == tag)\n            .then_some(tag.into())\n            .ok_or(Err::\u003cString, _\u003e(\"not tag\"))\n    };\n    any()\n        .repeat(tag.len())\n        .map(String::from_iter)\n        .convert(assert_tag)\n        .name(\"exact\")\n}\n","traces":[{"line":19,"address":[1659472],"length":1,"stats":{"Line":2}},{"line":20,"address":[1659473],"length":1,"stats":{"Line":2}},{"line":28,"address":[1659488,1660002,1660027],"length":1,"stats":{"Line":2}},{"line":29,"address":[1529760,1529795],"length":1,"stats":{"Line":8}},{"line":31,"address":[1659519,1660020,1660044],"length":1,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[1660250,1660080,1660228],"length":1,"stats":{"Line":2}},{"line":39,"address":[1660084,1660243],"length":1,"stats":{"Line":2}},{"line":44,"address":[1661138,1660272,1661110],"length":1,"stats":{"Line":1}},{"line":45,"address":[1661028,1660672,1660470,1660279,1660850,1661085],"length":1,"stats":{"Line":23}},{"line":46,"address":[1660351,1661185,1660549],"length":1,"stats":{"Line":8}},{"line":47,"address":[1660739,1661170,1660565],"length":1,"stats":{"Line":8}},{"line":48,"address":[1661155,1660917,1660755],"length":1,"stats":{"Line":8}},{"line":49,"address":[1661077,1660933,1661131],"length":1,"stats":{"Line":8}},{"line":54,"address":[1661390,1661200,1661412],"length":1,"stats":{"Line":4}},{"line":55,"address":[1529904,1529913],"length":1,"stats":{"Line":12}},{"line":56,"address":[1530160,1530176],"length":1,"stats":{"Line":8}},{"line":62,"address":[1661941,1661424,1661966],"length":1,"stats":{"Line":3}},{"line":63,"address":[1661431,1661980,1661959],"length":1,"stats":{"Line":1}},{"line":64,"address":[1530208,1530227],"length":1,"stats":{"Line":2}},{"line":75,"address":[1662895,1662016,1662867],"length":1,"stats":{"Line":4}},{"line":76,"address":[1662023,1662842,1662486,1662637,1662172,1662335,1662785],"length":1,"stats":{"Line":28}},{"line":77,"address":[1662251,1662957,1662092],"length":1,"stats":{"Line":8}},{"line":78,"address":[1662267,1662402,1662942],"length":1,"stats":{"Line":8}},{"line":79,"address":[1662418,1662553,1662927],"length":1,"stats":{"Line":8}},{"line":80,"address":[1662704,1662912,1662569],"length":1,"stats":{"Line":8}},{"line":81,"address":[1662834,1662720,1662888],"length":1,"stats":{"Line":8}},{"line":85,"address":[1663769,1662976,1663741],"length":1,"stats":{"Line":4}},{"line":86,"address":[1662983],"length":1,"stats":{"Line":6}},{"line":88,"address":[1663015,1663762,1663786],"length":1,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[1664617,1663824,1664589],"length":1,"stats":{"Line":4}},{"line":94,"address":[1530528,1530560],"length":1,"stats":{"Line":8}},{"line":96,"address":[1664610,1663863,1664634],"length":1,"stats":{"Line":4}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[1664672,1665620,1665648],"length":1,"stats":{"Line":4}},{"line":102,"address":[1530656,1530667],"length":1,"stats":{"Line":6}},{"line":104,"address":[1665525,1665584,1665377,1664719,1665680],"length":1,"stats":{"Line":16}},{"line":105,"address":[1665444,1665665,1665309],"length":1,"stats":{"Line":8}},{"line":106,"address":[1665641,1665460,1665576],"length":1,"stats":{"Line":8}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[1666704,1665728,1666676],"length":1,"stats":{"Line":4}},{"line":112,"address":[1530768,1530779],"length":1,"stats":{"Line":6}},{"line":114,"address":[1665775,1666697,1666721],"length":1,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[1666784,1667732,1667760],"length":1,"stats":{"Line":4}},{"line":120,"address":[1666791],"length":1,"stats":{"Line":6}},{"line":122,"address":[1667489,1666831,1667637,1667696,1667792],"length":1,"stats":{"Line":16}},{"line":123,"address":[1667556,1667777,1667421],"length":1,"stats":{"Line":8}},{"line":124,"address":[1667572,1667688,1667753],"length":1,"stats":{"Line":8}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[1667840],"length":1,"stats":{"Line":4}},{"line":130,"address":[1667841],"length":1,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[1668058,1667888,1668036],"length":1,"stats":{"Line":4}},{"line":137,"address":[1668051,1667892],"length":1,"stats":{"Line":4}},{"line":141,"address":[1668080,1668228,1668250],"length":1,"stats":{"Line":4}},{"line":142,"address":[1668084,1668243],"length":1,"stats":{"Line":4}},{"line":147,"address":[1668272,1668825,1668800],"length":1,"stats":{"Line":4}},{"line":148,"address":[1668279],"length":1,"stats":{"Line":6}},{"line":149,"address":[1531075],"length":1,"stats":{"Line":1}},{"line":150,"address":[1531093],"length":1,"stats":{"Line":1}},{"line":151,"address":[1531111],"length":1,"stats":{"Line":1}},{"line":152,"address":[1531129],"length":1,"stats":{"Line":1}},{"line":156,"address":[1668818,1668842,1668303],"length":1,"stats":{"Line":4}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[1668864],"length":1,"stats":{"Line":4}},{"line":162,"address":[1668865],"length":1,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[1531195,1531168],"length":1,"stats":{"Line":2}},{"line":178,"address":[1668944,1669218,1669240],"length":1,"stats":{"Line":3}},{"line":179,"address":[1668948,1669233,1669254],"length":1,"stats":{"Line":4}},{"line":184,"address":[1669264],"length":1,"stats":{"Line":4}},{"line":185,"address":[1669265],"length":1,"stats":{"Line":4}},{"line":189,"address":[1669280,1669975,1670003],"length":1,"stats":{"Line":4}},{"line":190,"address":[1669996,1670020,1669287],"length":1,"stats":{"Line":4}},{"line":195,"address":[1670064],"length":1,"stats":{"Line":4}},{"line":196,"address":[1670065],"length":1,"stats":{"Line":4}},{"line":200,"address":[1670277,1670255,1670112],"length":1,"stats":{"Line":1}},{"line":201,"address":[1670270,1670116],"length":1,"stats":{"Line":3}},{"line":205,"address":[1670288],"length":1,"stats":{"Line":3}},{"line":206,"address":[1670289],"length":1,"stats":{"Line":1}},{"line":211,"address":[1670304],"length":1,"stats":{"Line":3}},{"line":212,"address":[1670305],"length":1,"stats":{"Line":3}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[1670384],"length":1,"stats":{"Line":4}},{"line":230,"address":[1670385],"length":1,"stats":{"Line":4}},{"line":235,"address":[1670416,1670606,1670628],"length":1,"stats":{"Line":4}},{"line":236,"address":[1670420,1670539,1670584],"length":1,"stats":{"Line":12}},{"line":237,"address":[1670621,1670456,1670579],"length":1,"stats":{"Line":8}},{"line":243,"address":[1670833,1670640,1670855],"length":1,"stats":{"Line":4}},{"line":244,"address":[1670644,1670848],"length":1,"stats":{"Line":4}},{"line":245,"address":[1531364,1531344],"length":1,"stats":{"Line":4}},{"line":251,"address":[1671799,1671754,1670864],"length":1,"stats":{"Line":4}},{"line":252,"address":[1671671,1670871],"length":1,"stats":{"Line":8}},{"line":253,"address":[1671632,1671395,1670943,1671205,1671023,1671573],"length":1,"stats":{"Line":24}},{"line":254,"address":[1671789,1671086,1671284],"length":1,"stats":{"Line":8}},{"line":255,"address":[1671300,1671771,1671462],"length":1,"stats":{"Line":8}},{"line":256,"address":[1671478,1671624,1671744],"length":1,"stats":{"Line":8}},{"line":257,"address":[1670966,1671720,1671820],"length":1,"stats":{"Line":4}},{"line":262,"address":[1672192,1671840],"length":1,"stats":{"Line":4}},{"line":263,"address":[1672152,1671847,1672107],"length":1,"stats":{"Line":12}},{"line":264,"address":[1672182,1672147,1672216,1671888],"length":1,"stats":{"Line":8}},{"line":269,"address":[1672414,1672436,1672224],"length":1,"stats":{"Line":4}},{"line":270,"address":[1672228,1672429],"length":1,"stats":{"Line":4}},{"line":276,"address":[1672647,1672448,1672669],"length":1,"stats":{"Line":4}},{"line":277,"address":[1531728,1531679,1531440,1531650],"length":1,"stats":{"Line":8}},{"line":278,"address":[1531514],"length":1,"stats":{"Line":2}},{"line":279,"address":[1531552],"length":1,"stats":{"Line":2}},{"line":280,"address":[1531595],"length":1,"stats":{"Line":2}},{"line":283,"address":[1672662,1672457],"length":1,"stats":{"Line":4}},{"line":284,"address":[1531696,1531733],"length":1,"stats":{"Line":4}},{"line":288,"address":[1672819,1672688,1672841],"length":1,"stats":{"Line":4}},{"line":289,"address":[1672692,1672834],"length":1,"stats":{"Line":4}},{"line":293,"address":[1673076,1672864,1673054],"length":1,"stats":{"Line":4}},{"line":294,"address":[1672868,1673032,1672987],"length":1,"stats":{"Line":12}},{"line":295,"address":[1672904,1673069,1673027],"length":1,"stats":{"Line":8}},{"line":300,"address":[1673088],"length":1,"stats":{"Line":3}},{"line":301,"address":[1673089],"length":1,"stats":{"Line":1}},{"line":302,"address":[1531913,1531904],"length":1,"stats":{"Line":8}},{"line":307,"address":[1673293,1673315,1673136],"length":1,"stats":{"Line":4}},{"line":308,"address":[1673140,1673308],"length":1,"stats":{"Line":4}},{"line":312,"address":[1673328,1673504,1673526],"length":1,"stats":{"Line":4}},{"line":313,"address":[1673332,1673460,1673408],"length":1,"stats":{"Line":12}},{"line":314,"address":[1673455,1673357,1673519],"length":1,"stats":{"Line":8}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[1531920,1531952],"length":1,"stats":{"Line":2}},{"line":320,"address":[1673704,1673726,1673536],"length":1,"stats":{"Line":4}},{"line":321,"address":[1673540,1673719],"length":1,"stats":{"Line":6}},{"line":325,"address":[1673947,1673744,1673969],"length":1,"stats":{"Line":4}},{"line":326,"address":[1673748,1673962],"length":1,"stats":{"Line":12}},{"line":331,"address":[1673984,1674558],"length":1,"stats":{"Line":4}},{"line":332,"address":[1532128,1532139],"length":1,"stats":{"Line":6}},{"line":334,"address":[1674548,1674015,1674588],"length":1,"stats":{"Line":4}},{"line":340,"address":[1675404,1674624],"length":1,"stats":{"Line":4}},{"line":341,"address":[1674631],"length":1,"stats":{"Line":4}},{"line":342,"address":[1533240,1533125,1532847,1532983,1532832],"length":1,"stats":{"Line":0}},{"line":344,"address":[1674976,1674663,1675361,1675302],"length":1,"stats":{"Line":18}},{"line":345,"address":[1675449,1675043,1674703],"length":1,"stats":{"Line":8}},{"line":346,"address":[1675394,1675059,1675353,1675434],"length":1,"stats":{"Line":8}},{"line":352,"address":[1676325,1675488],"length":1,"stats":{"Line":4}},{"line":353,"address":[1533600,1533978,1533639,1533849],"length":1,"stats":{"Line":8}},{"line":354,"address":[1534000,1534127,1534224],"length":1,"stats":{"Line":3}},{"line":356,"address":[1675527,1676282,1676223,1676370],"length":1,"stats":{"Line":12}},{"line":357,"address":[1676355,1676274,1675941,1676315],"length":1,"stats":{"Line":8}},{"line":363,"address":[1677557,1677602,1676400],"length":1,"stats":{"Line":4}},{"line":364,"address":[1534543,1534240,1534654,1534401,1534265],"length":1,"stats":{"Line":4}},{"line":365,"address":[1535115,1534729,1534704,1534872,1535242],"length":1,"stats":{"Line":0}},{"line":367,"address":[1677514,1677455,1677638,1676455],"length":1,"stats":{"Line":12}},{"line":368,"address":[1677547,1676850,1677623,1677506,1677574],"length":1,"stats":{"Line":8}},{"line":373,"address":[1677891,1677664,1677869],"length":1,"stats":{"Line":4}},{"line":374,"address":[1677668,1677884],"length":1,"stats":{"Line":4}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[1678478,1677904],"length":1,"stats":{"Line":4}},{"line":382,"address":[1535313,1535296],"length":1,"stats":{"Line":6}},{"line":384,"address":[1677935,1678508,1678468],"length":1,"stats":{"Line":4}},{"line":389,"address":[1678544],"length":1,"stats":{"Line":3}},{"line":390,"address":[1678545],"length":1,"stats":{"Line":3}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[1535387,1535360],"length":1,"stats":{"Line":8}},{"line":398,"address":[1678624],"length":1,"stats":{"Line":4}},{"line":399,"address":[1678625],"length":1,"stats":{"Line":4}},{"line":408,"address":[1678842,1678672,1678820],"length":1,"stats":{"Line":4}},{"line":409,"address":[1678676,1678835],"length":1,"stats":{"Line":4}},{"line":414,"address":[1679370,1679345,1678864],"length":1,"stats":{"Line":4}},{"line":415,"address":[1679384,1678871,1679363],"length":1,"stats":{"Line":4}},{"line":421,"address":[1679408,1682888,1682916],"length":1,"stats":{"Line":4}},{"line":422,"address":[1681752,1682204,1681300,1681526,1681978,1680848,1679944,1682614,1681074,1682424,1680396,1680170,1682863,1679718,1679415,1682804,1680622],"length":1,"stats":{"Line":70}},{"line":423,"address":[1683149,1679587,1679797],"length":1,"stats":{"Line":10}},{"line":424,"address":[1535652,1535632],"length":1,"stats":{"Line":10}},{"line":425,"address":[1535680,1535700],"length":1,"stats":{"Line":10}},{"line":426,"address":[1680265,1680475,1683095],"length":1,"stats":{"Line":10}},{"line":427,"address":[1535776,1535796],"length":1,"stats":{"Line":10}},{"line":428,"address":[1680927,1683059,1680717],"length":1,"stats":{"Line":10}},{"line":429,"address":[1680943,1683041,1681153],"length":1,"stats":{"Line":10}},{"line":430,"address":[1535920,1535940],"length":1,"stats":{"Line":10}},{"line":431,"address":[1535988,1535968],"length":1,"stats":{"Line":10}},{"line":432,"address":[1681621,1682993,1681831],"length":1,"stats":{"Line":10}},{"line":433,"address":[1536064,1536084],"length":1,"stats":{"Line":10}},{"line":434,"address":[1536112,1536132],"length":1,"stats":{"Line":10}},{"line":435,"address":[1682491,1682948,1682299],"length":1,"stats":{"Line":10}},{"line":436,"address":[1536208,1536228],"length":1,"stats":{"Line":10}},{"line":437,"address":[1682697,1682909,1682855],"length":1,"stats":{"Line":10}},{"line":441,"address":[1683380,1683168,1683358],"length":1,"stats":{"Line":4}},{"line":442,"address":[1683172],"length":1,"stats":{"Line":6}},{"line":443,"address":[1536387],"length":1,"stats":{"Line":1}},{"line":444,"address":[1536394],"length":1,"stats":{"Line":1}},{"line":445,"address":[1536401],"length":1,"stats":{"Line":1}},{"line":446,"address":[1536408],"length":1,"stats":{"Line":1}},{"line":447,"address":[1536415],"length":1,"stats":{"Line":1}},{"line":448,"address":[1536422],"length":1,"stats":{"Line":1}},{"line":449,"address":[1536429],"length":1,"stats":{"Line":1}},{"line":450,"address":[1536436],"length":1,"stats":{"Line":1}},{"line":451,"address":[1536443],"length":1,"stats":{"Line":1}},{"line":452,"address":[1536450],"length":1,"stats":{"Line":1}},{"line":453,"address":[1536457],"length":1,"stats":{"Line":1}},{"line":454,"address":[1536464],"length":1,"stats":{"Line":1}},{"line":455,"address":[1536471],"length":1,"stats":{"Line":1}},{"line":456,"address":[1536478],"length":1,"stats":{"Line":1}},{"line":457,"address":[1536485],"length":1,"stats":{"Line":1}},{"line":458,"address":[1536492],"length":1,"stats":{"Line":1}},{"line":462,"address":[1683373,1683177],"length":1,"stats":{"Line":4}},{"line":466,"address":[1683392,1684758,1684786],"length":1,"stats":{"Line":4}},{"line":467,"address":[1684296,1684676,1683856,1684733,1683630,1683399,1684486,1684082],"length":1,"stats":{"Line":34}},{"line":468,"address":[1536560,1536580],"length":1,"stats":{"Line":10}},{"line":469,"address":[1683725,1684848,1683935],"length":1,"stats":{"Line":10}},{"line":470,"address":[1536656,1536676],"length":1,"stats":{"Line":10}},{"line":471,"address":[1684177,1684363,1684818],"length":1,"stats":{"Line":10}},{"line":472,"address":[1684553,1684379,1684803],"length":1,"stats":{"Line":10}},{"line":473,"address":[1684725,1684569,1684779],"length":1,"stats":{"Line":10}},{"line":477,"address":[1685117,1684880,1685095],"length":1,"stats":{"Line":4}},{"line":478,"address":[1536848,1536864],"length":1,"stats":{"Line":6}},{"line":479,"address":[1536931],"length":1,"stats":{"Line":1}},{"line":480,"address":[1536938],"length":1,"stats":{"Line":1}},{"line":481,"address":[1536945],"length":1,"stats":{"Line":1}},{"line":482,"address":[1536952],"length":1,"stats":{"Line":1}},{"line":483,"address":[1536959],"length":1,"stats":{"Line":1}},{"line":484,"address":[1536966],"length":1,"stats":{"Line":1}},{"line":485,"address":[1536973],"length":1,"stats":{"Line":1}},{"line":488,"address":[1684889,1685110],"length":1,"stats":{"Line":4}},{"line":492,"address":[1686053,1686081,1685136],"length":1,"stats":{"Line":4}},{"line":493,"address":[1685589,1685969,1685369,1685779,1686028,1685143],"length":1,"stats":{"Line":26}},{"line":494,"address":[1537040,1537060],"length":1,"stats":{"Line":10}},{"line":495,"address":[1685464,1685656,1686113],"length":1,"stats":{"Line":10}},{"line":496,"address":[1537156,1537136],"length":1,"stats":{"Line":10}},{"line":497,"address":[1537204,1537184],"length":1,"stats":{"Line":10}},{"line":503,"address":[1688223,1686144,1688251],"length":1,"stats":{"Line":4}},{"line":504,"address":[1686643,1687761,1688141,1686151,1687095,1688198,1687547,1686417,1687321,1686869,1687951],"length":1,"stats":{"Line":46}},{"line":505,"address":[1537280,1537300],"length":1,"stats":{"Line":10}},{"line":506,"address":[1537328,1537348],"length":1,"stats":{"Line":14}},{"line":507,"address":[1688343,1686738,1686948],"length":1,"stats":{"Line":10}},{"line":508,"address":[1537424,1537444],"length":1,"stats":{"Line":10}},{"line":509,"address":[1537492,1537472],"length":1,"stats":{"Line":10}},{"line":510,"address":[1537520,1537540],"length":1,"stats":{"Line":10}},{"line":511,"address":[1688283,1687642,1687828],"length":1,"stats":{"Line":10}},{"line":512,"address":[1537616,1537636],"length":1,"stats":{"Line":10}},{"line":513,"address":[1537664,1537684],"length":1,"stats":{"Line":10}},{"line":519,"address":[1688400,1691646,1691674],"length":1,"stats":{"Line":4}},{"line":520,"address":[1537712,1537732],"length":1,"stats":{"Line":66}},{"line":521,"address":[1688571,1691889,1688781],"length":1,"stats":{"Line":10}},{"line":522,"address":[1537828,1537808],"length":1,"stats":{"Line":10}},{"line":523,"address":[1691853,1689023,1689233],"length":1,"stats":{"Line":10}},{"line":524,"address":[1537904,1537924],"length":1,"stats":{"Line":10}},{"line":525,"address":[1691817,1689475,1689685],"length":1,"stats":{"Line":10}},{"line":526,"address":[1538000,1538020],"length":1,"stats":{"Line":10}},{"line":527,"address":[1691781,1690137,1689927],"length":1,"stats":{"Line":10}},{"line":528,"address":[1538096,1538116],"length":1,"stats":{"Line":10}},{"line":529,"address":[1538144,1538164],"length":1,"stats":{"Line":10}},{"line":530,"address":[1538192,1538212],"length":1,"stats":{"Line":10}},{"line":531,"address":[1538240,1538260],"length":1,"stats":{"Line":10}},{"line":532,"address":[1538288,1538308],"length":1,"stats":{"Line":10}},{"line":533,"address":[1691691,1691265,1691439],"length":1,"stats":{"Line":10}},{"line":534,"address":[1538384,1538404],"length":1,"stats":{"Line":10}},{"line":538,"address":[1691904],"length":1,"stats":{"Line":4}},{"line":539,"address":[1538432,1538452],"length":1,"stats":{"Line":6}},{"line":542,"address":[1691968],"length":1,"stats":{"Line":4}},{"line":543,"address":[1538480,1538500],"length":1,"stats":{"Line":6}},{"line":547,"address":[1692032,1692274,1692252],"length":1,"stats":{"Line":4}},{"line":548,"address":[1538528,1538759],"length":1,"stats":{"Line":8}},{"line":549,"address":[1538567,1538654,1538728],"length":1,"stats":{"Line":12}},{"line":550,"address":[1538620],"length":1,"stats":{"Line":4}},{"line":551,"address":[1538682],"length":1,"stats":{"Line":4}},{"line":553,"address":[1692198,1692151,1692071],"length":1,"stats":{"Line":12}},{"line":554,"address":[1692105,1692267,1692193],"length":1,"stats":{"Line":8}}],"covered":249,"coverable":267},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbc3","mod.rs"],"content":"mod assembler;\nmod assembly;\nmod ast;\nmod grammar;\nmod parser;\n\nuse self::assembler::Assembler;\nuse self::assembly::Assembly;\nuse self::ast::SourceProgramLine;\nuse self::parser::Parser;\n\nuse crate::args::Args;\nuse crate::list_writer::ListWriter;\nuse crate::model::*;\nuse crate::result::{Error, Result};\n\nuse std::path::Path;\n\npub struct Bbc3 {\n    args: Args,\n}\n\nimpl Bbc3 {\n    pub fn new(args: \u0026Args) -\u003e Bbc3 {\n        let args = args.clone();\n        Self { args }\n    }\n\n    fn impl_parse(\u0026self, path: \u0026Path) -\u003e Result\u003cVec\u003cResult\u003cSourceProgramLine\u003e\u003e\u003e {\n        let lines = file_lines(path)?;\n        let results = lines.iter().map(|line| Parser::parse_line(line));\n        Ok(results.collect())\n    }\n\n    fn impl_assemble(\u0026self, path: \u0026Path) -\u003e Result\u003cAssembly\u003e {\n        let parsed_lines = self.impl_parse(path)?;\n\n        let parsed_lines_len = parsed_lines.len();\n        let ast = parsed_lines\n            .iter()\n            .filter_map(|l| l.as_ref().ok())\n            .cloned()\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let all_ok = parsed_lines_len == ast.len();\n\n        if all_ok {\n            Assembler::assemble(\u0026ast)\n        } else {\n            let lines = file_lines(path)?;\n            let all_results = parsed_lines\n                .iter()\n                .zip(lines.iter())\n                .map(|(r, l)| match (r, l) {\n                    (Ok(_), l) =\u003e format!(\"        {}\", l),\n                    (Err(Error::FailedToParse(e)), l) =\u003e format!(\" *****  {}\\n         {}\", l, e),\n                    _ =\u003e unreachable!(),\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\\n\");\n            Err(Error::FailedToAssemble(all_results))\n        }\n    }\n\n    fn impl_run(\u0026self, _path: \u0026Path) -\u003e Result\u003c()\u003e {\n        Err(Error::FailedToRun(\n            \"BBC-3 run command is not implemented\".into(),\n        ))\n    }\n\n    fn impl_list(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        let mut writer = ListWriter::new(path, \u0026self.args);\n        let lines = file_lines(path)?;\n        let results = lines.iter().map(|line| Parser::parse_line(line));\n        for line in results {\n            let line = match line {\n                Ok(line) =\u003e format!(\"        {}\", line),\n                Err(Error::FailedToParse(error)) =\u003e format!(\" *****  {}\", error),\n                _ =\u003e unreachable!(),\n            };\n            writer.add_lines_to_listing(\u0026line);\n        }\n        writer\n            .write_content_to_file()\n            .map_err(|e| Error::CannotToWriteFile(path.display().to_string(), e.to_string()))\n    }\n}\n\nfn file_lines(path: \u0026Path) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let filename = path.display().to_string();\n\n    let content =\n        std::fs::read(path).map_err(|e| Error::CannotReadFile(filename.clone(), e.to_string()))?;\n\n    let content = String::from_utf8(content)\n        .map_err(|e| Error::CannotReadFile(filename.clone(), e.to_string()))?;\n\n    Ok(content.lines().map(|line| line.to_owned()).collect())\n}\n\nimpl LanguageModel for Bbc3 {\n    fn assemble(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        _ = self.impl_assemble(path)?;\n        Ok(())\n    }\n\n    fn run(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        self.impl_run(path)?;\n        unreachable!()\n    }\n\n    fn list(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        _ = self.impl_list(path);\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use tempdir::TempDir;\n\n    #[test]\n    fn will_assemble() {\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"./examples/test/bbc3/nthg.bbc\"]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let model = Bbc3::new(\u0026args);\n        let result = model.assemble(\u0026args.files().next().unwrap());\n        assert!(result.is_ok())\n    }\n\n    #[test]\n    fn will_not_run() {\n        let args = vec![\n            \"bbc-x\",\n            \"--lang=bbc3\",\n            \"--run\",\n            \"./examples/test/bbc3/nthg.bbc\",\n        ]\n        .into_iter()\n        .map(|s| s.to_string())\n        .collect();\n        let args = Args::from(args);\n        let model = Bbc3::new(\u0026args);\n        let result = model.run(\u0026args.files().next().unwrap());\n        assert!(result.is_err())\n    }\n\n    #[test]\n    fn will_list() {\n        let temp_folder = TempDir::new(\"bbcx-tests-bbc3\").unwrap();\n\n        let temp_target = temp_folder.path().join(\"nthg.bbc\");\n        let temp_target_str = temp_target.display().to_string();\n\n        std::fs::copy(\"./examples/test/bbc3/nthg.bbc\", temp_target).unwrap();\n\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"--list\", \u0026temp_target_str]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let model = Bbc3::new(\u0026args);\n        let _ = model.list(\u0026args.files().next().unwrap());\n\n        let list_target = temp_folder.path().join(\"nthg.lst\");\n        assert!(list_target.exists());\n    }\n}\n","traces":[{"line":24,"address":[1765872],"length":1,"stats":{"Line":3}},{"line":25,"address":[1765890],"length":1,"stats":{"Line":3}},{"line":29,"address":[1766401,1765936],"length":1,"stats":{"Line":1}},{"line":30,"address":[1766138,1766003],"length":1,"stats":{"Line":1}},{"line":31,"address":[1527936,1527971],"length":1,"stats":{"Line":4}},{"line":32,"address":[1766322],"length":1,"stats":{"Line":1}},{"line":35,"address":[1767895,1766432,1767990],"length":1,"stats":{"Line":1}},{"line":36,"address":[1766495,1766642],"length":1,"stats":{"Line":1}},{"line":38,"address":[1766627,1766749],"length":1,"stats":{"Line":2}},{"line":39,"address":[1766765],"length":1,"stats":{"Line":1}},{"line":41,"address":[1528000,1528025],"length":1,"stats":{"Line":2}},{"line":45,"address":[1767003,1766938],"length":1,"stats":{"Line":2}},{"line":47,"address":[1767021],"length":1,"stats":{"Line":1}},{"line":48,"address":[1767966,1767064],"length":1,"stats":{"Line":2}},{"line":50,"address":[1767049,1767100,1767233],"length":1,"stats":{"Line":2}},{"line":51,"address":[1767635,1767205,1767376,1767501],"length":1,"stats":{"Line":4}},{"line":53,"address":[1767413],"length":1,"stats":{"Line":1}},{"line":54,"address":[1528088,1528048,1528360],"length":1,"stats":{"Line":3}},{"line":55,"address":[1528153,1528264,1528358],"length":1,"stats":{"Line":3}},{"line":56,"address":[1528797,1528390,1528644],"length":1,"stats":{"Line":3}},{"line":57,"address":[1528802],"length":1,"stats":{"Line":0}},{"line":61,"address":[1767738],"length":1,"stats":{"Line":1}},{"line":65,"address":[1768016],"length":1,"stats":{"Line":1}},{"line":66,"address":[1768078],"length":1,"stats":{"Line":1}},{"line":67,"address":[1768044],"length":1,"stats":{"Line":1}},{"line":71,"address":[1768144,1769399,1770128],"length":1,"stats":{"Line":1}},{"line":72,"address":[1768211],"length":1,"stats":{"Line":1}},{"line":73,"address":[1768329,1768463,1768266],"length":1,"stats":{"Line":2}},{"line":74,"address":[1528832,1528867],"length":1,"stats":{"Line":4}},{"line":75,"address":[1768680,1768801,1769943],"length":1,"stats":{"Line":3}},{"line":76,"address":[1769109,1768851],"length":1,"stats":{"Line":2}},{"line":77,"address":[1768963,1769137,1769298],"length":1,"stats":{"Line":2}},{"line":78,"address":[1769609,1769774,1769408],"length":1,"stats":{"Line":2}},{"line":81,"address":[1769858,1769379],"length":1,"stats":{"Line":2}},{"line":83,"address":[1768789,1768911],"length":1,"stats":{"Line":2}},{"line":85,"address":[1528896,1528927],"length":1,"stats":{"Line":0}},{"line":89,"address":[1771154,1770144,1771101],"length":1,"stats":{"Line":1}},{"line":90,"address":[1770203],"length":1,"stats":{"Line":1}},{"line":92,"address":[1529224,1529200],"length":1,"stats":{"Line":2}},{"line":95,"address":[1770444,1770874,1771110,1770657],"length":1,"stats":{"Line":2}},{"line":96,"address":[1529440,1529464],"length":1,"stats":{"Line":0}},{"line":98,"address":[1529733,1529680],"length":1,"stats":{"Line":4}},{"line":102,"address":[1771168],"length":1,"stats":{"Line":1}},{"line":103,"address":[1771337,1771209],"length":1,"stats":{"Line":2}},{"line":104,"address":[1771328],"length":1,"stats":{"Line":1}},{"line":107,"address":[1771408],"length":1,"stats":{"Line":1}},{"line":108,"address":[1771424,1771524],"length":1,"stats":{"Line":2}},{"line":112,"address":[1771584],"length":1,"stats":{"Line":1}},{"line":113,"address":[1771613],"length":1,"stats":{"Line":1}},{"line":114,"address":[1771643],"length":1,"stats":{"Line":1}}],"covered":47,"coverable":50},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbc3","parser.rs"],"content":"use super::ast::*;\nuse super::grammar::*;\n\nuse crate::result::{Error, Result};\n\npub struct Parser;\n\nimpl Parser {\n    pub fn parse_line(input: \u0026str) -\u003e Result\u003cSourceProgramLine\u003e {\n        Grammar::bbc3_line()\n            .parse(input.trim().as_bytes())\n            .map_err(|_| Error::FailedToParse(input.into()))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use pretty_assertions::assert_eq;\n\n    type SourceProgram = Vec\u003cResult\u003cSourceProgramLine\u003e\u003e;\n\n    fn parse(input: \u0026str) -\u003e SourceProgram {\n        input\n            .to_string()\n            .lines()\n            .map(Parser::parse_line)\n            .collect::\u003cSourceProgram\u003e()\n    }\n\n    fn from_pwords(pwords: \u0026[PWord]) -\u003e SourceProgram {\n        pwords\n            .iter()\n            .enumerate()\n            .map(|(i, p)| {\n                Ok(SourceProgramLine::new(\n                    i + 1,\n                    SourceProgramWord::PWord(p.clone()),\n                    \"\".into(),\n                ))\n            })\n            .collect::\u003cSourceProgram\u003e()\n    }\n\n    #[test]\n    fn locations_and_comments() {\n        let program = r#\"\n0001    \u003c    \u003e\n0002    \u003c  C1\u003e      ; Comment 1\n\"#;\n        let actual = parse(program);\n        let expected = vec![\n            Ok(SourceProgramLine::new(\n                1,\n                SourceProgramWord::SWord(\"    \".into()),\n                \"\".into(),\n            )),\n            Ok(SourceProgramLine::new(\n                2,\n                SourceProgramWord::SWord(\"  C1\".into()),\n                \"; Comment 1\".into(),\n            )),\n        ]\n        .into_iter()\n        .collect::\u003cSourceProgram\u003e();\n        assert_eq!(actual[1..], expected);\n    }\n\n    #[test]\n    fn sword() {\n        let program = r#\"0001   \u003cTEXT\u003e\n\"#;\n        let actual = parse(program);\n        let expected = vec![Ok(SourceProgramLine::new(\n            1,\n            SourceProgramWord::SWord(\"TEXT\".into()),\n            \"\".into(),\n        ))]\n        .into_iter()\n        .collect::\u003cSourceProgram\u003e();\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn pword_take_type() {\n        let program = r#\"\n0001    ADD     ADDR1\n0002    ADD2    ADDR2\n0003    SKAG    ADDR3\n0004    SKAG2   ADDR4\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::TakeType(\n                Mnemonic::ADD,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                '2'.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR2\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::SKAG,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR3\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::SKAG,\n                '2'.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR4\".into())),\n                    None,\n                )),\n            ),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn pword_put_type() {\n        let program = r#\"\n0001    XADD    ADDR1\n0002    INCR    ADDR2\n0003    XINCR2  ADDR3\n0004    JUMP2   ADDR4\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::PutType(\n                Mnemonic::XADD,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::INCR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR2\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XINCR,\n                '2'.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR3\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::JUMP,\n                '2'.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR4\".into())),\n                    None,\n                ),\n            ),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn pword_loadn() {\n        let program = r#\"\n0001    LDN     ADDR1:42\n0002    LDN2    ADDR2:57\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::LoadN(\n                None.into(),\n                SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                42,\n            ),\n            PWord::LoadN(\n                '2'.into(),\n                SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR2\".into())),\n                57,\n            ),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn pword_loadr_const() {\n        let program = r#\"\n0001    LDR     +24:42\n0002    LDR2    -3.14:57\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::LoadRConst(None.into(), ConstOperand::SignedInteger(24), 42),\n            PWord::LoadRConst('2'.into(), ConstOperand::SignedFWord(-3.14), 57),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn pword_loadr() {\n        let program = r#\"\n0001    LDR     ADDR1:42\n0002    LDR2    ADDR2:57\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::LoadR(\n                None.into(),\n                SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                42,\n            ),\n            PWord::LoadR(\n                '2'.into(),\n                SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR2\".into())),\n                57,\n            ),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn pword_library_mnemonic() {\n        let program = r#\"\n0001    SQRT\n0002    LN\n0003    EXP\n0004    READ\n0005    PRINT\n0006    SIN\n0007    COS\n0008    TAN\n0009    ARCTAN\n0010    STOP\n0011    LINE\n0012    INT\n0013    FRAC\n0014    FLOAT\n0015    CAPTN\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::LibraryMnemonic(Mnemonic::SQRT),\n            PWord::LibraryMnemonic(Mnemonic::LN),\n            PWord::LibraryMnemonic(Mnemonic::EXP),\n            PWord::LibraryMnemonic(Mnemonic::READ),\n            PWord::LibraryMnemonic(Mnemonic::PRINT),\n            PWord::LibraryMnemonic(Mnemonic::SIN),\n            PWord::LibraryMnemonic(Mnemonic::COS),\n            PWord::LibraryMnemonic(Mnemonic::TAN),\n            PWord::LibraryMnemonic(Mnemonic::ARCTAN),\n            PWord::LibraryMnemonic(Mnemonic::STOP),\n            PWord::LibraryMnemonic(Mnemonic::LINE),\n            PWord::LibraryMnemonic(Mnemonic::INT),\n            PWord::LibraryMnemonic(Mnemonic::FRAC),\n            PWord::LibraryMnemonic(Mnemonic::FLOAT),\n            PWord::LibraryMnemonic(Mnemonic::CAPTN),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn fword() {\n        let program = r#\"\n0001   3.14\n\"#;\n        let actual = parse(program);\n        let expected = vec![Ok(SourceProgramLine::new(\n            1,\n            SourceProgramWord::FWord(3.14),\n            \"\".into(),\n        ))];\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn iword() {\n        let program = r#\"\n0001   42\n\"#;\n        let actual = parse(program);\n        let expected = vec![Ok(SourceProgramLine::new(\n            1,\n            SourceProgramWord::IWord(42),\n            \"\".into(),\n        ))];\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn octal() {\n        let program = r#\"\n0001    (S11110000)\n0002    (P33332222)\n0003    (F55554444)\n0004    (I77776666)\n\"#;\n        let actual = parse(program);\n        let expected = vec![\n            Ok(SourceProgramLine::new(\n                1,\n                SourceProgramWord::Octal(Octal::S(0o11110000)),\n                \"\".into(),\n            )),\n            Ok(SourceProgramLine::new(\n                2,\n                SourceProgramWord::Octal(Octal::P(0o33332222)),\n                \"\".into(),\n            )),\n            Ok(SourceProgramLine::new(\n                3,\n                SourceProgramWord::Octal(Octal::F(0o55554444)),\n                \"\".into(),\n            )),\n            Ok(SourceProgramLine::new(\n                4,\n                SourceProgramWord::Octal(Octal::I(0o77776666)),\n                \"\".into(),\n            )),\n        ];\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn octal_display() {\n        assert_eq!(format!(\"{}\", Octal::S(0o11110000)), \"(S11110000)\");\n        assert_eq!(format!(\"{}\", Octal::P(0o33332222)), \"(P33332222)\");\n        assert_eq!(format!(\"{}\", Octal::F(0o55554444)), \"(F55554444)\");\n        assert_eq!(format!(\"{}\", Octal::I(0o77776666)), \"(I77776666)\")\n    }\n\n    #[test]\n    fn addressing_modes() {\n        let program = r#\"\n0001    ADD     ADDR1\n0002    ADD2    ADDR2:42\n0003    ADD     *ADDR3\n0004    ADD2    *ADDR4:42\n0005    ADD     512\n0006    ADD2    512+\n0007    ADD     -42\n0008    ADD2    +3.14\n0009    ADD     (I01234567)\n0010    ADD2    \u003cTEXT\u003e\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::TakeType(\n                Mnemonic::ADD,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                '2'.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR2\".into())),\n                    Some(42),\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::IndirectAddress(Address::Identifier(\"ADDR3\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                '2'.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::IndirectAddress(Address::Identifier(\"ADDR4\".into())),\n                    Some(42),\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::NumericAddress(\n                        NumericAddress::AbsoluteAddress(512),\n                    )),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                '2'.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::NumericAddress(\n                        NumericAddress::RelativeAddress(512),\n                    )),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                None.into(),\n                GeneralOperand::ConstOperand(ConstOperand::SignedInteger(-42)),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                '2'.into(),\n                GeneralOperand::ConstOperand(ConstOperand::SignedFWord(3.14)),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                None.into(),\n                GeneralOperand::ConstOperand(ConstOperand::Octal(Octal::I(0o1234567))),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                '2'.into(),\n                GeneralOperand::ConstOperand(ConstOperand::SWord(\"TEXT\".into())),\n            ),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn mnemonics() {\n        let program = r#\"\n0001    LDN         ADDR1:42\n0002    LDR         ADDR1:42\n0003    NTHG        ADDR1\n0004    ADD         ADDR1\n0005    SUBT        ADDR1\n0006    MPLY        ADDR1\n0007    DVD         ADDR1\n0008    TAKE        ADDR1\n0009    NEG         ADDR1\n0010    MOD         ADDR1\n0011    CLR         ADDR1\n0012    AND         ADDR1\n0013    OR          ADDR1\n0014    NEQV        ADDR1\n0015    NOT         ADDR1\n0016    SHFR        ADDR1\n0017    CYCR        ADDR1\n0018    OPUT        ADDR1\n0019    XNTHG       ADDR1\n0020    XADD        ADDR1\n0021    XSUBT       ADDR1\n0022    XMPLY       ADDR1\n0023    XDVD        ADDR1\n0024    XTAKE       ADDR1\n0025    XNEG        ADDR1\n0026    XMOD        ADDR1\n0027    XCLR        ADDR1\n0028    XAND        ADDR1\n0029    XOR         ADDR1\n0030    XNEQV       ADDR1\n0031    XNOT        ADDR1\n0032    XSHFR       ADDR1\n0033    XCYCR       ADDR1\n0034    XOPUT       ADDR1\n0035    IPUT        ADDR1\n0036    PUT         ADDR1\n0037    INCR        ADDR1\n0038    DECR        ADDR1\n0039    TYPE        ADDR1\n0040    CHYP        ADDR1\n0041    EXEC        ADDR1\n0042    XIPUT       ADDR1\n0043    XPUT        ADDR1\n0044    XINCR       ADDR1\n0045    XDECR       ADDR1\n0046    XTYPE       ADDR1\n0047    XCHYP       ADDR1\n0048    XEXEC       ADDR1\n0049    SKET        ADDR1\n0050    SKAE        ADDR1\n0051    SKAN        ADDR1\n0052    SKAL        ADDR1\n0053    SKAG        ADDR1\n0054    LIBR        ADDR1\n0055    JLIK        ADDR1\n0056    JUMP        ADDR1\n0057    JEZ         ADDR1\n0058    JNZ         ADDR1\n0059    JLZ         ADDR1\n0060    JGZ         ADDR1\n0061    JOI         ADDR1\n0062    SLIK        ADDR1\n0063    SNLZ        ADDR1\n0064    SQRT\n0065    LN\n0066    EXP\n0067    READ\n0068    PRINT\n0069    SIN\n0070    COS\n0071    TAN\n0072    ARCTAN\n0073    STOP\n0074    LINE\n0075    INT\n0076    FRAC\n0077    FLOAT\n0078    CAPTN\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::LoadN(\n                None.into(),\n                SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                42,\n            ),\n            PWord::LoadR(\n                None.into(),\n                SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                42,\n            ),\n            PWord::TakeType(\n                Mnemonic::NTHG,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::ADD,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::SUBT,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::MPLY,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::DVD,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::TAKE,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::NEG,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::MOD,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::CLR,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::AND,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::OR,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::NEQV,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::NOT,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::SHFR,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::CYCR,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::OPUT,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::PutType(\n                Mnemonic::XNTHG,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XADD,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XSUBT,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XMPLY,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XDVD,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XTAKE,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XNEG,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XMOD,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XCLR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XAND,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XOR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XNEQV,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XNOT,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XSHFR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XCYCR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XOPUT,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::IPUT,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::PUT,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::INCR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::DECR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::TYPE,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::CHYP,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::EXEC,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XIPUT,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XPUT,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XINCR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XDECR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XTYPE,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XCHYP,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::XEXEC,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::TakeType(\n                Mnemonic::SKET,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::SKAE,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::SKAN,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::SKAL,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::TakeType(\n                Mnemonic::SKAG,\n                None.into(),\n                GeneralOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::PutType(\n                Mnemonic::LIBR,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::JLIK,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::JUMP,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::JEZ,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::JNZ,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::JLZ,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::JGZ,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::JOI,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::SLIK,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::PutType(\n                Mnemonic::SNLZ,\n                None.into(),\n                AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                ),\n            ),\n            PWord::LibraryMnemonic(Mnemonic::SQRT),\n            PWord::LibraryMnemonic(Mnemonic::LN),\n            PWord::LibraryMnemonic(Mnemonic::EXP),\n            PWord::LibraryMnemonic(Mnemonic::READ),\n            PWord::LibraryMnemonic(Mnemonic::PRINT),\n            PWord::LibraryMnemonic(Mnemonic::SIN),\n            PWord::LibraryMnemonic(Mnemonic::COS),\n            PWord::LibraryMnemonic(Mnemonic::TAN),\n            PWord::LibraryMnemonic(Mnemonic::ARCTAN),\n            PWord::LibraryMnemonic(Mnemonic::STOP),\n            PWord::LibraryMnemonic(Mnemonic::LINE),\n            PWord::LibraryMnemonic(Mnemonic::INT),\n            PWord::LibraryMnemonic(Mnemonic::FRAC),\n            PWord::LibraryMnemonic(Mnemonic::FLOAT),\n            PWord::LibraryMnemonic(Mnemonic::CAPTN),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual.len(), expected.len() + 1);\n        let results = actual.iter().skip(1).zip(expected.iter());\n        for (line, expected) in results {\n            // Line by line assert easier to detect errors.\n            assert_eq!(line, expected)\n        }\n    }\n\n    #[test]\n    fn invalid_syntax() {\n        let program = r#\"\n0001\n0002    Invalid One\n0003\n0004    SQRT        ; Valid\n0005\n0006    Invalid Two\n\"#;\n        let actual = parse(program);\n        let expected = vec![\n            Err(Error::FailedToParse(\"0001\".into())),\n            Err(Error::FailedToParse(\"0002    Invalid One\".into())),\n            Err(Error::FailedToParse(\"0003\".into())),\n            Ok(SourceProgramLine::new(\n                4,\n                SourceProgramWord::PWord(PWord::LibraryMnemonic(Mnemonic::SQRT)),\n                \"; Valid\".into(),\n            )),\n            Err(Error::FailedToParse(\"0005\".into())),\n            Err(Error::FailedToParse(\"0006    Invalid Two\".into())),\n        ];\n        assert_eq!(actual[1..], expected)\n    }\n}\n","traces":[{"line":9,"address":[1893246,1893008],"length":1,"stats":{"Line":2}},{"line":10,"address":[1893050,1893187],"length":1,"stats":{"Line":6}},{"line":11,"address":[1893081],"length":1,"stats":{"Line":4}},{"line":12,"address":[1835037,1835008],"length":1,"stats":{"Line":8}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","assembler.rs"],"content":"use super::assembly::{Assembly, Code, Symbols};\nuse super::ast::SourceLine;\n\nuse crate::result::{Error, Result};\n\nuse std::collections::HashMap;\n\n#[derive(Debug, PartialEq)]\npub struct Assembler {}\n\nimpl Assembler {\n    pub fn assemble(ast: \u0026[SourceLine]) -\u003e Result\u003cAssembly\u003e {\n        validate_ast(ast)?;\n        let code = generate_code(ast);\n        let symbols = generate_symbol_table(ast);\n        let assembly = Assembly::new(\u0026code, \u0026symbols);\n        Ok(assembly)\n    }\n}\n\nfn validate_ast(ast: \u0026[SourceLine]) -\u003e Result\u003c()\u003e {\n    let mut invalid_locations = ast\n        .iter()\n        .fold(HashMap::new(), |mut counts, line| {\n            *counts.entry(line.location()).or_insert(0) += 1;\n            counts\n        })\n        .into_iter()\n        .filter(|\u0026(_key, value)| (value \u003e 1))\n        .map(|(key, _value)| key)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut invalid_labels = ast\n        .iter()\n        .fold(HashMap::new(), |mut counts, line| {\n            *counts.entry(line.label()).or_insert(0) += 1;\n            counts\n        })\n        .into_iter()\n        .filter(|\u0026(key, value)| (key.name().is_some() \u0026\u0026 value \u003e 1))\n        .map(|(key, _value)| key)\n        .collect::\u003cVec\u003c_\u003e\u003e();\n\n    if invalid_locations.is_empty() \u0026\u0026 invalid_labels.is_empty() {\n        Ok(())\n    } else {\n        invalid_locations.sort();\n        let invalid_locations = invalid_locations\n            .into_iter()\n            .map(|l| l.to_string())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\", \");\n        invalid_labels.sort();\n        let invalid_labels = invalid_labels\n            .into_iter()\n            .map(|l| l.to_string())\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\", \");\n\n        let error = format!(\n            \"Multiple definitions: locations: \\\"{}\\\", labels: \\\"{}\\\"\",\n            invalid_locations, invalid_labels\n        );\n        Err(Error::FailedToAssemble(error))\n    }\n}\n\nfn generate_code(ast: \u0026[SourceLine]) -\u003e Code {\n    ast.iter()\n        .map(|line| (*line.location(), line.source_program_word().clone()))\n        .collect::\u003cCode\u003e()\n}\n\nfn generate_symbol_table(ast: \u0026[SourceLine]) -\u003e Symbols {\n    ast.iter()\n        .filter_map(|line| line.label().name().map(|name| (name, *line.location())))\n        .collect::\u003cSymbols\u003e()\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::bbcx::{ast::*, Parser};\n    use pretty_assertions::assert_eq;\n\n    type SourceProgram = Vec\u003cSourceLine\u003e;\n\n    fn parse(input: \u0026str) -\u003e SourceProgram {\n        input\n            .to_string()\n            .lines()\n            .map(|l| Parser::parse_line(l))\n            .filter_map(Result::ok)\n            .collect::\u003cSourceProgram\u003e()\n    }\n\n    #[test]\n    fn requires_unique_locations() {\n        let program = r#\"\n0001    JUMP    0001\n0002    JUMP    HERE\n\"#;\n        let program = parse(program);\n        let assembly = Assembler::assemble(\u0026program).unwrap();\n        assert_eq!(assembly.content(0), None);\n        assert_eq!(\n            assembly.content(1),\n            Some(SourceWord::PWord(PWord::new(\n                Mnemonic::JUMP,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::NumericAddress(1)),\n                    None\n                ))\n            )))\n        );\n        assert_eq!(\n            assembly.content(2),\n            Some(SourceWord::PWord(PWord::new(\n                Mnemonic::JUMP,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"HERE\".into())),\n                    None\n                ))\n            )))\n        );\n    }\n\n    #[test]\n    fn fails_when_location_not_unique() {\n        let program = r#\"\n0001    JUMP    0001\n0001    JUMP    HERE\n0002    JUMP    0002\n0002    JUMP    THERE\n\"#;\n        let program = parse(program);\n        let result = Assembler::assemble(\u0026program).err().unwrap();\n        assert_eq!(\n            result,\n            Error::FailedToAssemble(\n                \"Multiple definitions: locations: \\\"1, 2\\\", labels: \\\"\\\"\".into()\n            )\n        );\n    }\n\n    #[test]\n    fn expects_unique_labels() {\n        let program = r#\"\n0001    LABEL1: JUMP    0001\n0002    LABEL2: JUMP    HERE\n\"#;\n        let program = parse(program);\n        let assembly = Assembler::assemble(\u0026program).unwrap();\n        assert_eq!(assembly.location(\"LABEL1\".into()), 1.into());\n        assert_eq!(assembly.location(\"LABEL2\".into()), 2.into());\n    }\n\n    #[test]\n    fn fails_when_labels_not_unique() {\n        let program = r#\"\n0001    LABEL1: JUMP    0001\n0002    LABEL1: JUMP    THERE\n0003    LABEL2: JUMP    0001\n0004    LABEL2: JUMP    THERE\n\"#;\n        let program = parse(program);\n        let result = Assembler::assemble(\u0026program);\n        let result = result.err().unwrap();\n        assert_eq!(\n            result,\n            Error::FailedToAssemble(\n                \"Multiple definitions: locations: \\\"\\\", labels: \\\"LABEL1:, LABEL2:\\\"\".into()\n            )\n        );\n    }\n\n    #[test]\n    fn will_create_intermediate_code_representation() {\n        let program = r#\"\n0001    JUMP    ALPHA\n0002    JUMP    EPSILON\n\"#;\n        let program = parse(program);\n        let assembly = Assembler::assemble(\u0026program).unwrap();\n        assert_eq!(assembly.content(0), None);\n        assert_eq!(\n            assembly.content(1),\n            Some(SourceWord::PWord(PWord::new(\n                Mnemonic::JUMP,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ALPHA\".into())),\n                    None\n                ))\n            )))\n        );\n        assert_eq!(\n            assembly.content(2),\n            Some(SourceWord::PWord(PWord::new(\n                Mnemonic::JUMP,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"EPSILON\".into())),\n                    None\n                ))\n            )))\n        );\n        assert_eq!(assembly.content(3), None);\n    }\n}\n","traces":[{"line":12,"address":[1651889,1651472],"length":1,"stats":{"Line":3}},{"line":13,"address":[1651611,1651499],"length":1,"stats":{"Line":2}},{"line":14,"address":[1651581],"length":1,"stats":{"Line":1}},{"line":15,"address":[1651604],"length":1,"stats":{"Line":1}},{"line":16,"address":[1651728],"length":1,"stats":{"Line":1}},{"line":17,"address":[1651777],"length":1,"stats":{"Line":1}},{"line":21,"address":[1651920,1653735,1653833],"length":1,"stats":{"Line":3}},{"line":22,"address":[1652083,1651991],"length":1,"stats":{"Line":2}},{"line":24,"address":[1640560,1640765],"length":1,"stats":{"Line":6}},{"line":25,"address":[1640745,1640602,1640660],"length":1,"stats":{"Line":4}},{"line":26,"address":[1640725],"length":1,"stats":{"Line":1}},{"line":29,"address":[1640784,1640794],"length":1,"stats":{"Line":4}},{"line":30,"address":[1640832,1640849],"length":1,"stats":{"Line":2}},{"line":33,"address":[1652220,1652351],"length":1,"stats":{"Line":4}},{"line":35,"address":[1640864,1641069],"length":1,"stats":{"Line":2}},{"line":36,"address":[1640964,1640906,1641049],"length":1,"stats":{"Line":4}},{"line":37,"address":[1641029],"length":1,"stats":{"Line":3}},{"line":40,"address":[1641088,1641105],"length":1,"stats":{"Line":4}},{"line":41,"address":[1641297,1641280],"length":1,"stats":{"Line":2}},{"line":44,"address":[1652466,1652522,1652594,1652561],"length":1,"stats":{"Line":5}},{"line":45,"address":[1652587],"length":1,"stats":{"Line":1}},{"line":47,"address":[1652536,1652609],"length":1,"stats":{"Line":3}},{"line":48,"address":[1652616,1652808],"length":1,"stats":{"Line":3}},{"line":50,"address":[1641312,1641347],"length":1,"stats":{"Line":2}},{"line":53,"address":[1652911],"length":1,"stats":{"Line":1}},{"line":54,"address":[1652945,1653137],"length":1,"stats":{"Line":3}},{"line":56,"address":[1641376,1641411],"length":1,"stats":{"Line":2}},{"line":60,"address":[1653452],"length":1,"stats":{"Line":1}},{"line":64,"address":[1653594],"length":1,"stats":{"Line":1}},{"line":68,"address":[1653872],"length":1,"stats":{"Line":1}},{"line":69,"address":[1653922],"length":1,"stats":{"Line":1}},{"line":70,"address":[1641475,1641440],"length":1,"stats":{"Line":2}},{"line":74,"address":[1653968],"length":1,"stats":{"Line":1}},{"line":75,"address":[1654018],"length":1,"stats":{"Line":1}},{"line":76,"address":[1641589,1641648,1641666,1641552],"length":1,"stats":{"Line":4}}],"covered":35,"coverable":35},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","assembly.rs"],"content":"use super::ast::{\n    Address as AstAddress, AddressOperand, Identifier, Location as AstLocation, PWord as AstPWord,\n    SimpleAddressOperand as AstSimpleAddressOperand, SourceWord as AstSourceWord,\n    StoreOperand as AstStoreOperand,\n};\n\nuse std::collections::HashMap;\n\npub type Location = AstLocation;\npub type Content = AstSourceWord;\n\npub type Code = HashMap\u003cLocation, Content\u003e;\npub type Symbols = HashMap\u003cIdentifier, Location\u003e;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct Assembly {\n    code: Code,\n    symbols: Symbols,\n}\n\nimpl Assembly {\n    pub fn new(code: \u0026Code, symbols: \u0026Symbols) -\u003e Self {\n        let code = code.clone();\n        let symbols = symbols.clone();\n        Self { code, symbols }\n    }\n\n    #[cfg(test)]\n    pub fn content(\u0026self, location: Location) -\u003e Option\u003cContent\u003e {\n        self.code.get(\u0026location).cloned()\n    }\n\n    fn code_iter(\u0026self) -\u003e impl Iterator\u003cItem = (\u0026Location, \u0026Content)\u003e {\n        let mut keys = Vec::from_iter(self.code.keys());\n        keys.sort();\n        keys.into_iter()\n            .map(|location| (location, \u0026self.code[location]))\n    }\n\n    pub fn linked_code(\u0026self) -\u003e Code {\n        let mut keys = Vec::from_iter(self.code.keys());\n        keys.sort();\n        keys.into_iter()\n            .map(|location| (*location, self.linked_content(\u0026self.code[location])))\n            .collect::\u003cCode\u003e()\n    }\n\n    fn linked_content(\u0026self, content: \u0026Content) -\u003e Content {\n        match content {\n            Content::PWord(pword) =\u003e Content::PWord(self.linked_pword(pword)),\n            other =\u003e other.clone(),\n        }\n    }\n\n    fn linked_pword(\u0026self, pword: \u0026AstPWord) -\u003e AstPWord {\n        AstPWord::new(\n            pword.mnemonic(),\n            pword.accumulator(),\n            self.linked_storage_operand(pword.store_operand()),\n        )\n    }\n\n    fn linked_storage_operand(\u0026self, operand: AstStoreOperand) -\u003e AstStoreOperand {\n        match operand {\n            AstStoreOperand::AddressOperand(address_operand) =\u003e {\n                AstStoreOperand::AddressOperand(self.linked_address_operand(address_operand))\n            }\n            other =\u003e other,\n        }\n    }\n\n    pub fn address_used_by_store_operand(\u0026self, operand: AstStoreOperand) -\u003e Location {\n        match operand {\n            AstStoreOperand::None =\u003e 0,\n            AstStoreOperand::AddressOperand(address_operand) =\u003e {\n                self.address_used_by_address_operand(address_operand)\n            }\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    fn linked_address_operand(\u0026self, operand: AddressOperand) -\u003e AddressOperand {\n        AddressOperand::new(\n            self.linked_simple_address_operand(operand.address()),\n            operand.index(),\n        )\n    }\n\n    fn address_used_by_address_operand(\u0026self, operand: AddressOperand) -\u003e Location {\n        self.address_used_by_simple_address_operand(operand.address())\n    }\n\n    fn linked_simple_address_operand(\n        \u0026self,\n        operand: AstSimpleAddressOperand,\n    ) -\u003e AstSimpleAddressOperand {\n        match operand {\n            AstSimpleAddressOperand::DirectAddress(address) =\u003e {\n                AstSimpleAddressOperand::DirectAddress(self.linked_address(address))\n            }\n            AstSimpleAddressOperand::IndirectAddress(address) =\u003e {\n                AstSimpleAddressOperand::IndirectAddress(self.linked_address(address))\n            }\n        }\n    }\n\n    fn address_used_by_simple_address_operand(\u0026self, operand: AstSimpleAddressOperand) -\u003e Location {\n        match operand {\n            AstSimpleAddressOperand::DirectAddress(address)\n            | AstSimpleAddressOperand::IndirectAddress(address) =\u003e self.address_used_by(address),\n        }\n    }\n\n    fn linked_address(\u0026self, address: AstAddress) -\u003e AstAddress {\n        match address {\n            AstAddress::Identifier(id) =\u003e AstAddress::NumericAddress(self.symbols[\u0026id]),\n            other =\u003e other,\n        }\n    }\n\n    fn address_used_by(\u0026self, address: AstAddress) -\u003e Location {\n        match address {\n            AstAddress::NumericAddress(a) =\u003e a,\n            _ =\u003e unreachable!(),\n        }\n    }\n\n    pub fn location(\u0026self, label: \u0026str) -\u003e Option\u003cLocation\u003e {\n        self.symbols.get(label).copied()\n    }\n\n    pub fn allocate_storage_locations(mut self) -\u003e Self {\n        let undefined_symbols = self.undefined_symbols();\n        let mut store_location: usize = 1024;\n        undefined_symbols.into_iter().for_each(|identifier| {\n            store_location -= 1;\n            self.symbols.insert(identifier, store_location);\n        });\n        self\n    }\n\n    fn undefined_symbols(\u0026self) -\u003e Vec\u003cIdentifier\u003e {\n        self.code_iter()\n            .filter_map(|(_, content)| match content {\n                AstSourceWord::PWord(pword) =\u003e Some(pword),\n                _ =\u003e None,\n            })\n            .filter_map(|pword| match pword.store_operand() {\n                AstStoreOperand::None =\u003e None,\n                AstStoreOperand::ConstOperand(_) =\u003e None,\n                AstStoreOperand::AddressOperand(operand) =\u003e Some(operand.address()),\n            })\n            .map(|address| match address {\n                AstSimpleAddressOperand::DirectAddress(address) =\u003e address,\n                AstSimpleAddressOperand::IndirectAddress(address) =\u003e address,\n            })\n            .filter_map(|address| match address {\n                AstAddress::Identifier(identifer) =\u003e Some(identifer),\n                AstAddress::NumericAddress(_) =\u003e None,\n            })\n            .filter_map(|identifier| match self.location(\u0026identifier) {\n                Some(_) =\u003e None,\n                None =\u003e Some(identifier),\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e()\n    }\n\n    pub fn first_pword_location(\u0026self) -\u003e Option\u003cLocation\u003e {\n        self.code_iter()\n            .find_map(|(location, content)| match content {\n                AstSourceWord::PWord(_) =\u003e Some(*location),\n                _ =\u003e None,\n            })\n    }\n}\n","traces":[{"line":22,"address":[1581757,1581584],"length":1,"stats":{"Line":1}},{"line":23,"address":[1581626],"length":1,"stats":{"Line":1}},{"line":24,"address":[1581641],"length":1,"stats":{"Line":1}},{"line":29,"address":[1581792],"length":1,"stats":{"Line":1}},{"line":30,"address":[1581827],"length":1,"stats":{"Line":1}},{"line":33,"address":[1582161,1581872,1582136],"length":1,"stats":{"Line":3}},{"line":34,"address":[1581902],"length":1,"stats":{"Line":3}},{"line":35,"address":[1581958,1582026],"length":1,"stats":{"Line":6}},{"line":36,"address":[1582033],"length":1,"stats":{"Line":3}},{"line":37,"address":[1636770,1636752],"length":1,"stats":{"Line":4}},{"line":40,"address":[1582176,1582455,1582480],"length":1,"stats":{"Line":1}},{"line":41,"address":[1582205],"length":1,"stats":{"Line":1}},{"line":42,"address":[1582261,1582329],"length":1,"stats":{"Line":2}},{"line":43,"address":[1582336],"length":1,"stats":{"Line":1}},{"line":44,"address":[1636800,1636837],"length":1,"stats":{"Line":4}},{"line":48,"address":[1582496],"length":1,"stats":{"Line":3}},{"line":49,"address":[1582530],"length":1,"stats":{"Line":3}},{"line":50,"address":[1582570],"length":1,"stats":{"Line":3}},{"line":51,"address":[1582617],"length":1,"stats":{"Line":3}},{"line":55,"address":[1582640],"length":1,"stats":{"Line":3}},{"line":57,"address":[1582689],"length":1,"stats":{"Line":3}},{"line":58,"address":[1582702],"length":1,"stats":{"Line":3}},{"line":59,"address":[1582715],"length":1,"stats":{"Line":3}},{"line":63,"address":[1583077,1583053,1582784],"length":1,"stats":{"Line":3}},{"line":64,"address":[1582818],"length":1,"stats":{"Line":3}},{"line":65,"address":[1582869],"length":1,"stats":{"Line":3}},{"line":66,"address":[1583026,1582905],"length":1,"stats":{"Line":6}},{"line":68,"address":[1582916],"length":1,"stats":{"Line":3}},{"line":72,"address":[1583152,1583234,1583502,1583480],"length":1,"stats":{"Line":3}},{"line":73,"address":[1583174],"length":1,"stats":{"Line":3}},{"line":74,"address":[1583236],"length":1,"stats":{"Line":1}},{"line":75,"address":[1583257],"length":1,"stats":{"Line":3}},{"line":76,"address":[1583425,1583293],"length":1,"stats":{"Line":6}},{"line":82,"address":[1583520,1583772],"length":1,"stats":{"Line":3}},{"line":84,"address":[1583632,1583563],"length":1,"stats":{"Line":6}},{"line":85,"address":[1583649],"length":1,"stats":{"Line":3}},{"line":89,"address":[1583808,1583909],"length":1,"stats":{"Line":3}},{"line":90,"address":[1583877,1583832],"length":1,"stats":{"Line":6}},{"line":93,"address":[1583936],"length":1,"stats":{"Line":3}},{"line":97,"address":[1583970],"length":1,"stats":{"Line":3}},{"line":98,"address":[1583985],"length":1,"stats":{"Line":3}},{"line":99,"address":[1584012],"length":1,"stats":{"Line":3}},{"line":101,"address":[1584077],"length":1,"stats":{"Line":0}},{"line":102,"address":[1584104],"length":1,"stats":{"Line":0}},{"line":107,"address":[1584176],"length":1,"stats":{"Line":3}},{"line":108,"address":[1584232,1584194],"length":1,"stats":{"Line":6}},{"line":109,"address":[1584205],"length":1,"stats":{"Line":3}},{"line":114,"address":[1584551,1584320],"length":1,"stats":{"Line":3}},{"line":115,"address":[1584349],"length":1,"stats":{"Line":3}},{"line":116,"address":[1584389,1584468],"length":1,"stats":{"Line":3}},{"line":117,"address":[1584444],"length":1,"stats":{"Line":1}},{"line":121,"address":[1584576,1584714],"length":1,"stats":{"Line":3}},{"line":122,"address":[1584590],"length":1,"stats":{"Line":3}},{"line":123,"address":[1584625],"length":1,"stats":{"Line":3}},{"line":128,"address":[1584736],"length":1,"stats":{"Line":1}},{"line":129,"address":[1584754],"length":1,"stats":{"Line":1}},{"line":132,"address":[1584921,1584784],"length":1,"stats":{"Line":3}},{"line":133,"address":[1584807],"length":1,"stats":{"Line":3}},{"line":134,"address":[1584841],"length":1,"stats":{"Line":1}},{"line":135,"address":[1584860],"length":1,"stats":{"Line":1}},{"line":136,"address":[1636947,1637046],"length":1,"stats":{"Line":0}},{"line":137,"address":[1637002],"length":1,"stats":{"Line":0}},{"line":139,"address":[1584901],"length":1,"stats":{"Line":1}},{"line":142,"address":[1584944],"length":1,"stats":{"Line":3}},{"line":143,"address":[1584973],"length":1,"stats":{"Line":3}},{"line":144,"address":[1637136,1637156],"length":1,"stats":{"Line":4}},{"line":145,"address":[1637196],"length":1,"stats":{"Line":2}},{"line":146,"address":[1637208],"length":1,"stats":{"Line":2}},{"line":148,"address":[1637232,1637281,1637579],"length":1,"stats":{"Line":4}},{"line":149,"address":[1637345],"length":1,"stats":{"Line":1}},{"line":150,"address":[1637409],"length":1,"stats":{"Line":2}},{"line":151,"address":[1637354,1637458],"length":1,"stats":{"Line":2}},{"line":153,"address":[1637668,1637648],"length":1,"stats":{"Line":6}},{"line":154,"address":[1637684],"length":1,"stats":{"Line":3}},{"line":155,"address":[1637749],"length":1,"stats":{"Line":0}},{"line":157,"address":[1637808,1637828],"length":1,"stats":{"Line":6}},{"line":158,"address":[1637868],"length":1,"stats":{"Line":3}},{"line":159,"address":[1637927],"length":1,"stats":{"Line":1}},{"line":161,"address":[1638238,1638075,1637952,1637987],"length":1,"stats":{"Line":9}},{"line":162,"address":[1638192],"length":1,"stats":{"Line":3}},{"line":163,"address":[1638128],"length":1,"stats":{"Line":0}},{"line":168,"address":[1585220,1585120],"length":1,"stats":{"Line":1}},{"line":169,"address":[1585141],"length":1,"stats":{"Line":1}},{"line":170,"address":[1638272,1638292],"length":1,"stats":{"Line":4}},{"line":171,"address":[1638337],"length":1,"stats":{"Line":2}},{"line":172,"address":[1638356],"length":1,"stats":{"Line":2}}],"covered":80,"coverable":86},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","ast.rs"],"content":"use num_enum::{IntoPrimitive, TryFromPrimitive};\n\n#[derive(Clone, Debug, PartialEq)]\npub struct SourceLine {\n    location: Location,\n    label: Label,\n    source_program_word: SourceWord,\n    comment: Comment,\n}\n\nimpl SourceLine {\n    pub fn new(\n        location: Location,\n        label: Label,\n        source_program_word: SourceWord,\n        comment: Comment,\n    ) -\u003e Self {\n        Self {\n            location,\n            label,\n            source_program_word,\n            comment,\n        }\n    }\n\n    pub fn location(\u0026self) -\u003e \u0026Location {\n        \u0026self.location\n    }\n\n    pub fn label(\u0026self) -\u003e \u0026Label {\n        \u0026self.label\n    }\n\n    pub fn source_program_word(\u0026self) -\u003e \u0026SourceWord {\n        \u0026self.source_program_word\n    }\n}\n\nimpl std::fmt::Display for SourceLine {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        let location = format!(\"{:04}\", self.location);\n        let label = format!(\"{:08}\", self.label);\n        let source_program_word = self.source_program_word.to_string();\n        let comment = self.comment.to_string();\n\n        write!(\n            f,\n            \"{:\u003c8}{:\u003c10}{:\u003c42}{}\",\n            location, label, source_program_word, comment\n        )\n    }\n}\n\npub type Location = AddressRef;\n\n#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Label(Option\u003cString\u003e);\n\nimpl Label {\n    pub fn name(\u0026self) -\u003e Option\u003cString\u003e {\n        self.0.clone()\n    }\n}\n\nimpl From\u003cString\u003e for Label {\n    fn from(a: String) -\u003e Self {\n        Self(Some(a))\n    }\n}\n\nimpl From\u003cOption\u003cString\u003e\u003e for Label {\n    fn from(a: Option\u003cString\u003e) -\u003e Self {\n        Self(a)\n    }\n}\n\nimpl std::fmt::Display for Label {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match \u0026self.0 {\n            Some(l) =\u003e write!(f, \"{}:\", l),\n            None =\u003e write!(f, \"\"),\n        }\n    }\n}\n\npub type Identifier = String;\n\n#[derive(Clone, Debug, PartialEq)]\n#[allow(clippy::enum_variant_names)] // Reflects usage in spec.\npub enum SourceWord {\n    PWord(PWord),\n    FWord(FWord),\n    IWord(IWord),\n    SWord(SWord),\n}\n\nimpl std::fmt::Display for SourceWord {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            SourceWord::SWord(sword) =\u003e write!(f, \"\\\"{}\\\"\", sword),\n            SourceWord::PWord(pword) =\u003e write!(f, \"{}\", pword),\n            SourceWord::FWord(fword) =\u003e write!(f, \"{}\", fword),\n            SourceWord::IWord(iword) =\u003e write!(f, \"{}\", iword),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub struct PWord {\n    mnemonic: Mnemonic,\n    accumulator: Acc,\n    store_operand: StoreOperand,\n}\n\nimpl PWord {\n    pub fn new(mnemonic: Mnemonic, accumulator: Acc, store_operand: StoreOperand) -\u003e Self {\n        Self {\n            mnemonic,\n            accumulator,\n            store_operand,\n        }\n    }\n\n    pub fn mnemonic(\u0026self) -\u003e Mnemonic {\n        self.mnemonic\n    }\n\n    pub fn accumulator(\u0026self) -\u003e Acc {\n        self.accumulator.clone()\n    }\n\n    pub fn store_operand(\u0026self) -\u003e StoreOperand {\n        self.store_operand.clone()\n    }\n\n    pub fn index_register(\u0026self) -\u003e IndexRegister {\n        match self.store_operand() {\n            StoreOperand::AddressOperand(address_operand) =\u003e address_operand.index_register(),\n            _ =\u003e 0,\n        }\n    }\n\n    pub fn indirect(\u0026self) -\u003e bool {\n        match self.store_operand() {\n            StoreOperand::AddressOperand(address_operand) =\u003e address_operand.indirect(),\n            _ =\u003e false,\n        }\n    }\n\n    pub fn page(\u0026self) -\u003e usize {\n        0\n    }\n}\n\nimpl std::fmt::Display for PWord {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(\n            f,\n            \"{:\u003c8}{:\u003e2} {}\",\n            self.mnemonic.to_string(),\n            self.accumulator.to_string(),\n            self.store_operand\n        )\n    }\n}\n\npub type SWord = String;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct Acc(Option\u003cchar\u003e);\n\nimpl Acc {\n    pub fn as_usize(\u0026self) -\u003e usize {\n        self.0.map_or(0, |a| (a as u8) - b'0') as usize\n    }\n}\n\nimpl From\u003cchar\u003e for Acc {\n    fn from(a: char) -\u003e Self {\n        Self(Some(a))\n    }\n}\n\nimpl From\u003cOption\u003cchar\u003e\u003e for Acc {\n    fn from(a: Option\u003cchar\u003e) -\u003e Self {\n        Self(a)\n    }\n}\n\nimpl std::fmt::Display for Acc {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{}\", self.0.map_or(\"\".into(), |a| a.to_string()))\n    }\n}\n\npub type FWord = FloatType;\npub type IWord = IntType;\n\n#[derive(Clone, Debug, PartialEq)]\npub enum StoreOperand {\n    None,\n    AddressOperand(AddressOperand),\n    ConstOperand(ConstOperand),\n}\n\nimpl StoreOperand {\n    pub fn requires_storage(\u0026self) -\u003e bool {\n        matches!(self, StoreOperand::ConstOperand(_))\n    }\n}\n\nimpl std::fmt::Display for StoreOperand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            StoreOperand::None =\u003e write!(f, \"\"),\n            StoreOperand::AddressOperand(o) =\u003e write!(f, \"{}\", o),\n            StoreOperand::ConstOperand(o) =\u003e write!(f, \"{}\", o),\n        }\n    }\n}\n\n// TOOD: Line 110 in bbc-3\npub type Comment = String;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct AddressOperand {\n    address: SimpleAddressOperand,\n    index: Option\u003cIndexRegister\u003e,\n}\n\nimpl AddressOperand {\n    pub fn new(address: SimpleAddressOperand, index: Option\u003cIndexRegister\u003e) -\u003e Self {\n        Self { address, index }\n    }\n\n    pub fn address(\u0026self) -\u003e SimpleAddressOperand {\n        self.address.clone()\n    }\n\n    pub fn index(\u0026self) -\u003e Option\u003cIndexRegister\u003e {\n        self.index\n    }\n\n    pub fn index_register(\u0026self) -\u003e IndexRegister {\n        self.index.unwrap_or(0)\n    }\n\n    pub fn indirect(\u0026self) -\u003e bool {\n        match self.address {\n            SimpleAddressOperand::DirectAddress(_) =\u003e false,\n            SimpleAddressOperand::IndirectAddress(_) =\u003e true,\n        }\n    }\n}\n\nimpl std::fmt::Display for AddressOperand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        let index = self.index.map(|i| format!(\":{}\", i)).unwrap_or(\"\".into());\n        write!(f, \"{}{}\", self.address, index)\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\n#[allow(clippy::enum_variant_names)] // Reflects usage in spec.\npub enum ConstOperand {\n    SignedIWord(IntType),\n    SignedFWord(FloatType),\n    SWord(SWord),\n}\n\nimpl std::fmt::Display for ConstOperand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            ConstOperand::SignedIWord(c) =\u003e write!(f, \"{:+}\", c),\n            ConstOperand::SignedFWord(c) =\u003e write!(f, \"{:+}\", c),\n            ConstOperand::SWord(c) =\u003e write!(f, \"\\\"{}\\\"\", c),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum SimpleAddressOperand {\n    DirectAddress(Address),\n    IndirectAddress(Address),\n}\n\nimpl std::fmt::Display for SimpleAddressOperand {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            SimpleAddressOperand::DirectAddress(a) =\u003e write!(f, \"{}\", a),\n            SimpleAddressOperand::IndirectAddress(a) =\u003e write!(f, \"*{}\", a),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq)]\npub enum Address {\n    Identifier(Identifier),\n    NumericAddress(NumericAddress),\n}\n\nimpl std::fmt::Display for Address {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        match self {\n            Address::Identifier(i) =\u003e write!(f, \"{}\", i),\n            Address::NumericAddress(a) =\u003e write!(f, \"{}\", a),\n        }\n    }\n}\n\npub type NumericAddress = usize;\n\npub type Character = char;\npub type NumericCharacter = char;\npub type Punctuation = char;\npub type IntType = i64;\npub type FloatType = f64;\npub type AddressRef = usize;\npub type IndexRegister = usize;\n\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, IntoPrimitive, TryFromPrimitive)]\n#[allow(clippy::upper_case_acronyms)]\n#[repr(u32)]\npub enum Mnemonic {\n    #[default]\n    NIL,\n    OR,\n    NEQV,\n    AND,\n    ADD,\n    SUBT,\n    MULT,\n    DVD,\n    TAKE,\n    TSTR,\n    TNEG,\n    TNOT,\n    TTYP,\n    TTYZ,\n    TTTT,\n    TOUT,\n    SKIP,\n    SKAE,\n    SKAN,\n    SKET,\n    SKAL,\n    SKAG,\n    SKED,\n    SKEI,\n    SHL,\n    ROT,\n    DSHL,\n    DROT,\n    POWR,\n    DMULT,\n    DIV,\n    DDIV,\n    NILX,\n    ORX,\n    NEQVX,\n    ANDX,\n    ADDX,\n    SUBTX,\n    MULTX,\n    DVDX,\n    PUT,\n    PSQU,\n    PNEG,\n    PNOT,\n    PTYP,\n    PTYZ,\n    PFFP,\n    PIN,\n    JUMP,\n    JEZ,\n    JNZ,\n    JAT,\n    JLZ,\n    JGZ,\n    JZD,\n    JZI,\n    DECR,\n    INCR,\n    MOCKP,\n    MOCKS,\n    DBYTE,\n    #[allow(dead_code)]\n    UNUSED,\n    EXEC,\n    EXTRA,\n    // Library\n    SQRT,\n    LN,\n    EXP,\n    READ,\n    PRINT,\n    SIN,\n    COS,\n    TAN,\n    ATN,\n    STOP,\n    LINE,\n    INT,\n    FRAC,\n    FLOAT,\n    CAPTN,\n    PAGE,\n    RND,\n    ABS,\n}\n\nimpl std::fmt::Display for Mnemonic {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{:?}\", self)\n    }\n}\n","traces":[{"line":12,"address":[1256432],"length":1,"stats":{"Line":1}},{"line":26,"address":[1256560],"length":1,"stats":{"Line":3}},{"line":27,"address":[1256568],"length":1,"stats":{"Line":1}},{"line":30,"address":[1256576],"length":1,"stats":{"Line":1}},{"line":31,"address":[1256584],"length":1,"stats":{"Line":3}},{"line":34,"address":[1256592],"length":1,"stats":{"Line":1}},{"line":40,"address":[1259604,1256608],"length":1,"stats":{"Line":1}},{"line":41,"address":[1256641,1256731,1256995],"length":1,"stats":{"Line":3}},{"line":42,"address":[1257121,1257254,1257518],"length":1,"stats":{"Line":3}},{"line":43,"address":[1257685],"length":1,"stats":{"Line":1}},{"line":44,"address":[1257741],"length":1,"stats":{"Line":1}},{"line":46,"address":[1258638,1258278,1259102,1258870,1259322],"length":1,"stats":{"Line":5}},{"line":60,"address":[1259632],"length":1,"stats":{"Line":1}},{"line":61,"address":[1259649],"length":1,"stats":{"Line":3}},{"line":66,"address":[1259680],"length":1,"stats":{"Line":1}},{"line":67,"address":[1259683],"length":1,"stats":{"Line":1}},{"line":72,"address":[1259744],"length":1,"stats":{"Line":2}},{"line":73,"address":[1259747],"length":1,"stats":{"Line":2}},{"line":78,"address":[1259776],"length":1,"stats":{"Line":1}},{"line":79,"address":[1259808],"length":1,"stats":{"Line":1}},{"line":80,"address":[1259983,1259883],"length":1,"stats":{"Line":2}},{"line":81,"address":[1259838],"length":1,"stats":{"Line":1}},{"line":98,"address":[1260064],"length":1,"stats":{"Line":1}},{"line":99,"address":[1260097],"length":1,"stats":{"Line":1}},{"line":100,"address":[1260801],"length":1,"stats":{"Line":0}},{"line":101,"address":[1260154,1260272],"length":1,"stats":{"Line":2}},{"line":102,"address":[1260489,1260367],"length":1,"stats":{"Line":0}},{"line":103,"address":[1260706,1260584],"length":1,"stats":{"Line":0}},{"line":116,"address":[1260992],"length":1,"stats":{"Line":3}},{"line":124,"address":[1261056],"length":1,"stats":{"Line":3}},{"line":125,"address":[1261061],"length":1,"stats":{"Line":3}},{"line":128,"address":[1261072],"length":1,"stats":{"Line":3}},{"line":129,"address":[1261077],"length":1,"stats":{"Line":3}},{"line":132,"address":[1261088],"length":1,"stats":{"Line":2}},{"line":133,"address":[1261105],"length":1,"stats":{"Line":2}},{"line":136,"address":[1261120,1261385],"length":1,"stats":{"Line":1}},{"line":137,"address":[1261138],"length":1,"stats":{"Line":3}},{"line":138,"address":[1261186,1261253],"length":1,"stats":{"Line":3}},{"line":139,"address":[1261237],"length":1,"stats":{"Line":1}},{"line":143,"address":[1261472,1261734],"length":1,"stats":{"Line":1}},{"line":144,"address":[1261490],"length":1,"stats":{"Line":3}},{"line":145,"address":[1261601,1261538],"length":1,"stats":{"Line":3}},{"line":146,"address":[1261589],"length":1,"stats":{"Line":1}},{"line":150,"address":[1261824],"length":1,"stats":{"Line":3}},{"line":156,"address":[1263290,1261840],"length":1,"stats":{"Line":1}},{"line":157,"address":[1263085,1262323,1262865,1262633],"length":1,"stats":{"Line":4}},{"line":160,"address":[1261879],"length":1,"stats":{"Line":1}},{"line":161,"address":[1262057],"length":1,"stats":{"Line":1}},{"line":173,"address":[1263312],"length":1,"stats":{"Line":3}},{"line":174,"address":[1263317],"length":1,"stats":{"Line":5}},{"line":179,"address":[1263344],"length":1,"stats":{"Line":2}},{"line":180,"address":[1263348],"length":1,"stats":{"Line":2}},{"line":185,"address":[1263360],"length":1,"stats":{"Line":3}},{"line":191,"address":[1263681,1263376],"length":1,"stats":{"Line":1}},{"line":192,"address":[1263597,1263404],"length":1,"stats":{"Line":2}},{"line":207,"address":[1263712],"length":1,"stats":{"Line":3}},{"line":208,"address":[1263717],"length":1,"stats":{"Line":3}},{"line":213,"address":[1263760],"length":1,"stats":{"Line":1}},{"line":214,"address":[1263793],"length":1,"stats":{"Line":1}},{"line":215,"address":[1263848],"length":1,"stats":{"Line":0}},{"line":216,"address":[1264000,1263894],"length":1,"stats":{"Line":2}},{"line":217,"address":[1264211,1264089],"length":1,"stats":{"Line":0}},{"line":232,"address":[1264320],"length":1,"stats":{"Line":1}},{"line":236,"address":[1264384],"length":1,"stats":{"Line":2}},{"line":237,"address":[1264401],"length":1,"stats":{"Line":3}},{"line":240,"address":[1264416],"length":1,"stats":{"Line":3}},{"line":241,"address":[1264421],"length":1,"stats":{"Line":3}},{"line":244,"address":[1264432],"length":1,"stats":{"Line":2}},{"line":245,"address":[1264440],"length":1,"stats":{"Line":3}},{"line":248,"address":[1264464],"length":1,"stats":{"Line":3}},{"line":249,"address":[1264469],"length":1,"stats":{"Line":3}},{"line":250,"address":[1264475],"length":1,"stats":{"Line":3}},{"line":251,"address":[1264482],"length":1,"stats":{"Line":0}},{"line":257,"address":[1264496,1265020],"length":1,"stats":{"Line":1}},{"line":258,"address":[1265042,1264529],"length":1,"stats":{"Line":1}},{"line":259,"address":[1264911],"length":1,"stats":{"Line":1}},{"line":272,"address":[1265072],"length":1,"stats":{"Line":0}},{"line":273,"address":[1265105],"length":1,"stats":{"Line":0}},{"line":274,"address":[1265178,1265522,1265282],"length":1,"stats":{"Line":0}},{"line":275,"address":[1265626,1266000,1265748],"length":1,"stats":{"Line":0}},{"line":276,"address":[1266113,1266231],"length":1,"stats":{"Line":0}},{"line":288,"address":[1266336],"length":1,"stats":{"Line":1}},{"line":289,"address":[1266368],"length":1,"stats":{"Line":1}},{"line":290,"address":[1266382,1266486],"length":1,"stats":{"Line":2}},{"line":291,"address":[1266559,1266669],"length":1,"stats":{"Line":0}},{"line":303,"address":[1266768],"length":1,"stats":{"Line":1}},{"line":304,"address":[1266800],"length":1,"stats":{"Line":1}},{"line":305,"address":[1266838,1266938],"length":1,"stats":{"Line":2}},{"line":306,"address":[1267011,1267121],"length":1,"stats":{"Line":0}},{"line":413,"address":[1267216],"length":1,"stats":{"Line":1}},{"line":414,"address":[1267321],"length":1,"stats":{"Line":1}}],"covered":78,"coverable":91},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","charset.rs"],"content":"use once_cell::sync::Lazy;\n\nuse std::collections::HashMap;\n\ntype Bits = u64;\n\nstatic CHAR_TO_BITS: Lazy\u003cHashMap\u003cu8, Bits\u003e\u003e = Lazy::new(|| {\n    HashMap::from_iter(vec![\n        (b'\\0', 0),\n        (b'A', 1),\n        (b'B', 2),\n        (b'C', 3),\n        (b'D', 4),\n        (b'E', 5),\n        (b'F', 6),\n        (b'G', 7),\n        (b'H', 8),\n        (b'I', 9),\n        (b'J', 10),\n        (b'K', 11),\n        (b'L', 12),\n        (b'M', 13),\n        (b'N', 14),\n        (b'O', 15),\n        (b'P', 16),\n        (b'Q', 17),\n        (b'R', 18),\n        (b'S', 19),\n        (b'T', 20),\n        (b'U', 21),\n        (b'V', 22),\n        (b'W', 23),\n        (b'X', 24),\n        (b'Y', 25),\n        (b'Z', 26),\n        (b'\\'', 27),\n        (b'\u003c', 28),\n        (b'\u003e', 29),\n        // (b'\u003c=', 30), // Not parsed\n        // (b'\u003e=', 31), // Not parsed\n        (b'0', 32),\n        (b'1', 33),\n        (b'2', 34),\n        (b'3', 35),\n        (b'4', 36),\n        (b'5', 37),\n        (b'6', 38),\n        (b'7', 39),\n        (b'8', 40),\n        (b'9', 41),\n        (b'.', 42),\n        (b'@', 43),\n        (b'+', 44),\n        (b'-', 45),\n        (b'(', 46),\n        (b')', 47),\n        (b'[', 48),\n        (b']', 49),\n        (b'*', 50),\n        (b'/', 51),\n        (b'=', 52),\n        // (b'|=', 53), // Not parsed\n        (b'^', 54), // Re-interpreted from up-arrow\n        // (b'\u003c-', 55), // Not parsed\n        (b'?', 56),\n        (b'\"', 57),\n        (b':', 58),\n        (b';', 59),\n        (b',', 60),\n        (b' ', 61),\n        (b'\\n', 62),\n        // (b'\u003cctrl\u003e', 63), // Ctrl-? escapes not parsed\n    ])\n});\n\nstatic BITS_TO_CHAR: Lazy\u003cHashMap\u003cBits, u8\u003e\u003e =\n    Lazy::new(|| HashMap::from_iter(CHAR_TO_BITS.iter().map(|(c, b)| (*b, *c))));\n\npub struct CharSet {}\n\nimpl CharSet {\n    pub fn char_to_bits(char: u8) -\u003e Option\u003cBits\u003e {\n        CHAR_TO_BITS.get(\u0026char).copied()\n    }\n\n    pub fn bits_to_char(bits: Bits) -\u003e Option\u003cu8\u003e {\n        BITS_TO_CHAR.get(\u0026bits).copied()\n    }\n}\n","traces":[{"line":7,"address":[1038496],"length":1,"stats":{"Line":1}},{"line":8,"address":[1039610,1038514],"length":1,"stats":{"Line":1}},{"line":77,"address":[1039650,1039743,1039632,1039728],"length":1,"stats":{"Line":4}},{"line":82,"address":[1581488],"length":1,"stats":{"Line":2}},{"line":83,"address":[1581496],"length":1,"stats":{"Line":2}},{"line":86,"address":[1581536],"length":1,"stats":{"Line":1}},{"line":87,"address":[1581541],"length":1,"stats":{"Line":1}}],"covered":7,"coverable":7},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","executor.rs"],"content":"use super::assembly::Assembly;\nuse super::memory::{word_to_instruction, Instruction, *};\nuse super::result::{Error, Result};\n\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\n\npub struct Executor {\n    ec: ExecutionContext,\n    #[allow(dead_code)] // TODO: Remove\n    stdin: Rc\u003cRefCell\u003cdyn std::io::Read\u003e\u003e,\n    stdout: Rc\u003cRefCell\u003cdyn std::io::Write\u003e\u003e,\n}\n\nimpl Executor {\n    pub fn new() -\u003e Self {\n        let stdin = Rc::new(RefCell::new(std::io::stdin()));\n        let stdout = Rc::new(RefCell::new(std::io::stdout()));\n        Self::with_io(stdin, stdout)\n    }\n\n    pub fn with_io\u003cR, W\u003e(stdin: Rc\u003cRefCell\u003cR\u003e\u003e, stdout: Rc\u003cRefCell\u003cW\u003e\u003e) -\u003e Self\n    where\n        R: std::io::Read + 'static,\n        W: std::io::Write + 'static,\n    {\n        Self {\n            ec: ExecutionContext::default(),\n            stdin,\n            stdout,\n        }\n    }\n\n    pub fn execute(mut self, assembly: \u0026Assembly) -\u003e Result\u003cExecutionContext\u003e {\n        self.ec = assembly.clone().try_into()?;\n\n        while self.can_step() {\n            self.step()?;\n        }\n        Ok(self.ec.clone())\n    }\n\n    fn can_step(\u0026self) -\u003e bool {\n        let context = \u0026self.ec;\n        let content = \u0026context[context.pc];\n        content.is_instruction()\n    }\n\n    fn step(\u0026mut self) -\u003e Result\u003c()\u003e {\n        let pc = self.ec.pc;\n        self.ec.pc += 1;\n        let content = self.ec[pc];\n        println!(\"exec {:?} @ {:?}\", content, pc);\n        let instruction = word_to_instruction(\u0026content)\n            .map_err(|err| Error::CannotConvertWordToInstruction(err.to_string()))?;\n        self.step_word(\u0026instruction);\n        Ok(())\n    }\n\n    fn step_word(\u0026mut self, instruction: \u0026Instruction) {\n        type ExecFn = fn(\u0026mut Executor, \u0026Instruction);\n        let execution: HashMap\u003cFunction, ExecFn\u003e = vec![\n            (Function::NIL, Executor::exec_nil as ExecFn),\n            (Function::OR, Executor::exec_or as ExecFn),\n            (Function::NEQV, Executor::exec_neqv as ExecFn),\n            (Function::AND, Executor::exec_and as ExecFn),\n            (Function::ADD, Executor::exec_add as ExecFn),\n            (Function::SUBT, Executor::exec_subt as ExecFn),\n            (Function::MULT, Executor::exec_mult as ExecFn),\n            (Function::DVD, Executor::exec_dvd as ExecFn),\n            (Function::TAKE, Executor::exec_take as ExecFn),\n            (Function::TSTR, Executor::exec_tstr as ExecFn),\n            (Function::TNEG, Executor::exec_tneg as ExecFn),\n            (Function::TNOT, Executor::exec_tnot as ExecFn),\n            (Function::TTYP, Executor::exec_ttyp as ExecFn),\n            (Function::TTYZ, Executor::exec_ttyz as ExecFn),\n            (Function::TOUT, Executor::exec_tout as ExecFn),\n            (Function::SKIP, Executor::exec_skip as ExecFn),\n            (Function::SKAE, Executor::exec_skae as ExecFn),\n            (Function::SKAN, Executor::exec_skan as ExecFn),\n            (Function::SKET, Executor::exec_sket as ExecFn),\n            (Function::SKAL, Executor::exec_skal as ExecFn),\n            (Function::SKAG, Executor::exec_skag as ExecFn),\n            (Function::SKED, Executor::exec_sked as ExecFn),\n            (Function::SKEI, Executor::exec_skei as ExecFn),\n            (Function::SHL, Executor::exec_shl as ExecFn),\n            (Function::ROT, Executor::exec_rot as ExecFn),\n            (Function::DSHL, Executor::exec_dshl as ExecFn),\n            (Function::DROT, Executor::exec_drot as ExecFn),\n            (Function::POWR, Executor::exec_powr as ExecFn),\n            (Function::DMULT, Executor::exec_dmult as ExecFn),\n            (Function::DIV, Executor::exec_div as ExecFn),\n            (Function::DDIV, Executor::exec_ddiv as ExecFn),\n            (Function::NILX, Executor::exec_nilx as ExecFn),\n            (Function::ORX, Executor::exec_orx as ExecFn),\n            (Function::NEQVX, Executor::exec_neqvx as ExecFn),\n            (Function::ADDX, Executor::exec_addx as ExecFn),\n            (Function::SUBTX, Executor::exec_subtx as ExecFn),\n            (Function::MULTX, Executor::exec_multx as ExecFn),\n            (Function::DVDX, Executor::exec_dvdx as ExecFn),\n            (Function::PUT, Executor::exec_put as ExecFn),\n            (Function::PSQU, Executor::exec_psqu as ExecFn),\n            (Function::PNEG, Executor::exec_pneg as ExecFn),\n            (Function::PTYP, Executor::exec_ptyp as ExecFn),\n        ]\n        .into_iter()\n        .collect();\n\n        let f = execution\n            .get(\u0026instruction.function())\n            .expect(\"Expected instruction to be implemented\");\n        f(self, instruction)\n    }\n\n    fn operand(\u0026self, instruction: \u0026Instruction) -\u003e Result\u003cWord\u003e {\n        let ec = \u0026self.ec;\n\n        let index_register = instruction.index_register();\n        let mut address = instruction.address();\n\n        if instruction.is_indirect() {\n            let indirect_instruction = word_to_instruction(\u0026ec[address])\n                .map_err(|err| Error::CannotDetermineOperand(err.to_string()))?;\n            address = indirect_instruction.address()\n        }\n\n        if index_register.is_indexable() {\n            let index = ec[index_register]\n                .as_i64()\n                .map_err(|err| Error::CannotDetermineOperand(err.to_string()))?;\n            address += index as isize;\n        }\n\n        Ok(ec[address])\n    }\n\n    fn acc_and_operand(\u0026self, instruction: \u0026Instruction) -\u003e (Accumulator, Word) {\n        let acc = instruction.accumulator();\n        let operand = self.operand(instruction).expect(\"Invalid operand\");\n        (acc, operand)\n    }\n\n    fn acc_and_address(\u0026instruction: \u0026Instruction) -\u003e (Accumulator, Address) {\n        let acc = instruction.accumulator();\n        let address = instruction.address();\n        (acc, address)\n    }\n\n    fn exec_nil(\u0026mut self, _instruction: \u0026Instruction) {}\n\n    fn exec_or(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] |= operand;\n    }\n\n    fn exec_neqv(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] ^= operand;\n    }\n\n    fn exec_and(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] \u0026= operand;\n    }\n\n    fn exec_add(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] += operand;\n    }\n\n    fn exec_subt(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] -= operand;\n    }\n\n    fn exec_mult(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] *= operand;\n    }\n\n    fn exec_dvd(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] /= operand;\n    }\n\n    fn exec_take(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] = operand;\n    }\n\n    fn exec_tstr(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        let value = operand.as_i64().expect(\"TSTR invalid operand\");\n        self.ec[acc] = operand;\n        self.ec[acc - 1] = (if value \u003c 1 { -1 } else { 0 }).try_into().unwrap();\n    }\n\n    fn exec_tneg(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        println!(\"operand {:?} neg_operand {:?}\", operand, -operand);\n        self.ec[acc] = -operand;\n    }\n\n    fn exec_tnot(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] = !operand;\n    }\n\n    fn exec_ttyp(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] = operand.word_type();\n    }\n\n    fn exec_ttyz(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] = operand.word_bits();\n    }\n\n    fn exec_tout(\u0026mut self, instruction: \u0026Instruction) {\n        let (_acc, operand) = self.acc_and_operand(instruction);\n        let chars = vec![operand.as_char().expect(\"TOUT invalid operand\")];\n        let mut stdout = (*self.stdout).borrow_mut();\n        stdout.write_all(\u0026chars).unwrap();\n    }\n\n    fn exec_skip(\u0026mut self, _instruction: \u0026Instruction) {\n        self.ec.pc += 1;\n    }\n\n    fn exec_skae(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        if self.ec[acc] == operand {\n            self.ec.pc += 1;\n        }\n    }\n\n    fn exec_skan(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        if self.ec[acc] != operand {\n            self.ec.pc += 1;\n        }\n    }\n\n    fn exec_sket(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        let same_type = self.ec[acc].word_type() == operand.word_type();\n        if same_type {\n            self.ec.pc += 1;\n        }\n    }\n\n    fn exec_skal(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        if self.ec[acc] \u003c operand {\n            self.ec.pc += 1\n        }\n    }\n\n    fn exec_skag(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        if self.ec[acc] \u003e operand {\n            self.ec.pc += 1\n        }\n    }\n\n    fn exec_sked(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        if self.ec[acc] == operand {\n            self.ec.pc += 1\n        } else {\n            self.ec[acc] -= 1.try_into().unwrap()\n        }\n    }\n\n    fn exec_skei(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        if self.ec[acc] == operand {\n            self.ec.pc += 1\n        } else {\n            self.ec[acc] += 1.try_into().unwrap()\n        }\n    }\n\n    fn exec_shl(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] \u003c\u003c= operand;\n    }\n\n    fn exec_rot(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc].rotate(operand.as_i64().unwrap());\n    }\n\n    fn exec_dshl(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        let (msw, lsw) = double_shift_left(\u0026self.ec[acc - 1], \u0026self.ec[acc], \u0026operand).unwrap();\n        self.ec[acc - 1].set_word_bits(\u0026msw);\n        self.ec[acc].set_word_bits(\u0026lsw);\n    }\n\n    fn exec_drot(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        let (msw, lsw) = double_rotate_left(\u0026self.ec[acc - 1], \u0026self.ec[acc], \u0026operand).unwrap();\n        self.ec[acc - 1].set_word_bits(\u0026msw);\n        self.ec[acc].set_word_bits(\u0026lsw);\n    }\n\n    fn exec_powr(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc].power(\u0026operand);\n    }\n\n    fn exec_dmult(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        let (msw, lsw) = double_mult(\u0026self.ec[acc - 1], \u0026self.ec[acc], \u0026operand).unwrap();\n        self.ec[acc - 1].set_word_bits(\u0026msw);\n        self.ec[acc].set_word_bits(\u0026lsw);\n    }\n\n    fn exec_div(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        self.ec[acc] /= operand;\n    }\n\n    fn exec_ddiv(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        let (msw, lsw) = double_div(\u0026self.ec[acc - 1], \u0026self.ec[acc], \u0026operand).unwrap();\n        self.ec[acc - 1].set_word_bits(\u0026msw);\n        self.ec[acc].set_word_bits(\u0026lsw);\n    }\n\n    fn exec_nilx(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, operand) = self.acc_and_operand(instruction);\n        let acc_value = self.ec[acc];\n        let operand_address = instruction.address();\n        self.ec[acc] = operand;\n        self.ec[operand_address] = acc_value;\n    }\n\n    fn exec_orx(\u0026mut self, instruction: \u0026Instruction) {\n        self.exec_or(instruction);\n        self.exec_nilx(instruction);\n    }\n\n    fn exec_neqvx(\u0026mut self, instruction: \u0026Instruction) {\n        self.exec_neqv(instruction);\n        self.exec_nilx(instruction);\n    }\n\n    fn exec_addx(\u0026mut self, instruction: \u0026Instruction) {\n        self.exec_add(instruction);\n        self.exec_nilx(instruction);\n    }\n\n    fn exec_subtx(\u0026mut self, instruction: \u0026Instruction) {\n        self.exec_subt(instruction);\n        self.exec_nilx(instruction);\n    }\n\n    fn exec_multx(\u0026mut self, instruction: \u0026Instruction) {\n        self.exec_mult(instruction);\n        self.exec_nilx(instruction);\n    }\n\n    fn exec_dvdx(\u0026mut self, instruction: \u0026Instruction) {\n        self.exec_dvd(instruction);\n        self.exec_nilx(instruction);\n    }\n\n    fn exec_put(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, address) = Self::acc_and_address(instruction);\n        let acc_value = self.ec[acc];\n        self.ec[address] = acc_value;\n    }\n\n    fn exec_psqu(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, address) = Self::acc_and_address(instruction);\n        let msw0 = self.ec[acc - 1];\n        let lsw0 = self.ec[acc];\n        let (_, mut lsw1) = squash(\u0026msw0, \u0026lsw0).unwrap();\n        lsw1.set_word_type(\u0026lsw0);\n        self.ec[address] = lsw1;\n    }\n\n    fn exec_pneg(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, address) = Self::acc_and_address(instruction);\n        let acc_value = self.ec[acc];\n        self.ec[address] = -acc_value;\n    }\n\n    fn exec_ptyp(\u0026mut self, instruction: \u0026Instruction) {\n        let (acc, address) = Self::acc_and_address(instruction);\n        let acc_value = self.ec[acc];\n        self.ec[address].set_word_type(\u0026acc_value);\n    }\n}\n\nimpl std::fmt::Debug for Executor {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"Executor\")\n            .field(\"execution_context\", \u0026self.ec)\n            .field(\"stdin\", \u0026\"Box\u003cstd::io::Read\u003e\")\n            .field(\"stdout\", \u0026\"Box\u003cstd::io::Write\u003e\")\n            .finish()\n    }\n}\n\nimpl PartialEq for Executor {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.ec.eq(\u0026other.ec)\n    }\n}\n\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct ExecutionContext {\n    pc: Offset,\n    memory: Memory,\n}\n\n#[cfg(test)]\nimpl ExecutionContext {\n    fn with_program_counter(self, program_counter: Offset) -\u003e Self {\n        Self {\n            pc: program_counter,\n            ..self\n        }\n    }\n\n    fn with_memory_word\u003cT\u003e(mut self, offset: Offset, value: T) -\u003e Self\n    where\n        T: TryInto\u003cWord\u003e,\n        T::Error: std::fmt::Debug,\n    {\n        self.memory[offset] = value\n            .try_into()\n            .expect(\"required valid value to create word\");\n        self\n    }\n\n    fn with_instruction(self, location: Offset, instruction: Instruction) -\u003e Self {\n        use crate::bbcx::memory::*;\n\n        self.with_memory_word(location, instruction_to_word(\u0026instruction).unwrap())\n    }\n}\n\nimpl TryFrom\u003cAssembly\u003e for ExecutionContext {\n    type Error = Error;\n\n    fn try_from(value: Assembly) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        let value = value.allocate_storage_locations();\n        let program_counter = value.first_pword_location().unwrap_or(0);\n        let memory = Memory::try_from(value)\n            .map_err(|err| Error::FailedToCreateExecutionContext(err.to_string()))?;\n\n        Ok(Self {\n            pc: program_counter,\n            memory,\n        })\n    }\n}\n\nimpl std::ops::Index\u003cusize\u003e for ExecutionContext {\n    type Output = Word;\n\n    fn index(\u0026self, index: usize) -\u003e \u0026Self::Output {\n        \u0026self.memory[index]\n    }\n}\n\nimpl std::ops::IndexMut\u003cusize\u003e for ExecutionContext {\n    fn index_mut(\u0026mut self, index: usize) -\u003e \u0026mut Self::Output {\n        \u0026mut self.memory[index]\n    }\n}\n\nimpl std::ops::Index\u003cAccumulator\u003e for ExecutionContext {\n    type Output = Word;\n\n    fn index(\u0026self, acc: Accumulator) -\u003e \u0026Self::Output {\n        \u0026self.memory[acc]\n    }\n}\n\nimpl std::ops::IndexMut\u003cAccumulator\u003e for ExecutionContext {\n    fn index_mut(\u0026mut self, acc: Accumulator) -\u003e \u0026mut Self::Output {\n        \u0026mut self.memory[acc]\n    }\n}\n\nimpl std::ops::Index\u003cIndexRegister\u003e for ExecutionContext {\n    type Output = Word;\n\n    fn index(\u0026self, index_register: IndexRegister) -\u003e \u0026Self::Output {\n        \u0026self.memory[index_register]\n    }\n}\n\nimpl std::ops::IndexMut\u003cIndexRegister\u003e for ExecutionContext {\n    fn index_mut(\u0026mut self, index_register: IndexRegister) -\u003e \u0026mut Self::Output {\n        \u0026mut self.memory[index_register]\n    }\n}\n\nimpl std::ops::Index\u003cAddress\u003e for ExecutionContext {\n    type Output = Word;\n\n    fn index(\u0026self, address: Address) -\u003e \u0026Self::Output {\n        \u0026self.memory[address]\n    }\n}\n\nimpl std::ops::IndexMut\u003cAddress\u003e for ExecutionContext {\n    fn index_mut(\u0026mut self, address: Address) -\u003e \u0026mut Self::Output {\n        \u0026mut self.memory[address]\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use pretty_assertions::assert_eq;\n    use std::io::Cursor;\n\n    use super::*;\n\n    use crate::bbcx::assembler::*;\n    use crate::bbcx::parser::*;\n\n    fn execute(input: \u0026str) -\u003e Result\u003cExecutionContext\u003e {\n        let executor = Executor::new();\n        do_execute(input, executor)\n    }\n\n    fn execute_io(input: \u0026str, stdin: \u0026str, expected: \u0026str) -\u003e Result\u003cExecutionContext\u003e {\n        let stdin = String::from(stdin);\n        let stdin_buffer = Cursor::new(stdin);\n        let stdin = Rc::new(RefCell::new(std::io::BufReader::new(stdin_buffer)));\n\n        let stdout_buffer = Vec::new();\n        let stdout = Rc::new(RefCell::new(std::io::BufWriter::new(stdout_buffer)));\n\n        let executor = Executor::with_io(stdin, stdout.clone());\n        let ec = do_execute(input, executor).unwrap().clone();\n\n        let stdout = stdout.borrow();\n        let bytes = stdout.buffer();\n        let actual = String::from_utf8_lossy(\u0026bytes);\n\n        assert_eq!(actual, String::from(expected));\n\n        Ok(ec)\n    }\n\n    fn do_execute(input: \u0026str, executor: Executor) -\u003e Result\u003cExecutionContext\u003e {\n        let program = input\n            .to_string()\n            .lines()\n            .map(Parser::parse_line)\n            .filter_map(|l| l.ok())\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        let assembly =\n            Assembler::assemble(\u0026program).expect(\u0026format!(\"Failed to assemble {}\", input));\n        let ec = executor\n            .execute(\u0026assembly)\n            .expect(\u0026format!(\"Failed to execute {}\", input));\n        Ok(ec.clone())\n    }\n\n    #[test]\n    fn default_execution_context() {\n        let program = r#\"\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default().with_program_counter(0);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_nil() {\n        let program = r#\"\n0001    +3.14\n0100    NIL 1, +2.71\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::NIL)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 3.14)\n            .with_memory_word(MEMORY_SIZE - 1, 2.71)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_or() {\n        let program = r#\"\n0001    +12\n0100    OR 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::OR)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 14)\n            .with_memory_word(MEMORY_SIZE - 1, 10)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_neqv() {\n        let program = r#\"\n0001    +12\n0100    NEQV 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::NEQV)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 6)\n            .with_memory_word(MEMORY_SIZE - 1, 10)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_and() {\n        let program = r#\"\n0001    +12\n0100    AND 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::AND)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 8)\n            .with_memory_word(MEMORY_SIZE - 1, 10)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_add() {\n        let program = r#\"\n0001    +12\n0100    ADD 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 22)\n            .with_memory_word(MEMORY_SIZE - 1, 10)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_subt() {\n        let program = r#\"\n0001    +12\n0002    +10\n0100    SUBT 1, +10\n0101    SUBT 2, +12\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::SUBT)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SUBT)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, 2)\n            .with_memory_word(2, -2)\n            .with_memory_word(MEMORY_SIZE - 1, 10)\n            .with_memory_word(MEMORY_SIZE - 2, 12)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_mult() {\n        let program = r#\"\n0001    +12\n0100    MULT 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::MULT)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 120)\n            .with_memory_word(MEMORY_SIZE - 1, 10)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_dvd() {\n        let program = r#\"\n0001    +12\n0100    DVD 1, +6\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::DVD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 2)\n            .with_memory_word(MEMORY_SIZE - 1, 6)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_take() {\n        let program = r#\"\n0100            TAKE 1, +42\n0101            TAKE 2, +3.14\n0102            TAKE 3, \"ABCD\"\n0103            TAKE 4, LOC\n0110    LOC:    +2.718\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(4)\n                    .with_address(110)\n                    .build(),\n            )\n            .with_memory_word(1, 42)\n            .with_memory_word(2, 3.14)\n            .with_memory_word(3, \"ABCD\")\n            .with_memory_word(4, 2.718)\n            .with_memory_word(MEMORY_SIZE - 1, 42)\n            .with_memory_word(MEMORY_SIZE - 2, 3.14)\n            .with_memory_word(MEMORY_SIZE - 3, \"ABCD\")\n            .with_memory_word(110, 2.718)\n            .with_program_counter(104);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_tstr() {\n        let program = r#\"\n0100    TSTR 2, +2\n0101    TSTR 4, -2\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TSTR)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::TSTR)\n                    .with_accumulator(4)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, 0)\n            .with_memory_word(2, 2)\n            .with_memory_word(3, -1)\n            .with_memory_word(4, -2)\n            .with_memory_word(MEMORY_SIZE - 1, 2)\n            .with_memory_word(MEMORY_SIZE - 2, -2)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_tneg() {\n        let program = r#\"\n0100    TNEG 1, +6\n0101    TNEG 2, -6\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TNEG)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::TNEG)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, -6)\n            .with_memory_word(2, 6)\n            .with_memory_word(MEMORY_SIZE - 1, 6)\n            .with_memory_word(MEMORY_SIZE - 2, -6)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_tnot() {\n        let program = r#\"\n0100    TNOT 1, +5592405\n0101    TNOT 2, -5592406\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TNOT)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::TNOT)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, -5592406)\n            .with_memory_word(2, 5592405)\n            .with_memory_word(MEMORY_SIZE - 1, 5592405)\n            .with_memory_word(MEMORY_SIZE - 2, -5592406)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_ttyp() {\n        let program = r#\"\n0100    TTYP 1, +42\n0101    TTYP 2, +3.14\n0102    TTYP 3, \"ABCD\"\n0103    TTYP 4, 103\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TTYP)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::TTYP)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::TTYP)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::TTYP)\n                    .with_accumulator(4)\n                    .with_address(103)\n                    .build(),\n            )\n            .with_memory_word(1, 0)\n            .with_memory_word(2, 1)\n            .with_memory_word(3, 2)\n            .with_memory_word(4, 3)\n            .with_memory_word(MEMORY_SIZE - 1, 42)\n            .with_memory_word(MEMORY_SIZE - 2, 3.14)\n            .with_memory_word(MEMORY_SIZE - 3, \"ABCD\")\n            .with_program_counter(104);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_ttyz() {\n        let program = r#\"\n0100    TTYZ 1, +42\n0101    TTYZ 2, \"ABCD\"\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TTYZ)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::TTYZ)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, 42)\n            .with_memory_word(2, 0o01020304)\n            .with_memory_word(MEMORY_SIZE - 1, 42)\n            .with_memory_word(MEMORY_SIZE - 2, \"ABCD\")\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_tttt() {\n        // Spec: \"not used at present\"\n        assert!(true)\n    }\n\n    #[test]\n    fn test_tout() {\n        let program = r#\"\n0100    TOUT +1\n0101    TOUT \"ABCD\"\n\"#;\n        let actual = execute_io(program, \"\", \"AD\").ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TOUT)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::TOUT)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(MEMORY_SIZE - 1, 1)\n            .with_memory_word(MEMORY_SIZE - 2, \"ABCD\")\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_skip() {\n        let program = r#\"\n0001    +0\n0100    ADD 1, +1\n0101    SKIP\n0102    ADD 1, +1\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(101, InstructionBuilder::new(Function::SKIP).build())\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, 1)\n            .with_memory_word(MEMORY_SIZE - 1, 1)\n            .with_memory_word(MEMORY_SIZE - 2, 1)\n            .with_program_counter(103);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_skae() {\n        let program = r#\"\n0001    +0\n0002    +0\n0100    ADD 1, +1\n0101    SKAE 1, +1\n0102    ADD 1, +1\n0103    ADD 2, +1\n0104    SKAE 2, +2\n0105    ADD 2, +1\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SKAE)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 4)\n                    .build(),\n            )\n            .with_instruction(\n                104,\n                InstructionBuilder::new(Function::SKAE)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 5)\n                    .build(),\n            )\n            .with_instruction(\n                105,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 6)\n                    .build(),\n            )\n            .with_memory_word(1, 1)\n            .with_memory_word(2, 2)\n            .with_memory_word(MEMORY_SIZE - 1, 1)\n            .with_memory_word(MEMORY_SIZE - 2, 1)\n            .with_memory_word(MEMORY_SIZE - 3, 1)\n            .with_memory_word(MEMORY_SIZE - 4, 1)\n            .with_memory_word(MEMORY_SIZE - 5, 2)\n            .with_memory_word(MEMORY_SIZE - 6, 1)\n            .with_program_counter(106);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_skan() {\n        let program = r#\"\n0001    +0\n0002    +0\n0100    ADD 1, +1\n0101    SKAN 1, +1\n0102    ADD 1, +1\n0103    ADD 2, +1\n0104    SKAN 2, +2\n0105    ADD 2, +1\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SKAN)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 4)\n                    .build(),\n            )\n            .with_instruction(\n                104,\n                InstructionBuilder::new(Function::SKAN)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 5)\n                    .build(),\n            )\n            .with_instruction(\n                105,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 6)\n                    .build(),\n            )\n            .with_memory_word(1, 2)\n            .with_memory_word(2, 1)\n            .with_memory_word(MEMORY_SIZE - 1, 1)\n            .with_memory_word(MEMORY_SIZE - 2, 1)\n            .with_memory_word(MEMORY_SIZE - 3, 1)\n            .with_memory_word(MEMORY_SIZE - 4, 1)\n            .with_memory_word(MEMORY_SIZE - 5, 2)\n            .with_memory_word(MEMORY_SIZE - 6, 1)\n            .with_program_counter(106);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_sket() {\n        let program = r#\"\n0100    TAKE 1, +1.0\n0101    SKET 1, +1.0\n0102    ADD 1, +1.0\n0103    TAKE 2, +1.0\n0104    SKET 2, +1\n0105    ADD 2, +1.0\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SKET)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 4)\n                    .build(),\n            )\n            .with_instruction(\n                104,\n                InstructionBuilder::new(Function::SKET)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 5)\n                    .build(),\n            )\n            .with_instruction(\n                105,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 6)\n                    .build(),\n            )\n            .with_memory_word(1, 1.0)\n            .with_memory_word(2, 2.0)\n            .with_memory_word(MEMORY_SIZE - 1, 1.0)\n            .with_memory_word(MEMORY_SIZE - 2, 1.0)\n            .with_memory_word(MEMORY_SIZE - 3, 1.0)\n            .with_memory_word(MEMORY_SIZE - 4, 1.0)\n            .with_memory_word(MEMORY_SIZE - 5, 1)\n            .with_memory_word(MEMORY_SIZE - 6, 1.0)\n            .with_program_counter(106);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_skal() {\n        let program = r#\"\n0100    TAKE 1, +0.0\n0101    SKAL 1, +1.0\n0102    ADD 1, +1.0\n0103    TAKE 2, +1.0\n0104    SKAL 2, +1.0\n0105    ADD 2, +1.0\n0106    TAKE 3, +2.0\n0107    SKAL 3, +1.0\n0108    ADD 3, +1.0\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SKAL)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 4)\n                    .build(),\n            )\n            .with_instruction(\n                104,\n                InstructionBuilder::new(Function::SKAL)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 5)\n                    .build(),\n            )\n            .with_instruction(\n                105,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 6)\n                    .build(),\n            )\n            .with_instruction(\n                106,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 7)\n                    .build(),\n            )\n            .with_instruction(\n                107,\n                InstructionBuilder::new(Function::SKAL)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 8)\n                    .build(),\n            )\n            .with_instruction(\n                108,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 9)\n                    .build(),\n            )\n            .with_memory_word(1, 0.0)\n            .with_memory_word(2, 2.0)\n            .with_memory_word(3, 3.0)\n            .with_memory_word(MEMORY_SIZE - 1, 0.0)\n            .with_memory_word(MEMORY_SIZE - 2, 1.0)\n            .with_memory_word(MEMORY_SIZE - 3, 1.0)\n            .with_memory_word(MEMORY_SIZE - 4, 1.0)\n            .with_memory_word(MEMORY_SIZE - 5, 1.0)\n            .with_memory_word(MEMORY_SIZE - 6, 1.0)\n            .with_memory_word(MEMORY_SIZE - 7, 2.0)\n            .with_memory_word(MEMORY_SIZE - 8, 1.0)\n            .with_memory_word(MEMORY_SIZE - 9, 1.0)\n            .with_program_counter(109);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_skag() {\n        let program = r#\"\n0100    TAKE 1, +0.0\n0101    SKAG 1, +1.0\n0102    ADD 1, +1.0\n0103    TAKE 2, +1.0\n0104    SKAG 2, +1.0\n0105    ADD 2, +1.0\n0106    TAKE 3, +2.0\n0107    SKAG 3, +1.0\n0108    ADD 3, +1.0\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SKAG)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 4)\n                    .build(),\n            )\n            .with_instruction(\n                104,\n                InstructionBuilder::new(Function::SKAG)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 5)\n                    .build(),\n            )\n            .with_instruction(\n                105,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 6)\n                    .build(),\n            )\n            .with_instruction(\n                106,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 7)\n                    .build(),\n            )\n            .with_instruction(\n                107,\n                InstructionBuilder::new(Function::SKAG)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 8)\n                    .build(),\n            )\n            .with_instruction(\n                108,\n                InstructionBuilder::new(Function::ADD)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 9)\n                    .build(),\n            )\n            .with_memory_word(1, 1.0)\n            .with_memory_word(2, 2.0)\n            .with_memory_word(3, 2.0)\n            .with_memory_word(MEMORY_SIZE - 1, 0.0)\n            .with_memory_word(MEMORY_SIZE - 2, 1.0)\n            .with_memory_word(MEMORY_SIZE - 3, 1.0)\n            .with_memory_word(MEMORY_SIZE - 4, 1.0)\n            .with_memory_word(MEMORY_SIZE - 5, 1.0)\n            .with_memory_word(MEMORY_SIZE - 6, 1.0)\n            .with_memory_word(MEMORY_SIZE - 7, 2.0)\n            .with_memory_word(MEMORY_SIZE - 8, 1.0)\n            .with_memory_word(MEMORY_SIZE - 9, 1.0)\n            .with_program_counter(109);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_sked() {\n        let program = r#\"\n0100    TAKE 1, +42\n0101    SKED 1, +42\n0102    NIL\n0103    TAKE 2, +1\n0104    SKED 2, +42\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SKED)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(102, InstructionBuilder::new(Function::NIL).build())\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                104,\n                InstructionBuilder::new(Function::SKED)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 4)\n                    .build(),\n            )\n            .with_memory_word(1, 42)\n            .with_memory_word(2, 0)\n            .with_memory_word(MEMORY_SIZE - 1, 42)\n            .with_memory_word(MEMORY_SIZE - 2, 42)\n            .with_memory_word(MEMORY_SIZE - 3, 1)\n            .with_memory_word(MEMORY_SIZE - 4, 42)\n            .with_program_counter(105);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_skei() {\n        let program = r#\"\n0100    TAKE 1, +42\n0101    SKEI 1, +42\n0102    NIL\n0103    TAKE 2, +1\n0104    SKEI 2, +42\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SKEI)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(102, InstructionBuilder::new(Function::NIL).build())\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::TAKE)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                104,\n                InstructionBuilder::new(Function::SKEI)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 4)\n                    .build(),\n            )\n            .with_memory_word(1, 42)\n            .with_memory_word(2, 2)\n            .with_memory_word(MEMORY_SIZE - 1, 42)\n            .with_memory_word(MEMORY_SIZE - 2, 42)\n            .with_memory_word(MEMORY_SIZE - 3, 1)\n            .with_memory_word(MEMORY_SIZE - 4, 42)\n            .with_program_counter(105);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_shl() {\n        let program = r#\"\n0001    +1\n0002    +1.0\n0003    \"  AB\"\n0100    SHL 1, +1\n0101    SHL 2, +1\n0102    SHL 3, +6\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::SHL)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SHL)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::SHL)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_memory_word(1, 2)\n            .with_memory_word(2, 9_223_372_036_854_775_808.0)\n            .with_memory_word(3, \" AB\\0\")\n            .with_memory_word(MEMORY_SIZE - 1, 1)\n            .with_memory_word(MEMORY_SIZE - 2, 1)\n            .with_memory_word(MEMORY_SIZE - 3, 6)\n            .with_program_counter(103);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_rot() {\n        let program = r#\"\n0001    +1\n0002    +1.0\n0003    \"ABCD\"\n0100    ROT 1, +25\n0101    ROT 2, +1\n0102    ROT 3, +6\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::ROT)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::ROT)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::ROT)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_memory_word(1, 2)\n            .with_memory_word(2, 9_223_372_036_854_775_808.0)\n            .with_memory_word(3, \"BCDA\")\n            .with_memory_word(MEMORY_SIZE - 1, 25)\n            .with_memory_word(MEMORY_SIZE - 2, 1)\n            .with_memory_word(MEMORY_SIZE - 3, 6)\n            .with_program_counter(103);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_dshl() {\n        let program = r#\"\n0001    +0\n0002    +1\n0003    \"    \"\n0004    \"ABCD\"\n0100    DSHL 2, +25\n0101    DSHL 4, +12\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::DSHL)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::DSHL)\n                    .with_accumulator(4)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, 2)\n            .with_memory_word(2, 0)\n            .with_memory_word(3, \"  AB\")\n            .with_memory_word(4, \"CD\\0\\0\")\n            .with_memory_word(MEMORY_SIZE - 1, 25)\n            .with_memory_word(MEMORY_SIZE - 2, 12)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_drot() {\n        let program = r#\"\n0001    +2\n0002    +1\n0003    \"WXYZ\"\n0004    \"ABCD\"\n0100    DROT 2, +25\n0101    DROT 4, +12\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::DROT)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::DROT)\n                    .with_accumulator(4)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, 2)\n            .with_memory_word(2, 4)\n            .with_memory_word(3, \"YZAB\")\n            .with_memory_word(4, \"CDWX\")\n            .with_memory_word(MEMORY_SIZE - 1, 25)\n            .with_memory_word(MEMORY_SIZE - 2, 12)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_powr() {\n        let program = r#\"\n0001    +2\n0002    +2.0\n0100    POWR 1, +3\n0101    POWR 2, +3.0\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::POWR)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::POWR)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, 8)\n            .with_memory_word(2, 8.0)\n            .with_memory_word(MEMORY_SIZE - 1, 3)\n            .with_memory_word(MEMORY_SIZE - 2, 3.0)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_dmult() {\n        let program = r#\"\n0001    -1\n0002    -16000\n0100    DMULT 2, +12000\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::DMULT)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, -12)\n            .with_memory_word(2, -7450624)\n            .with_memory_word(MEMORY_SIZE - 1, 12000)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_div() {\n        let program = r#\"\n0001    -42\n0002    +41\n0100    DIV 1, +7\n0101    DIV 2, +7\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::DIV)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::DIV)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, -6)\n            .with_memory_word(2, 5)\n            .with_memory_word(MEMORY_SIZE - 1, 7)\n            .with_memory_word(MEMORY_SIZE - 2, 7)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_ddiv() {\n        let program = r#\"\n0001    -12\n0002    -7450624\n0100    DDIV 2, -12000\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::DDIV)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 0)\n            .with_memory_word(2, 16000)\n            .with_memory_word(MEMORY_SIZE - 1, -12000)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_nilx() {\n        let program = r#\"\n0001    +3.14\n0100    NILX 1, +2.71\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::NILX)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 2.71)\n            .with_memory_word(MEMORY_SIZE - 1, 3.14)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_orx() {\n        let program = r#\"\n0001    +12\n0100    ORX 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::ORX)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 10)\n            .with_memory_word(MEMORY_SIZE - 1, 14)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_neqvx() {\n        let program = r#\"\n0001    +12\n0100    NEQVX 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::NEQVX)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 10)\n            .with_memory_word(MEMORY_SIZE - 1, 6)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_addx() {\n        let program = r#\"\n0001    +12\n0100    ADDX 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::ADDX)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 10)\n            .with_memory_word(MEMORY_SIZE - 1, 22)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_subtx() {\n        let program = r#\"\n0001    +12\n0002    +10\n0100    SUBTX 1, +10\n0101    SUBTX 2, +12\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::SUBTX)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::SUBTX)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_memory_word(1, 10)\n            .with_memory_word(2, 12)\n            .with_memory_word(MEMORY_SIZE - 1, 2)\n            .with_memory_word(MEMORY_SIZE - 2, -2)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_multx() {\n        let program = r#\"\n0001    +12\n0100    MULTX 1, +10\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::MULTX)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 10)\n            .with_memory_word(MEMORY_SIZE - 1, 120)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_dvdx() {\n        let program = r#\"\n0001    +12\n0100    DVDX 1, +6\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::DVDX)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_memory_word(1, 6)\n            .with_memory_word(MEMORY_SIZE - 1, 2)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_put() {\n        let program = r#\"\n0001            +42\n0002            +3.14\n0003            \"ABCD\"\n0004            +2.718\n0100            PUT 1, +0\n0101            PUT 2, +0.0\n0102            PUT 3, \"    \"\n0103            PUT 4, LOC\n0110    LOC:    +0.0\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::PUT)\n                    .with_accumulator(1)\n                    .with_address(MEMORY_SIZE - 1)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::PUT)\n                    .with_accumulator(2)\n                    .with_address(MEMORY_SIZE - 2)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::PUT)\n                    .with_accumulator(3)\n                    .with_address(MEMORY_SIZE - 3)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::PUT)\n                    .with_accumulator(4)\n                    .with_address(110)\n                    .build(),\n            )\n            .with_memory_word(1, 42)\n            .with_memory_word(2, 3.14)\n            .with_memory_word(3, \"ABCD\")\n            .with_memory_word(4, 2.718)\n            .with_memory_word(MEMORY_SIZE - 1, 42)\n            .with_memory_word(MEMORY_SIZE - 2, 3.14)\n            .with_memory_word(MEMORY_SIZE - 3, \"ABCD\")\n            .with_memory_word(110, 2.718)\n            .with_program_counter(104);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_psqu() {\n        let program = r#\"\n0001            -1\n0002            -12\n0100            PSQU 2, LOC\n0110    LOC:    +0\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::PSQU)\n                    .with_accumulator(2)\n                    .with_address(110)\n                    .build(),\n            )\n            .with_memory_word(1, -1)\n            .with_memory_word(2, -12)\n            .with_memory_word(110, -12)\n            .with_program_counter(101);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_pneg() {\n        let program = r#\"\n0001            +3\n0002            -3.14\n0100            PNEG 1, LOC1\n0101            PNEG 2, LOC2\n0110    LOC1:   +0\n0111    LOC2:   +0\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::PNEG)\n                    .with_accumulator(1)\n                    .with_address(110)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::PNEG)\n                    .with_accumulator(2)\n                    .with_address(111)\n                    .build(),\n            )\n            .with_memory_word(1, 3)\n            .with_memory_word(2, -3.14)\n            .with_memory_word(110, -3)\n            .with_memory_word(111, 3.14)\n            .with_program_counter(102);\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn test_ptyp() {\n        let program = r#\"\n0001    +0\n0002    +1\n0003    +2\n0004    +3\n0100            PTYP 1, LOC1\n0101            PTYP 2, LOC2\n0102            PTYP 3, LOC3\n0103            PTYP 4, LOC4\n0110    LOC1:   +0.0\n0111    LOC2:   +0.0\n0112    LOC3:   +0.0\n0113    LOC4:   +0.0\n\"#;\n        let actual = execute(program).ok().unwrap();\n        let expected = ExecutionContext::default()\n            .with_instruction(\n                100,\n                InstructionBuilder::new(Function::PTYP)\n                    .with_accumulator(1)\n                    .with_address(110)\n                    .build(),\n            )\n            .with_instruction(\n                101,\n                InstructionBuilder::new(Function::PTYP)\n                    .with_accumulator(2)\n                    .with_address(111)\n                    .build(),\n            )\n            .with_instruction(\n                102,\n                InstructionBuilder::new(Function::PTYP)\n                    .with_accumulator(3)\n                    .with_address(112)\n                    .build(),\n            )\n            .with_instruction(\n                103,\n                InstructionBuilder::new(Function::PTYP)\n                    .with_accumulator(4)\n                    .with_address(113)\n                    .build(),\n            )\n            .with_memory_word(1, 0)\n            .with_memory_word(2, 1)\n            .with_memory_word(3, 2)\n            .with_memory_word(4, 3)\n            .with_memory_word(110, 0)\n            .with_memory_word(111, 0.0)\n            .with_memory_word(112, \"\\0\\0\\0\\0\")\n            .with_instruction(113, InstructionBuilder::new(Function::NIL).build())\n            .with_program_counter(104);\n        assert_eq!(actual, expected)\n    }\n}\n","traces":[{"line":17,"address":[693393,693184,693371],"length":1,"stats":{"Line":3}},{"line":18,"address":[693198],"length":1,"stats":{"Line":3}},{"line":19,"address":[693241,693287],"length":1,"stats":{"Line":6}},{"line":20,"address":[693339],"length":1,"stats":{"Line":3}},{"line":23,"address":[1365424,1365599,1365616,1365791,1365578,1365770],"length":1,"stats":{"Line":4}},{"line":29,"address":[1365645,1365453],"length":1,"stats":{"Line":4}},{"line":35,"address":[693408,694056],"length":1,"stats":{"Line":1}},{"line":36,"address":[693516,694054,693459],"length":1,"stats":{"Line":2}},{"line":38,"address":[693781],"length":1,"stats":{"Line":1}},{"line":39,"address":[693443,693941,693835],"length":1,"stats":{"Line":5}},{"line":41,"address":[693852,693815],"length":1,"stats":{"Line":2}},{"line":44,"address":[694080],"length":1,"stats":{"Line":1}},{"line":45,"address":[694088],"length":1,"stats":{"Line":1}},{"line":46,"address":[694093],"length":1,"stats":{"Line":1}},{"line":47,"address":[694117],"length":1,"stats":{"Line":1}},{"line":50,"address":[694144],"length":1,"stats":{"Line":1}},{"line":51,"address":[694173],"length":1,"stats":{"Line":3}},{"line":52,"address":[694182,694627],"length":1,"stats":{"Line":1}},{"line":53,"address":[694217],"length":1,"stats":{"Line":3}},{"line":54,"address":[694451],"length":1,"stats":{"Line":1}},{"line":55,"address":[694540,694643,694795],"length":1,"stats":{"Line":4}},{"line":56,"address":[694731],"length":1,"stats":{"Line":0}},{"line":57,"address":[694699],"length":1,"stats":{"Line":3}},{"line":58,"address":[694717],"length":1,"stats":{"Line":1}},{"line":61,"address":[694832,697249],"length":1,"stats":{"Line":1}},{"line":63,"address":[694875,695897,697054],"length":1,"stats":{"Line":4}},{"line":64,"address":[694895],"length":1,"stats":{"Line":1}},{"line":65,"address":[694917],"length":1,"stats":{"Line":3}},{"line":66,"address":[694939],"length":1,"stats":{"Line":1}},{"line":67,"address":[694961],"length":1,"stats":{"Line":3}},{"line":68,"address":[694983],"length":1,"stats":{"Line":1}},{"line":69,"address":[695005],"length":1,"stats":{"Line":3}},{"line":70,"address":[695027],"length":1,"stats":{"Line":1}},{"line":71,"address":[695049],"length":1,"stats":{"Line":3}},{"line":72,"address":[695071],"length":1,"stats":{"Line":1}},{"line":73,"address":[695093],"length":1,"stats":{"Line":3}},{"line":74,"address":[695115],"length":1,"stats":{"Line":1}},{"line":75,"address":[695137],"length":1,"stats":{"Line":3}},{"line":76,"address":[695159],"length":1,"stats":{"Line":1}},{"line":77,"address":[695181],"length":1,"stats":{"Line":3}},{"line":78,"address":[695203],"length":1,"stats":{"Line":1}},{"line":79,"address":[695225],"length":1,"stats":{"Line":3}},{"line":80,"address":[695247],"length":1,"stats":{"Line":1}},{"line":81,"address":[695272],"length":1,"stats":{"Line":3}},{"line":82,"address":[695297],"length":1,"stats":{"Line":1}},{"line":83,"address":[695322],"length":1,"stats":{"Line":3}},{"line":84,"address":[695347],"length":1,"stats":{"Line":1}},{"line":85,"address":[695372],"length":1,"stats":{"Line":3}},{"line":86,"address":[695397],"length":1,"stats":{"Line":1}},{"line":87,"address":[695422],"length":1,"stats":{"Line":3}},{"line":88,"address":[695447],"length":1,"stats":{"Line":1}},{"line":89,"address":[695472],"length":1,"stats":{"Line":3}},{"line":90,"address":[695497],"length":1,"stats":{"Line":1}},{"line":91,"address":[695522],"length":1,"stats":{"Line":3}},{"line":92,"address":[695547],"length":1,"stats":{"Line":1}},{"line":93,"address":[695572],"length":1,"stats":{"Line":3}},{"line":94,"address":[695597],"length":1,"stats":{"Line":1}},{"line":95,"address":[695622],"length":1,"stats":{"Line":3}},{"line":96,"address":[695647],"length":1,"stats":{"Line":1}},{"line":97,"address":[695672],"length":1,"stats":{"Line":3}},{"line":98,"address":[695697],"length":1,"stats":{"Line":1}},{"line":99,"address":[695722],"length":1,"stats":{"Line":3}},{"line":100,"address":[695747],"length":1,"stats":{"Line":1}},{"line":101,"address":[695772],"length":1,"stats":{"Line":3}},{"line":102,"address":[695797],"length":1,"stats":{"Line":1}},{"line":103,"address":[695822],"length":1,"stats":{"Line":3}},{"line":104,"address":[695847],"length":1,"stats":{"Line":1}},{"line":105,"address":[695872],"length":1,"stats":{"Line":3}},{"line":110,"address":[697142],"length":1,"stats":{"Line":3}},{"line":111,"address":[697038,697119],"length":1,"stats":{"Line":4}},{"line":113,"address":[697211],"length":1,"stats":{"Line":1}},{"line":116,"address":[697280],"length":1,"stats":{"Line":1}},{"line":117,"address":[697330],"length":1,"stats":{"Line":3}},{"line":119,"address":[697338],"length":1,"stats":{"Line":1}},{"line":120,"address":[697353],"length":1,"stats":{"Line":3}},{"line":122,"address":[697559,697368],"length":1,"stats":{"Line":1}},{"line":123,"address":[697621,697404],"length":1,"stats":{"Line":0}},{"line":124,"address":[697569],"length":1,"stats":{"Line":0}},{"line":125,"address":[697544],"length":1,"stats":{"Line":0}},{"line":128,"address":[697377],"length":1,"stats":{"Line":3}},{"line":129,"address":[697704,697905],"length":1,"stats":{"Line":0}},{"line":131,"address":[697841],"length":1,"stats":{"Line":0}},{"line":132,"address":[697821],"length":1,"stats":{"Line":0}},{"line":135,"address":[697650],"length":1,"stats":{"Line":1}},{"line":138,"address":[697952],"length":1,"stats":{"Line":3}},{"line":139,"address":[697994],"length":1,"stats":{"Line":1}},{"line":140,"address":[698019],"length":1,"stats":{"Line":3}},{"line":141,"address":[698085],"length":1,"stats":{"Line":3}},{"line":144,"address":[698121,698112],"length":1,"stats":{"Line":4}},{"line":145,"address":[698156],"length":1,"stats":{"Line":3}},{"line":146,"address":[698175],"length":1,"stats":{"Line":3}},{"line":150,"address":[698208,698218],"length":1,"stats":{"Line":2}},{"line":152,"address":[698224],"length":1,"stats":{"Line":1}},{"line":153,"address":[698248],"length":1,"stats":{"Line":1}},{"line":154,"address":[698299],"length":1,"stats":{"Line":1}},{"line":157,"address":[698336],"length":1,"stats":{"Line":1}},{"line":158,"address":[698360],"length":1,"stats":{"Line":1}},{"line":159,"address":[698411],"length":1,"stats":{"Line":1}},{"line":162,"address":[698448],"length":1,"stats":{"Line":1}},{"line":163,"address":[698472],"length":1,"stats":{"Line":1}},{"line":164,"address":[698523],"length":1,"stats":{"Line":1}},{"line":167,"address":[698560],"length":1,"stats":{"Line":1}},{"line":168,"address":[698584],"length":1,"stats":{"Line":1}},{"line":169,"address":[698635],"length":1,"stats":{"Line":2}},{"line":172,"address":[698672],"length":1,"stats":{"Line":1}},{"line":173,"address":[698696],"length":1,"stats":{"Line":1}},{"line":174,"address":[698747],"length":1,"stats":{"Line":1}},{"line":177,"address":[698784],"length":1,"stats":{"Line":1}},{"line":178,"address":[698808],"length":1,"stats":{"Line":1}},{"line":179,"address":[698859],"length":1,"stats":{"Line":2}},{"line":182,"address":[698896],"length":1,"stats":{"Line":1}},{"line":183,"address":[698920],"length":1,"stats":{"Line":1}},{"line":184,"address":[698971],"length":1,"stats":{"Line":1}},{"line":187,"address":[699008],"length":1,"stats":{"Line":1}},{"line":188,"address":[699032],"length":1,"stats":{"Line":1}},{"line":189,"address":[699083],"length":1,"stats":{"Line":1}},{"line":192,"address":[699120],"length":1,"stats":{"Line":1}},{"line":193,"address":[699154],"length":1,"stats":{"Line":1}},{"line":194,"address":[699200],"length":1,"stats":{"Line":1}},{"line":195,"address":[699267],"length":1,"stats":{"Line":1}},{"line":196,"address":[699302,699546],"length":1,"stats":{"Line":2}},{"line":199,"address":[699600],"length":1,"stats":{"Line":1}},{"line":200,"address":[699634],"length":1,"stats":{"Line":1}},{"line":201,"address":[699781,699920],"length":1,"stats":{"Line":2}},{"line":202,"address":[700021],"length":1,"stats":{"Line":1}},{"line":205,"address":[700096],"length":1,"stats":{"Line":1}},{"line":206,"address":[700121],"length":1,"stats":{"Line":1}},{"line":207,"address":[700164],"length":1,"stats":{"Line":1}},{"line":210,"address":[700224],"length":1,"stats":{"Line":1}},{"line":211,"address":[700249],"length":1,"stats":{"Line":1}},{"line":212,"address":[700292],"length":1,"stats":{"Line":1}},{"line":215,"address":[700368],"length":1,"stats":{"Line":1}},{"line":216,"address":[700393],"length":1,"stats":{"Line":1}},{"line":217,"address":[700436],"length":1,"stats":{"Line":1}},{"line":220,"address":[701340,700512],"length":1,"stats":{"Line":1}},{"line":221,"address":[700554],"length":1,"stats":{"Line":1}},{"line":222,"address":[700604],"length":1,"stats":{"Line":1}},{"line":223,"address":[700773,700941],"length":1,"stats":{"Line":2}},{"line":224,"address":[701065,700971],"length":1,"stats":{"Line":2}},{"line":227,"address":[701376],"length":1,"stats":{"Line":1}},{"line":228,"address":[701432,701395],"length":1,"stats":{"Line":1}},{"line":231,"address":[701456],"length":1,"stats":{"Line":1}},{"line":232,"address":[701481],"length":1,"stats":{"Line":1}},{"line":233,"address":[701524,701595],"length":1,"stats":{"Line":2}},{"line":234,"address":[701563,701597],"length":1,"stats":{"Line":1}},{"line":238,"address":[701616],"length":1,"stats":{"Line":1}},{"line":239,"address":[701641],"length":1,"stats":{"Line":1}},{"line":240,"address":[701755,701684],"length":1,"stats":{"Line":2}},{"line":241,"address":[701723,701757],"length":1,"stats":{"Line":1}},{"line":245,"address":[701776],"length":1,"stats":{"Line":1}},{"line":246,"address":[701801],"length":1,"stats":{"Line":1}},{"line":247,"address":[701844],"length":1,"stats":{"Line":1}},{"line":248,"address":[701960,701916],"length":1,"stats":{"Line":2}},{"line":249,"address":[701930,701962],"length":1,"stats":{"Line":1}},{"line":253,"address":[701984],"length":1,"stats":{"Line":1}},{"line":254,"address":[702009],"length":1,"stats":{"Line":1}},{"line":255,"address":[702052,702123],"length":1,"stats":{"Line":2}},{"line":256,"address":[702125,702091],"length":1,"stats":{"Line":1}},{"line":260,"address":[702144],"length":1,"stats":{"Line":1}},{"line":261,"address":[702169],"length":1,"stats":{"Line":1}},{"line":262,"address":[702283,702212],"length":1,"stats":{"Line":2}},{"line":263,"address":[702285,702251],"length":1,"stats":{"Line":1}},{"line":267,"address":[702304],"length":1,"stats":{"Line":1}},{"line":268,"address":[702332],"length":1,"stats":{"Line":1}},{"line":269,"address":[702380,702683],"length":1,"stats":{"Line":2}},{"line":270,"address":[702685,702679,702643],"length":1,"stats":{"Line":2}},{"line":272,"address":[702423,702631],"length":1,"stats":{"Line":2}},{"line":276,"address":[702704],"length":1,"stats":{"Line":1}},{"line":277,"address":[702732],"length":1,"stats":{"Line":1}},{"line":278,"address":[702780,703083],"length":1,"stats":{"Line":2}},{"line":279,"address":[703043,703079,703085],"length":1,"stats":{"Line":2}},{"line":281,"address":[702823,703031],"length":1,"stats":{"Line":2}},{"line":285,"address":[703104],"length":1,"stats":{"Line":1}},{"line":286,"address":[703128],"length":1,"stats":{"Line":1}},{"line":287,"address":[703179],"length":1,"stats":{"Line":1}},{"line":290,"address":[703216],"length":1,"stats":{"Line":1}},{"line":291,"address":[703243],"length":1,"stats":{"Line":1}},{"line":292,"address":[703285,703469],"length":1,"stats":{"Line":2}},{"line":295,"address":[703488],"length":1,"stats":{"Line":1}},{"line":296,"address":[703521],"length":1,"stats":{"Line":1}},{"line":297,"address":[703567,703856],"length":1,"stats":{"Line":2}},{"line":298,"address":[703892],"length":1,"stats":{"Line":1}},{"line":299,"address":[703943],"length":1,"stats":{"Line":1}},{"line":302,"address":[703984],"length":1,"stats":{"Line":1}},{"line":303,"address":[704017],"length":1,"stats":{"Line":1}},{"line":304,"address":[704352,704063],"length":1,"stats":{"Line":2}},{"line":305,"address":[704388],"length":1,"stats":{"Line":1}},{"line":306,"address":[704439],"length":1,"stats":{"Line":1}},{"line":309,"address":[704480],"length":1,"stats":{"Line":1}},{"line":310,"address":[704504],"length":1,"stats":{"Line":1}},{"line":311,"address":[704546],"length":1,"stats":{"Line":1}},{"line":314,"address":[704576],"length":1,"stats":{"Line":1}},{"line":315,"address":[704609],"length":1,"stats":{"Line":1}},{"line":316,"address":[704944,704655],"length":1,"stats":{"Line":2}},{"line":317,"address":[704980],"length":1,"stats":{"Line":1}},{"line":318,"address":[705031],"length":1,"stats":{"Line":1}},{"line":321,"address":[705072],"length":1,"stats":{"Line":1}},{"line":322,"address":[705096],"length":1,"stats":{"Line":1}},{"line":323,"address":[705147],"length":1,"stats":{"Line":1}},{"line":326,"address":[705184],"length":1,"stats":{"Line":1}},{"line":327,"address":[705217],"length":1,"stats":{"Line":1}},{"line":328,"address":[705263,705552],"length":1,"stats":{"Line":2}},{"line":329,"address":[705588],"length":1,"stats":{"Line":1}},{"line":330,"address":[705639],"length":1,"stats":{"Line":1}},{"line":333,"address":[705680],"length":1,"stats":{"Line":1}},{"line":334,"address":[705712],"length":1,"stats":{"Line":1}},{"line":335,"address":[705769],"length":1,"stats":{"Line":1}},{"line":336,"address":[705815],"length":1,"stats":{"Line":1}},{"line":337,"address":[705843],"length":1,"stats":{"Line":1}},{"line":338,"address":[705880],"length":1,"stats":{"Line":1}},{"line":341,"address":[705920],"length":1,"stats":{"Line":1}},{"line":342,"address":[705944],"length":1,"stats":{"Line":1}},{"line":343,"address":[705959],"length":1,"stats":{"Line":1}},{"line":346,"address":[705984],"length":1,"stats":{"Line":1}},{"line":347,"address":[706008],"length":1,"stats":{"Line":1}},{"line":348,"address":[706023],"length":1,"stats":{"Line":1}},{"line":351,"address":[706048],"length":1,"stats":{"Line":1}},{"line":352,"address":[706072],"length":1,"stats":{"Line":1}},{"line":353,"address":[706087],"length":1,"stats":{"Line":1}},{"line":356,"address":[706112],"length":1,"stats":{"Line":1}},{"line":357,"address":[706136],"length":1,"stats":{"Line":1}},{"line":358,"address":[706151],"length":1,"stats":{"Line":1}},{"line":361,"address":[706176],"length":1,"stats":{"Line":1}},{"line":362,"address":[706200],"length":1,"stats":{"Line":1}},{"line":363,"address":[706215],"length":1,"stats":{"Line":1}},{"line":366,"address":[706240],"length":1,"stats":{"Line":1}},{"line":367,"address":[706264],"length":1,"stats":{"Line":1}},{"line":368,"address":[706279],"length":1,"stats":{"Line":1}},{"line":371,"address":[706304],"length":1,"stats":{"Line":1}},{"line":372,"address":[706334],"length":1,"stats":{"Line":1}},{"line":373,"address":[706362],"length":1,"stats":{"Line":1}},{"line":374,"address":[706408],"length":1,"stats":{"Line":1}},{"line":377,"address":[706448],"length":1,"stats":{"Line":1}},{"line":378,"address":[706489],"length":1,"stats":{"Line":1}},{"line":379,"address":[706523],"length":1,"stats":{"Line":1}},{"line":380,"address":[706578],"length":1,"stats":{"Line":1}},{"line":381,"address":[706605,706834],"length":1,"stats":{"Line":2}},{"line":382,"address":[706855],"length":1,"stats":{"Line":1}},{"line":383,"address":[706880],"length":1,"stats":{"Line":1}},{"line":386,"address":[706944],"length":1,"stats":{"Line":1}},{"line":387,"address":[706974],"length":1,"stats":{"Line":1}},{"line":388,"address":[707002],"length":1,"stats":{"Line":1}},{"line":389,"address":[707029],"length":1,"stats":{"Line":1}},{"line":392,"address":[707088],"length":1,"stats":{"Line":1}},{"line":393,"address":[707118],"length":1,"stats":{"Line":1}},{"line":394,"address":[707146],"length":1,"stats":{"Line":1}},{"line":395,"address":[707183],"length":1,"stats":{"Line":1}},{"line":400,"address":[707216],"length":1,"stats":{"Line":0}},{"line":401,"address":[707234],"length":1,"stats":{"Line":0}},{"line":410,"address":[707392],"length":1,"stats":{"Line":0}},{"line":411,"address":[707406],"length":1,"stats":{"Line":0}},{"line":451,"address":[708545,707920,708520],"length":1,"stats":{"Line":3}},{"line":452,"address":[707937],"length":1,"stats":{"Line":3}},{"line":453,"address":[708041,707973],"length":1,"stats":{"Line":2}},{"line":454,"address":[708475,708072],"length":1,"stats":{"Line":1}},{"line":455,"address":[708443],"length":1,"stats":{"Line":0}},{"line":457,"address":[708317],"length":1,"stats":{"Line":1}},{"line":467,"address":[708560],"length":1,"stats":{"Line":1}},{"line":468,"address":[708574],"length":1,"stats":{"Line":1}},{"line":473,"address":[708592],"length":1,"stats":{"Line":0}},{"line":474,"address":[708606],"length":1,"stats":{"Line":0}},{"line":481,"address":[708624],"length":1,"stats":{"Line":1}},{"line":482,"address":[708638],"length":1,"stats":{"Line":1}},{"line":487,"address":[708656],"length":1,"stats":{"Line":3}},{"line":488,"address":[708670],"length":1,"stats":{"Line":3}},{"line":495,"address":[708688],"length":1,"stats":{"Line":0}},{"line":496,"address":[708702],"length":1,"stats":{"Line":0}},{"line":501,"address":[708720],"length":1,"stats":{"Line":0}},{"line":502,"address":[708734],"length":1,"stats":{"Line":0}},{"line":509,"address":[708752],"length":1,"stats":{"Line":3}},{"line":510,"address":[708766],"length":1,"stats":{"Line":1}},{"line":515,"address":[708784],"length":1,"stats":{"Line":1}},{"line":516,"address":[708798],"length":1,"stats":{"Line":1}}],"covered":255,"coverable":273},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","grammar.rs"],"content":"use super::ast::*;\n\nuse pom::utf8::*;\n\nuse std::str::FromStr;\n\n// ****************************************************************************\n// Pom representation of \"The Assembler\" section of:\n// https://github.com/nigeleke/bbc-x/blob/main/docs/BBCX.pdf\n//\n// The assember is single pass so that each line of source code\n// is translated into object code completely on a line by line\n// basis.\n\npub struct Grammar;\n\nimpl Grammar {\n    pub fn bbcx_line\u003c'a\u003e() -\u003e Parser\u003c'a, SourceLine\u003e {\n        source_program_line()\n    }\n}\n\n// ****************************************************************************\n// A source program line consists of the address of the location which is to\n// receive the translated version of the source word followed by the source\n// word itself.\nfn source_program_line\u003c'a\u003e() -\u003e Parser\u003c'a, SourceLine\u003e {\n    let as_source_program_line = |(((l, lbl), w), c)| SourceLine::new(l, lbl, w, c);\n\n    (location() + label() - inline_ws().opt() + source_program_word() - inline_ws().opt()\n        + comment()\n        - end())\n    .map(as_source_program_line)\n    .name(\"source_program_line\")\n}\n\n// \u003clocation\u003e ::= \u003cnumeric address\u003e\u003cspace\u003e\nfn location\u003c'a\u003e() -\u003e Parser\u003c'a, Location\u003e {\n    (absolute_address() - inline_ws()).name(\"location\")\n}\n\n// label := \u003cidenifier\u003e :\nfn label\u003c'a\u003e() -\u003e Parser\u003c'a, Label\u003e {\n    ((identifier() - sym(':')).map(Label::from)) | empty().map(|_| Label::from(None)).name(\"label\")\n}\n\n// This source word can be any of the four tyoes (but certain conventions\n// must be kept to if the program is to list correctly)\nfn source_program_word\u003c'a\u003e() -\u003e Parser\u003c'a, SourceWord\u003e {\n    (pword().map(SourceWord::PWord)\n        | fword().map(SourceWord::FWord)\n        | iword().map(SourceWord::IWord)\n        | sword().map(SourceWord::SWord))\n    .name(\"source_program_word\")\n}\n\n// ; COMMENT\nfn comment\u003c'a\u003e() -\u003e Parser\u003c'a, Comment\u003e {\n    let actual = || {\n        sym(';')\n            * none_of(\"\\n\")\n                .repeat(0..)\n                .map(|s| format!(\";{}\", String::from_iter(s)))\n    };\n    (actual() | empty().map(|_| \"\".to_string())).name(\"comment\")\n}\n\n// ****************************************************************************\n// The basic format for a P-word consists of a mnemonic terminated by a space\n// followed by an accumulator address (an integer from 0 to 7) terminated by a\n// comma followed by a store operand specifier.\nfn pword\u003c'a\u003e() -\u003e Parser\u003c'a, PWord\u003e {\n    (mnemonic() - inline_ws().opt() + acc() - inline_ws().opt() + store_operand())\n        .map(|((m, a), so)| PWord::new(m, a, so))\n        .name(\"pword\")\n}\n\n// ****************************************************************************\n// \u003cS-word\u003e ::= \u003cquote\u003e\u003cactual character\u003e\u003ccharacter\u003e\u003ccharacter\u003e\n//              \u003ccharacter\u003e\u003cunquote\u003e\nfn sword\u003c'a\u003e() -\u003e Parser\u003c'a, SWord\u003e {\n    (sym('\"') + actual_character().repeat(1..=4) + sym('\"'))\n        .map(|((_, cs), _)| SWord::from_iter(cs.iter()))\n        .name(\"sword\")\n}\n// \u003cF-word\u003e ::= \u003cunsigned F-word\u003e | \u003csigned F-word\u003e\nfn fword\u003c'a\u003e() -\u003e Parser\u003c'a, FWord\u003e {\n    (unsigned_fword() | signed_fword()).name(\"fword\")\n}\n\n// \u003cI-word\u003e ::= \u003cunsigned integer\u003e | \u003csigned integer\u003e\nfn iword\u003c'a\u003e() -\u003e Parser\u003c'a, IWord\u003e {\n    (unsigned_integer() | signed_integer()).name(\"iword\")\n}\n\n// \u003cdigit\u003e ::= \u003coct.dig\u003e | 8 | 9\nfn digit\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    oct_dig() | one_of(\"89\")\n}\n\n// \u003coct.dig\u003e ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7\nfn oct_dig\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    one_of(\u0026('0'..='7'))\n}\n\n// Added: ++\n// Represents 'space()' in description\nfn inline_ws\u003c'a\u003e() -\u003e Parser\u003c'a, String\u003e {\n    one_of(\" \\t\")\n        .repeat(1..)\n        .map(String::from_iter)\n        .name(\"inline_ws\")\n}\n// Added: --\n\nfn store_operand\u003c'a\u003e() -\u003e Parser\u003c'a, StoreOperand\u003e {\n    (address_operand().map(StoreOperand::AddressOperand)\n        | const_operand().map(StoreOperand::ConstOperand)\n        | empty().map(|_| StoreOperand::None))\n    .name(\"store_operand\")\n}\n\nfn address_operand\u003c'a\u003e() -\u003e Parser\u003c'a, AddressOperand\u003e {\n    (simple_address_operand() + index_ref().opt())\n        .map(|(o, i)| AddressOperand::new(o, i))\n        .name(\"address_operand\")\n}\n\n// \u003cconst. operand\u003e ::= \u003csigned integer\u003e | \u003csigned F-word\u003e !\n//                      \u003coctal\u003e | \u003cS-word\u003e\nfn const_operand\u003c'a\u003e() -\u003e Parser\u003c'a, ConstOperand\u003e {\n    inline_ws().opt()\n        * (signed_fword().map(ConstOperand::SignedFWord)\n            | signed_integer().map(ConstOperand::SignedIWord)\n            | sword().map(ConstOperand::SWord))\n        .name(\"const_operand\")\n}\n\nfn simple_address_operand\u003c'a\u003e() -\u003e Parser\u003c'a, SimpleAddressOperand\u003e {\n    (address().map(SimpleAddressOperand::DirectAddress)\n        | (sym('*') * address()).map(SimpleAddressOperand::IndirectAddress))\n    .name(\"simple_address_operand\")\n}\n\n// \u003caddress\u003e ::= \u003cidentifier\u003e | \u003cnumeric address\u003e\nfn address\u003c'a\u003e() -\u003e Parser\u003c'a, Address\u003e {\n    (identifier().map(Address::Identifier) | numeric_address().map(Address::NumericAddress))\n        .name(\"address\")\n}\n\n// \u003cidentifier\u003e ::= \u003calpha char.\u003e | \u003cidentifier\u003e\u003calpha char.\u003e !\n//                  \u003cidentifier\u003e\u003cdigit\u003e\nfn identifier\u003c'a\u003e() -\u003e Parser\u003c'a, Identifier\u003e {\n    let concat = |a: char, ans: \u0026[char]| {\n        let mut id = Vec::from(ans);\n        id.insert(0, a);\n        String::from_iter(id)\n    };\n\n    (alpha_character() + alpha_numeric().repeat(0..))\n        .map(move |ans| concat(ans.0, \u0026ans.1))\n        .name(\"identifier\")\n}\n\n// \u003cactual character\u003e ::= \u003calpha character\u003e | \u003cnumeric character\u003e |\n//                        \u003cpunctuation\u003e\nfn actual_character\u003c'a\u003e() -\u003e Parser\u003c'a, Character\u003e {\n    (alpha_character() | numeric_character() | punctuation()).name(\"actual_character\")\n}\n\n// \u003calpha character\u003e ::= A | B | C | D | E | F | G | H | I | J | K| L |M | N | O | P |\n//                       Q | R | S | T | V | W | X | Y | Z\nfn alpha_character\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    one_of(\u0026('A'..='Z')).name(\"alpha_character\")\n}\n\n// \u003cnumeric character\u003e ::= \u003cdigit\u003e | + | - | \u003csubscript 10\u003e | .\nfn numeric_character\u003c'a\u003e() -\u003e Parser\u003c'a, NumericCharacter\u003e {\n    (digit() | sym('+') | sym('-') | subscript10() | sym('.')).name(\"numeric_character\")\n}\n\n// \u003cpunctuation\u003e ::= ( | \u003cquote\u003e | \u003cunquote\u003e | \u003capostrophe\u003e | * | / |\n//                   : | ) | = | ? | ^ | ~ | # | ; | , | \u003cspace\u003e\nfn punctuation\u003c'a\u003e() -\u003e Parser\u003c'a, Punctuation\u003e {\n    one_of(\"\u003c\u003e'*/:)=?^~#;. \").name(\"punctuation\")\n}\n\nfn alpha_numeric\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    (alpha_character() | digit()).name(\"alpha_numeric\")\n}\n\nfn subscript10\u003c'a\u003e() -\u003e Parser\u003c'a, char\u003e {\n    sym('@')\n}\n\n// \u003cnumeric address\u003e ::= \u003cabsolute address\u003e | \u003crelative address\u003e\nfn numeric_address\u003c'a\u003e() -\u003e Parser\u003c'a, NumericAddress\u003e {\n    unsigned_integer()\n        .map(|i| i as NumericAddress)\n        .name(\"numeric_address\")\n}\n\n// TODO: Work out what an Index actually is in bbc-x; it appears to be numeric only and possibly single digit??\nfn index\u003c'a\u003e() -\u003e Parser\u003c'a, IndexRegister\u003e {\n    digit()\n        .repeat(1..=2)\n        .map(String::from_iter)\n        .convert(|s| IndexRegister::from_str(\u0026s))\n        .name(\"index\")\n}\n\nfn index_ref\u003c'a\u003e() -\u003e Parser\u003c'a, IndexRegister\u003e {\n    (sym('[') * index() - sym(']')).map(|i| i).name(\"index_ref\")\n}\n\n// ****************************************************************************\n// \u003csigned F-word\u003e ::= +\u003cunsigned F-word\u003e | -\u003cunsigned F-word\u003e\nfn signed_fword\u003c'a\u003e() -\u003e Parser\u003c'a, FWord\u003e {\n    let negate = |f: FloatType| -f;\n\n    ((sym('+') * unsigned_fword()) | (sym('-') * unsigned_fword().map(negate))).name(\"signed_fword\")\n}\n\n// \u003cunsigned F-word\u003e ::= \u003cdecimal part\u003e | \u003cdecimal part\u003e\n//                       \u003cexponent part\u003e | \u003cunsigned integer\u003e\n//                       \u003cexponent part\u003e\nfn unsigned_fword\u003c'a\u003e() -\u003e Parser\u003c'a, FWord\u003e {\n    let de_to_float1 = |(d, e)| FloatType::from_str(\u0026format!(\"{}e{}\", d, e));\n    let de_to_float2 = |(d, e)| FloatType::from_str(\u0026format!(\"{}e{}\", d, e));\n\n    (decimal_part().convert(|s| FloatType::from_str(\u0026s))\n        | (decimal_part() + exponent_part()).convert(de_to_float1)\n        | (unsigned_integer() + exponent_part()).convert(de_to_float2))\n    .name(\"unsigned_fword\")\n}\n\n// \u003cdecimal part\u003e ::= \u003cunsigned integer\u003e.\u003cunsigned integer\u003e |\n//                    .\u003cunsigned integer\u003e\nfn decimal_part\u003c'a\u003e() -\u003e Parser\u003c'a, String\u003e {\n    let if_to_string = |(i, f): (IntType, IntType)| format!(\"{}.{}\", i, f);\n    let f_to_string = |f: IntType| format!(\"0.{}\", f);\n\n    ((unsigned_integer() - sym('.').discard() + unsigned_integer()).map(if_to_string)\n        | (sym('.').discard() * unsigned_integer()).map(f_to_string))\n    .name(\"decimal_part\")\n}\n\n// \u003cexponent part\u003e ::= \u003csubscript 10\u003e\u003csign\u003e\u003cdigit\u003e |\n//                     \u003csubscript 10\u003e\u003csign\u003e\u003cdigit\u003e\u003cdigit\u003e\nfn exponent_part\u003c'a\u003e() -\u003e Parser\u003c'a, String\u003e {\n    let sd_to_string = |(s, d): (String, char)| format!(\"{}{}\", s, d);\n    let sdd_to_string = |((s, d1), d2): ((String, char), char)| format!(\"{}{}{}\", s, d1, d2);\n\n    ((subscript10().discard() * sign() + digit()).map(sd_to_string)\n        | (subscript10().discard() * sign() + digit() + digit()).map(sdd_to_string))\n    .name(\"exponent_part\")\n}\n\n// \u003csign\u003e ::= \u003cno character\u003e | + | -\nfn sign\u003c'a\u003e() -\u003e Parser\u003c'a, String\u003e {\n    (sym('+') | sym('-'))\n        .repeat(..=1)\n        .map(String::from_iter)\n        .name(\"sign\")\n}\n\n// \u003csigned integer\u003e ::= +\u003cunsigned integer\u003e | -\u003cunsigned integer\u003e\nfn signed_integer\u003c'a\u003e() -\u003e Parser\u003c'a, IntType\u003e {\n    let negate = |i: IntType| -i;\n\n    ((sym('+') * unsigned_integer()) | (sym('-') * unsigned_integer().map(negate)))\n        .name(\"signed_integer\")\n}\n\n// \u003cunsigned integer\u003e ::= \u003cdigit\u003e | \u003cdigit\u003e\u003cunsigned integer\u003e\nfn unsigned_integer\u003c'a\u003e() -\u003e Parser\u003c'a, IntType\u003e {\n    digit()\n        .repeat(1..)\n        .map(String::from_iter)\n        .convert(|s| IntType::from_str(\u0026s))\n        .name(\"unsigned_integer\")\n}\n\n// An accumulator address (an integer from 0 to 7).\n// The accumulator address and terminating comma can be omitted\n// if the user wishes to use accumulator 1.\nfn acc\u003c'a\u003e() -\u003e Parser\u003c'a, Acc\u003e {\n    ((oct_dig() - sym(',')).map(Acc::from) | empty().map(|_| Acc::from(None))).name(\"acc\")\n}\n\n// \u003cabsolute address\u003e ::= \u003cUnsigned integer\u003e\nfn absolute_address\u003c'a\u003e() -\u003e Parser\u003c'a, AddressRef\u003e {\n    unsigned_integer()\n        .map(|i| i as AddressRef)\n        .name(\"absolute_address\")\n}\n\nfn mnemonic\u003c'a\u003e() -\u003e Parser\u003c'a, Mnemonic\u003e {\n    (exact(\"DBYTE\").map(|_| Mnemonic::DBYTE)\n        | exact(\"EXTRA\").map(|_| Mnemonic::EXTRA)\n        | exact(\"MOCKP\").map(|_| Mnemonic::MOCKP)\n        | exact(\"MOCKS\").map(|_| Mnemonic::MOCKS)\n        | exact(\"MPLYX\").map(|_| Mnemonic::MULTX)\n        | exact(\"MULTX\").map(|_| Mnemonic::MULTX)\n        | exact(\"NEQVX\").map(|_| Mnemonic::NEQVX)\n        | exact(\"SUBTX\").map(|_| Mnemonic::SUBTX)\n        | exact(\"ADDX\").map(|_| Mnemonic::ADDX)\n        | exact(\"ANDX\").map(|_| Mnemonic::ANDX)\n        | exact(\"DDIV\").map(|_| Mnemonic::DDIV)\n        | exact(\"DECR\").map(|_| Mnemonic::DECR)\n        | exact(\"DMULT\").map(|_| Mnemonic::DMULT)\n        | exact(\"DROT\").map(|_| Mnemonic::DROT)\n        | exact(\"DSHL\").map(|_| Mnemonic::DSHL)\n        | exact(\"DVDX\").map(|_| Mnemonic::DVDX)\n        | exact(\"EXEC\").map(|_| Mnemonic::EXEC)\n        | exact(\"INCR\").map(|_| Mnemonic::INCR)\n        | exact(\"JUMP\").map(|_| Mnemonic::JUMP)\n        | exact(\"MPLY\").map(|_| Mnemonic::MULT)\n        | exact(\"MULT\").map(|_| Mnemonic::MULT)\n        | exact(\"NEQV\").map(|_| Mnemonic::NEQV)\n        | exact(\"NTHG\").map(|_| Mnemonic::NIL)\n        | exact(\"PNEG\").map(|_| Mnemonic::PNEG)\n        | exact(\"PNOT\").map(|_| Mnemonic::PNOT)\n        | exact(\"POWR\").map(|_| Mnemonic::POWR)\n        | exact(\"PSQU\").map(|_| Mnemonic::PSQU)\n        | exact(\"PTYP\").map(|_| Mnemonic::PTYP)\n        | exact(\"PTYZ\").map(|_| Mnemonic::PTYZ)\n        | exact(\"PFFP\").map(|_| Mnemonic::PFFP)\n        | exact(\"SKAE\").map(|_| Mnemonic::SKAE)\n        | exact(\"SKAL\").map(|_| Mnemonic::SKAL)\n        | exact(\"SKAG\").map(|_| Mnemonic::SKAG)\n        | exact(\"SKAN\").map(|_| Mnemonic::SKAN)\n        | exact(\"SKED\").map(|_| Mnemonic::SKED)\n        | exact(\"SKEI\").map(|_| Mnemonic::SKEI)\n        | exact(\"SKET\").map(|_| Mnemonic::SKET)\n        | exact(\"SKIP\").map(|_| Mnemonic::SKIP)\n        | exact(\"SUBT\").map(|_| Mnemonic::SUBT)\n        | exact(\"NILX\").map(|_| Mnemonic::NILX)\n        | exact(\"SWAP\").map(|_| Mnemonic::NILX)\n        | exact(\"TAKE\").map(|_| Mnemonic::TAKE)\n        | exact(\"TNEG\").map(|_| Mnemonic::TNEG)\n        | exact(\"TNOT\").map(|_| Mnemonic::TNOT)\n        | exact(\"TOUT\").map(|_| Mnemonic::TOUT)\n        | exact(\"TSTR\").map(|_| Mnemonic::TSTR)\n        | exact(\"TTTT\").map(|_| Mnemonic::TTTT)\n        | exact(\"TTYP\").map(|_| Mnemonic::TTYP)\n        | exact(\"TTYZ\").map(|_| Mnemonic::TTYZ)\n        | exact(\"ADD\").map(|_| Mnemonic::ADD)\n        | exact(\"AND\").map(|_| Mnemonic::AND)\n        | exact(\"DIV\").map(|_| Mnemonic::DIV)\n        | exact(\"DVD\").map(|_| Mnemonic::DVD)\n        | exact(\"JAT\").map(|_| Mnemonic::JAT)\n        | exact(\"JEZ\").map(|_| Mnemonic::JEZ)\n        | exact(\"JGZ\").map(|_| Mnemonic::JGZ)\n        | exact(\"JLZ\").map(|_| Mnemonic::JLZ)\n        | exact(\"JNZ\").map(|_| Mnemonic::JNZ)\n        | exact(\"JZD\").map(|_| Mnemonic::JZD)\n        | exact(\"JZI\").map(|_| Mnemonic::JZI)\n        | exact(\"NIL\").map(|_| Mnemonic::NIL)\n        | exact(\"ORX\").map(|_| Mnemonic::ORX)\n        | exact(\"PIN\").map(|_| Mnemonic::PIN)\n        | exact(\"PUT\").map(|_| Mnemonic::PUT)\n        | exact(\"ROT\").map(|_| Mnemonic::ROT)\n        | exact(\"SHL\").map(|_| Mnemonic::SHL)\n        | exact(\"OR\").map(|_| Mnemonic::OR)\n        | exact(\"SQRT\").map(|_| Mnemonic::SQRT)\n        | exact(\"LN\").map(|_| Mnemonic::LN)\n        | exact(\"EXP\").map(|_| Mnemonic::EXP)\n        | exact(\"READ\").map(|_| Mnemonic::READ)\n        | exact(\"PRINT\").map(|_| Mnemonic::PRINT)\n        | exact(\"SIN\").map(|_| Mnemonic::SIN)\n        | exact(\"COS\").map(|_| Mnemonic::COS)\n        | exact(\"TAN\").map(|_| Mnemonic::TAN)\n        | exact(\"ATN\").map(|_| Mnemonic::ATN)\n        | exact(\"STOP\").map(|_| Mnemonic::STOP)\n        | exact(\"LINE\").map(|_| Mnemonic::LINE)\n        | exact(\"INT\").map(|_| Mnemonic::INT)\n        | exact(\"FRAC\").map(|_| Mnemonic::FRAC)\n        | exact(\"FLOAT\").map(|_| Mnemonic::FLOAT)\n        | exact(\"CAPTN\").map(|_| Mnemonic::CAPTN)\n        | exact(\"PAGE\").map(|_| Mnemonic::PAGE)\n        | exact(\"RND\").map(|_| Mnemonic::RND)\n        | exact(\"ABS\").map(|_| Mnemonic::ABS))\n    .name(\"mnemonic\")\n}\n\n// Utility parsers\nfn exact(tag: \u0026str) -\u003e Parser\u003c'_, String\u003e {\n    let assert_tag = move |s| {\n        (s == tag)\n            .then_some(tag.into())\n            .ok_or(Err::\u003cString, _\u003e(\"not tag\"))\n    };\n    any()\n        .repeat(tag.len())\n        .map(String::from_iter)\n        .convert(assert_tag)\n        .name(\"exact\")\n}\n","traces":[{"line":18,"address":[1328720],"length":1,"stats":{"Line":1}},{"line":19,"address":[1328721],"length":1,"stats":{"Line":1}},{"line":27,"address":[1329871,1328736,1329899],"length":1,"stats":{"Line":1}},{"line":28,"address":[1328743],"length":1,"stats":{"Line":5}},{"line":30,"address":[1329624,1329835,1329776,1329931,1328791],"length":1,"stats":{"Line":8}},{"line":31,"address":[1329691,1329556,1329916],"length":1,"stats":{"Line":4}},{"line":32,"address":[1329827,1329892,1329707],"length":1,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[1330132,1329984,1330154],"length":1,"stats":{"Line":1}},{"line":39,"address":[1330147,1329988],"length":1,"stats":{"Line":1}},{"line":43,"address":[1330176,1330572,1330597],"length":1,"stats":{"Line":1}},{"line":44,"address":[1701712,1701729],"length":1,"stats":{"Line":5}},{"line":49,"address":[1331240,1331268,1330624],"length":1,"stats":{"Line":1}},{"line":50,"address":[1330802,1330631,1330980,1331158,1331215],"length":1,"stats":{"Line":11}},{"line":51,"address":[1331300,1330695,1330869],"length":1,"stats":{"Line":2}},{"line":52,"address":[1331285,1330885,1331047],"length":1,"stats":{"Line":6}},{"line":53,"address":[1331063,1331261,1331207],"length":1,"stats":{"Line":2}},{"line":58,"address":[1331524,1331312,1331502],"length":1,"stats":{"Line":3}},{"line":59,"address":[1331316],"length":1,"stats":{"Line":2}},{"line":60,"address":[1701785,1701948],"length":1,"stats":{"Line":4}},{"line":61,"address":[1701819,1701894],"length":1,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[1701990,1702032,1702070,1701848,1702195,1702015,1702426],"length":1,"stats":{"Line":6}},{"line":65,"address":[1331517,1331321],"length":1,"stats":{"Line":7}},{"line":72,"address":[1332321,1332293,1331536],"length":1,"stats":{"Line":1}},{"line":73,"address":[1332314,1332338,1331543],"length":1,"stats":{"Line":1}},{"line":74,"address":[1702544,1702512],"length":1,"stats":{"Line":4}},{"line":81,"address":[1332384,1332901,1332926],"length":1,"stats":{"Line":3}},{"line":82,"address":[1332391,1332919,1332940],"length":1,"stats":{"Line":1}},{"line":83,"address":[1702624,1702643],"length":1,"stats":{"Line":4}},{"line":87,"address":[1332976,1333146,1333124],"length":1,"stats":{"Line":3}},{"line":88,"address":[1333139,1332980],"length":1,"stats":{"Line":1}},{"line":92,"address":[1333316,1333338,1333168],"length":1,"stats":{"Line":1}},{"line":93,"address":[1333172,1333331],"length":1,"stats":{"Line":3}},{"line":97,"address":[1333503,1333360,1333525],"length":1,"stats":{"Line":1}},{"line":98,"address":[1333518,1333364],"length":1,"stats":{"Line":1}},{"line":102,"address":[1333536],"length":1,"stats":{"Line":1}},{"line":103,"address":[1333537],"length":1,"stats":{"Line":1}},{"line":108,"address":[1333552],"length":1,"stats":{"Line":1}},{"line":109,"address":[1333553],"length":1,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[1334030,1334055,1333632],"length":1,"stats":{"Line":1}},{"line":117,"address":[1333954,1334005,1333784,1333639],"length":1,"stats":{"Line":10}},{"line":118,"address":[1333689,1334069,1333839],"length":1,"stats":{"Line":4}},{"line":119,"address":[1333997,1333855,1334048],"length":1,"stats":{"Line":4}},{"line":123,"address":[1334295,1334080,1334273],"length":1,"stats":{"Line":1}},{"line":124,"address":[1334288,1334084],"length":1,"stats":{"Line":3}},{"line":125,"address":[1702832,1702852],"length":1,"stats":{"Line":4}},{"line":131,"address":[1334304,1334972,1334999],"length":1,"stats":{"Line":3}},{"line":132,"address":[1334889,1334311],"length":1,"stats":{"Line":2}},{"line":133,"address":[1334850,1334791,1334375,1334613,1334455],"length":1,"stats":{"Line":13}},{"line":134,"address":[1334989,1334680,1334518],"length":1,"stats":{"Line":4}},{"line":135,"address":[1334696,1334842,1334962],"length":1,"stats":{"Line":2}},{"line":136,"address":[1335020,1334398,1334938],"length":1,"stats":{"Line":3}},{"line":139,"address":[1335040,1335392],"length":1,"stats":{"Line":1}},{"line":140,"address":[1335047,1335307,1335352],"length":1,"stats":{"Line":9}},{"line":141,"address":[1335347,1335416,1335382,1335088],"length":1,"stats":{"Line":2}},{"line":146,"address":[1335614,1335424,1335636],"length":1,"stats":{"Line":1}},{"line":147,"address":[1335629,1335428],"length":1,"stats":{"Line":3}},{"line":153,"address":[1335847,1335869,1335648],"length":1,"stats":{"Line":1}},{"line":154,"address":[1335652],"length":1,"stats":{"Line":7}},{"line":155,"address":[1703002],"length":1,"stats":{"Line":1}},{"line":156,"address":[1703040],"length":1,"stats":{"Line":3}},{"line":157,"address":[1703083],"length":1,"stats":{"Line":1}},{"line":160,"address":[1335657,1335862],"length":1,"stats":{"Line":1}},{"line":161,"address":[1703221,1703184],"length":1,"stats":{"Line":2}},{"line":167,"address":[1336162,1335888,1336184],"length":1,"stats":{"Line":3}},{"line":168,"address":[1336198,1336177,1335892],"length":1,"stats":{"Line":1}},{"line":173,"address":[1336208],"length":1,"stats":{"Line":1}},{"line":174,"address":[1336209],"length":1,"stats":{"Line":1}},{"line":178,"address":[1336951,1336256,1336979],"length":1,"stats":{"Line":3}},{"line":179,"address":[1336996,1336263,1336972],"length":1,"stats":{"Line":1}},{"line":184,"address":[1337040],"length":1,"stats":{"Line":3}},{"line":185,"address":[1337041],"length":1,"stats":{"Line":1}},{"line":188,"address":[1337258,1337088,1337236],"length":1,"stats":{"Line":1}},{"line":189,"address":[1337251,1337092],"length":1,"stats":{"Line":1}},{"line":192,"address":[1337280],"length":1,"stats":{"Line":3}},{"line":193,"address":[1337281],"length":1,"stats":{"Line":1}},{"line":197,"address":[1337312],"length":1,"stats":{"Line":1}},{"line":198,"address":[1337313],"length":1,"stats":{"Line":3}},{"line":199,"address":[1703392,1703405],"length":1,"stats":{"Line":4}},{"line":204,"address":[1337360,1337536,1337558],"length":1,"stats":{"Line":1}},{"line":205,"address":[1337492,1337440,1337364],"length":1,"stats":{"Line":9}},{"line":206,"address":[1337389,1337487,1337551],"length":1,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[1703408,1703440],"length":1,"stats":{"Line":2}},{"line":212,"address":[1337568,1337871,1337893],"length":1,"stats":{"Line":1}},{"line":213,"address":[1337886,1337907,1337572],"length":1,"stats":{"Line":5}},{"line":218,"address":[1338494,1337920],"length":1,"stats":{"Line":1}},{"line":219,"address":[1703584,1703595],"length":1,"stats":{"Line":5}},{"line":221,"address":[1337951,1338484,1338524],"length":1,"stats":{"Line":1}},{"line":227,"address":[1338560,1339340],"length":1,"stats":{"Line":3}},{"line":228,"address":[1338567],"length":1,"stats":{"Line":1}},{"line":229,"address":[1704708,1704288,1704451,1704593,1704313],"length":1,"stats":{"Line":0}},{"line":231,"address":[1339238,1338599,1338912,1339297],"length":1,"stats":{"Line":12}},{"line":232,"address":[1339385,1338639,1338979],"length":1,"stats":{"Line":4}},{"line":233,"address":[1338995,1339289,1339330,1339370],"length":1,"stats":{"Line":6}},{"line":239,"address":[1340261,1339424],"length":1,"stats":{"Line":1}},{"line":240,"address":[1705024,1705277,1705409,1705065],"length":1,"stats":{"Line":11}},{"line":241,"address":[1705552,1705424,1705649],"length":1,"stats":{"Line":0}},{"line":243,"address":[1340159,1340218,1340306,1339463],"length":1,"stats":{"Line":3}},{"line":244,"address":[1339877,1340291,1340251,1340210],"length":1,"stats":{"Line":6}},{"line":250,"address":[1341493,1341538,1340336],"length":1,"stats":{"Line":1}},{"line":251,"address":[1340343],"length":1,"stats":{"Line":3}},{"line":252,"address":[1706153,1706296,1706128,1706539,1706666],"length":1,"stats":{"Line":0}},{"line":254,"address":[1341391,1341450,1340391,1341574],"length":1,"stats":{"Line":3}},{"line":255,"address":[1341442,1341559,1341510,1340786,1341483],"length":1,"stats":{"Line":6}},{"line":260,"address":[1341805,1341827,1341600],"length":1,"stats":{"Line":3}},{"line":261,"address":[1341604,1341820],"length":1,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[1341840,1342414],"length":1,"stats":{"Line":3}},{"line":269,"address":[1706720,1706738],"length":1,"stats":{"Line":3}},{"line":271,"address":[1342444,1342404,1341871],"length":1,"stats":{"Line":3}},{"line":276,"address":[1342480],"length":1,"stats":{"Line":1}},{"line":277,"address":[1342481],"length":1,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[1706816,1706784],"length":1,"stats":{"Line":4}},{"line":287,"address":[1342560,1342895,1342917],"length":1,"stats":{"Line":1}},{"line":288,"address":[1342931,1342567,1342910],"length":1,"stats":{"Line":7}},{"line":292,"address":[1342944],"length":1,"stats":{"Line":1}},{"line":293,"address":[1342945],"length":1,"stats":{"Line":1}},{"line":294,"address":[1706976,1706989],"length":1,"stats":{"Line":4}},{"line":298,"address":[1362644,1362672,1342992],"length":1,"stats":{"Line":1}},{"line":299,"address":[1707012,1706992],"length":1,"stats":{"Line":127}},{"line":300,"address":[1707040,1707060],"length":1,"stats":{"Line":4}},{"line":301,"address":[1344185,1364129,1343975],"length":1,"stats":{"Line":4}},{"line":302,"address":[1707156,1707136],"length":1,"stats":{"Line":4}},{"line":303,"address":[1344637,1364093,1344427],"length":1,"stats":{"Line":4}},{"line":304,"address":[1707232,1707252],"length":1,"stats":{"Line":4}},{"line":305,"address":[1364057,1345089,1344879],"length":1,"stats":{"Line":4}},{"line":306,"address":[1364039,1345315,1345105],"length":1,"stats":{"Line":4}},{"line":307,"address":[1707376,1707396],"length":1,"stats":{"Line":4}},{"line":308,"address":[1707424,1707444],"length":1,"stats":{"Line":4}},{"line":309,"address":[1345993,1363985,1345783],"length":1,"stats":{"Line":4}},{"line":310,"address":[1363967,1346009,1346219],"length":1,"stats":{"Line":4}},{"line":311,"address":[1346445,1363949,1346235],"length":1,"stats":{"Line":4}},{"line":312,"address":[1707616,1707636],"length":1,"stats":{"Line":4}},{"line":313,"address":[1346897,1346687,1363913],"length":1,"stats":{"Line":4}},{"line":314,"address":[1346913,1347123,1363895],"length":1,"stats":{"Line":4}},{"line":315,"address":[1707760,1707780],"length":1,"stats":{"Line":4}},{"line":316,"address":[1347575,1347365,1363859],"length":1,"stats":{"Line":4}},{"line":317,"address":[1707856,1707876],"length":1,"stats":{"Line":6}},{"line":318,"address":[1707904,1707924],"length":1,"stats":{"Line":4}},{"line":319,"address":[1348253,1348043,1363805],"length":1,"stats":{"Line":4}},{"line":320,"address":[1348269,1348479,1363787],"length":1,"stats":{"Line":5}},{"line":321,"address":[1708048,1708068],"length":1,"stats":{"Line":4}},{"line":322,"address":[1708116,1708096],"length":1,"stats":{"Line":6}},{"line":323,"address":[1708144,1708164],"length":1,"stats":{"Line":4}},{"line":324,"address":[1349173,1349383,1363715],"length":1,"stats":{"Line":6}},{"line":325,"address":[1349399,1349609,1363697],"length":1,"stats":{"Line":4}},{"line":326,"address":[1363679,1349835,1349625],"length":1,"stats":{"Line":6}},{"line":327,"address":[1363661,1349851,1350061],"length":1,"stats":{"Line":4}},{"line":328,"address":[1350287,1363643,1350077],"length":1,"stats":{"Line":6}},{"line":329,"address":[1708452,1708432],"length":1,"stats":{"Line":4}},{"line":330,"address":[1350529,1350739,1363607],"length":1,"stats":{"Line":6}},{"line":331,"address":[1363589,1350755,1350965],"length":1,"stats":{"Line":4}},{"line":332,"address":[1708596,1708576],"length":1,"stats":{"Line":6}},{"line":333,"address":[1351207,1351417,1363553],"length":1,"stats":{"Line":4}},{"line":334,"address":[1363535,1351643,1351433],"length":1,"stats":{"Line":6}},{"line":335,"address":[1351659,1363517,1351869],"length":1,"stats":{"Line":4}},{"line":336,"address":[1708768,1708788],"length":1,"stats":{"Line":6}},{"line":337,"address":[1363481,1352111,1352321],"length":1,"stats":{"Line":4}},{"line":338,"address":[1708864,1708884],"length":1,"stats":{"Line":6}},{"line":339,"address":[1352773,1363445,1352563],"length":1,"stats":{"Line":4}},{"line":340,"address":[1352999,1352789,1363427],"length":1,"stats":{"Line":7}},{"line":341,"address":[1353225,1363409,1353015],"length":1,"stats":{"Line":4}},{"line":342,"address":[1709076,1709056],"length":1,"stats":{"Line":6}},{"line":343,"address":[1353677,1363373,1353467],"length":1,"stats":{"Line":4}},{"line":344,"address":[1363355,1353903,1353693],"length":1,"stats":{"Line":6}},{"line":345,"address":[1353919,1354129,1363337],"length":1,"stats":{"Line":4}},{"line":346,"address":[1354355,1354145,1363319],"length":1,"stats":{"Line":6}},{"line":347,"address":[1709296,1709316],"length":1,"stats":{"Line":4}},{"line":348,"address":[1709344,1709364],"length":1,"stats":{"Line":6}},{"line":349,"address":[1355033,1363265,1354823],"length":1,"stats":{"Line":4}},{"line":350,"address":[1355049,1355259,1363247],"length":1,"stats":{"Line":6}},{"line":351,"address":[1355485,1363229,1355275],"length":1,"stats":{"Line":4}},{"line":352,"address":[1709536,1709556],"length":1,"stats":{"Line":6}},{"line":353,"address":[1709604,1709584],"length":1,"stats":{"Line":4}},{"line":354,"address":[1363175,1355953,1356163],"length":1,"stats":{"Line":6}},{"line":355,"address":[1356389,1363157,1356179],"length":1,"stats":{"Line":4}},{"line":356,"address":[1709728,1709748],"length":1,"stats":{"Line":6}},{"line":357,"address":[1709796,1709776],"length":1,"stats":{"Line":4}},{"line":358,"address":[1709824,1709844],"length":1,"stats":{"Line":6}},{"line":359,"address":[1357293,1357083,1363085],"length":1,"stats":{"Line":4}},{"line":360,"address":[1357309,1363067,1357519],"length":1,"stats":{"Line":6}},{"line":361,"address":[1357745,1363049,1357535],"length":1,"stats":{"Line":4}},{"line":362,"address":[1357971,1363031,1357761],"length":1,"stats":{"Line":6}},{"line":363,"address":[1710064,1710084],"length":1,"stats":{"Line":4}},{"line":364,"address":[1710112,1710132],"length":1,"stats":{"Line":6}},{"line":365,"address":[1358649,1358439,1362977],"length":1,"stats":{"Line":4}},{"line":366,"address":[1358665,1358875,1362959],"length":1,"stats":{"Line":6}},{"line":367,"address":[1359101,1362941,1358891],"length":1,"stats":{"Line":4}},{"line":368,"address":[1359117,1362923,1359327],"length":1,"stats":{"Line":6}},{"line":369,"address":[1359553,1359343,1362905],"length":1,"stats":{"Line":4}},{"line":370,"address":[1359779,1362887,1359569],"length":1,"stats":{"Line":6}},{"line":371,"address":[1362869,1359795,1360005],"length":1,"stats":{"Line":4}},{"line":372,"address":[1710496,1710516],"length":1,"stats":{"Line":6}},{"line":373,"address":[1362833,1360247,1360457],"length":1,"stats":{"Line":4}},{"line":374,"address":[1360683,1360473,1362815],"length":1,"stats":{"Line":6}},{"line":375,"address":[1360699,1362797,1360909],"length":1,"stats":{"Line":4}},{"line":376,"address":[1710708,1710688],"length":1,"stats":{"Line":8}},{"line":377,"address":[1710736,1710756],"length":1,"stats":{"Line":4}},{"line":378,"address":[1361377,1361587,1362749],"length":1,"stats":{"Line":8}},{"line":379,"address":[1362734,1361813,1361603],"length":1,"stats":{"Line":4}},{"line":380,"address":[1362719,1362039,1361829],"length":1,"stats":{"Line":8}},{"line":381,"address":[1710928,1710948],"length":1,"stats":{"Line":4}},{"line":382,"address":[1362689,1362263,1362437],"length":1,"stats":{"Line":8}},{"line":383,"address":[1711024,1711044],"length":1,"stats":{"Line":4}},{"line":388,"address":[1364380,1364402,1364160],"length":1,"stats":{"Line":1}},{"line":389,"address":[1364184],"length":1,"stats":{"Line":2}},{"line":390,"address":[1711198,1711111,1711272],"length":1,"stats":{"Line":3}},{"line":391,"address":[1711164],"length":1,"stats":{"Line":1}},{"line":392,"address":[1711226],"length":1,"stats":{"Line":1}},{"line":394,"address":[1364279,1364199,1364326],"length":1,"stats":{"Line":3}},{"line":395,"address":[1364395,1364233,1364321],"length":1,"stats":{"Line":2}}],"covered":206,"coverable":218},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","memory","convert","mod.rs"],"content":"use super::instruction::*;\nuse super::result::{Error, Result};\nuse super::word::{bits, Word, WordType};\n\nuse crate::bbcx::ast::{ConstOperand, StoreOperand};\n\nuse num_enum::TryFromPrimitive;\n\npub fn word_to_instruction(word: \u0026Word) -\u003e Result\u003cInstruction\u003e {\n    let function = Function::try_from_primitive(word.pword_function_bits() as u32)\n        .map_err(|err| Error::CannotConvertFromWord(err.to_string()))?;\n    let instruction = Builder::new(function)\n        .with_accumulator(word.pword_accumulator_bits() as usize)\n        .with_index_register(word.pword_index_register_bits() as usize)\n        .with_indirect(word.pword_indirect_bits() != 0)\n        .with_page(word.pword_page_bits() as usize)\n        .with_address(word.pword_address_bits() as usize)\n        .build();\n    Ok(instruction)\n}\n\npub fn instruction_to_word(instruction: \u0026Instruction) -\u003e Result\u003cWord\u003e {\n    let function: u32 = instruction.function().into();\n    let acc = instruction.accumulator().as_bits();\n    let index_register = instruction.index_register().as_bits();\n    let indirect = instruction.indirect().as_bits();\n    let page = instruction.page().as_bits();\n    let address = instruction.address().as_bits();\n\n    let raw = bits::set(function, Word::PWORD_FUNCTION_MASK)\n        | bits::set(acc, Word::PWORD_ACCUMULATOR_MASK)\n        | bits::set(index_register, Word::PWORD_INDEX_REGISTER_MASK)\n        | bits::set(indirect, Word::PWORD_INDIRECT_MASK)\n        | bits::set(page, Word::PWORD_PAGE_MASK)\n        | bits::set(address, Word::PWORD_ADDRESS_MASK);\n\n    Ok(Word::new(WordType::PWord, raw))\n}\n\npub fn store_operand_to_word(operand: \u0026StoreOperand) -\u003e Result\u003cWord\u003e {\n    match operand {\n        StoreOperand::ConstOperand(operand) =\u003e match operand {\n            ConstOperand::SignedIWord(i) =\u003e (*i).try_into(),\n            ConstOperand::SignedFWord(f) =\u003e {\n                println!(\"store_operand_to_word\");\n                (*f).try_into()\n            }\n            ConstOperand::SWord(s) =\u003e s.as_str().try_into(),\n        },\n        _ =\u003e Err(Error::CannotCreateWordFromStoreOperand(operand.to_string())),\n    }\n}\n","traces":[{"line":9,"address":[1367952],"length":1,"stats":{"Line":1}},{"line":10,"address":[1367990,1368351],"length":1,"stats":{"Line":3}},{"line":11,"address":[1066064,1066081],"length":1,"stats":{"Line":0}},{"line":12,"address":[1368067,1368093,1368127,1368165,1368205,1368239],"length":1,"stats":{"Line":12}},{"line":13,"address":[1368085],"length":1,"stats":{"Line":1}},{"line":14,"address":[1368119],"length":1,"stats":{"Line":3}},{"line":15,"address":[1368153],"length":1,"stats":{"Line":1}},{"line":16,"address":[1368197],"length":1,"stats":{"Line":3}},{"line":17,"address":[1368231],"length":1,"stats":{"Line":1}},{"line":19,"address":[1368286],"length":1,"stats":{"Line":3}},{"line":22,"address":[1368384],"length":1,"stats":{"Line":1}},{"line":23,"address":[1368422],"length":1,"stats":{"Line":3}},{"line":24,"address":[1368457],"length":1,"stats":{"Line":1}},{"line":25,"address":[1368493],"length":1,"stats":{"Line":3}},{"line":26,"address":[1368529],"length":1,"stats":{"Line":1}},{"line":27,"address":[1368572],"length":1,"stats":{"Line":3}},{"line":28,"address":[1368614],"length":1,"stats":{"Line":1}},{"line":30,"address":[1368809,1368655,1368756,1368696,1368726,1368786],"length":1,"stats":{"Line":18}},{"line":31,"address":[1368674],"length":1,"stats":{"Line":1}},{"line":32,"address":[1368704],"length":1,"stats":{"Line":1}},{"line":33,"address":[1368734],"length":1,"stats":{"Line":1}},{"line":34,"address":[1368764],"length":1,"stats":{"Line":1}},{"line":35,"address":[1368794],"length":1,"stats":{"Line":1}},{"line":37,"address":[1368820],"length":1,"stats":{"Line":1}},{"line":40,"address":[1368880],"length":1,"stats":{"Line":3}},{"line":41,"address":[1368910],"length":1,"stats":{"Line":3}},{"line":42,"address":[1369136,1368941],"length":1,"stats":{"Line":3}},{"line":43,"address":[1369147],"length":1,"stats":{"Line":3}},{"line":44,"address":[1369177],"length":1,"stats":{"Line":2}},{"line":45,"address":[1369189],"length":1,"stats":{"Line":2}},{"line":46,"address":[1369227],"length":1,"stats":{"Line":2}},{"line":48,"address":[1369243],"length":1,"stats":{"Line":1}},{"line":50,"address":[1369036],"length":1,"stats":{"Line":0}}],"covered":31,"coverable":33},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","memory","instruction.rs"],"content":"use std::ops::AddAssign;\n\nuse super::result::{Error, Result};\n\npub type Function = crate::bbcx::ast::Mnemonic;\n\npub trait AsBits {\n    fn as_bits(\u0026self) -\u003e u32;\n}\n\npub trait MemoryRef {\n    type Target: TryFrom\u003cusize\u003e;\n\n    fn index(\u0026self) -\u003e usize;\n}\n\n#[derive(Clone, Copy, Debug, Default, PartialEq)]\npub struct Accumulator(usize);\n\nimpl AsBits for Accumulator {\n    fn as_bits(\u0026self) -\u003e u32 {\n        self.0 as u32\n    }\n}\n\nimpl MemoryRef for Accumulator {\n    type Target = Accumulator;\n    fn index(\u0026self) -\u003e usize {\n        self.0\n    }\n}\n\nimpl TryFrom\u003cusize\u003e for Accumulator {\n    type Error = Error;\n\n    fn try_from(value: usize) -\u003e Result\u003cSelf\u003e {\n        (value \u003c= Instruction::ACCUMULATOR_LIMIT)\n            .then_some(Accumulator(value))\n            .ok_or(Error::InvalidAccumulator(value))\n    }\n}\n\nimpl std::ops::Add\u003cusize\u003e for Accumulator {\n    type Output = Self;\n\n    fn add(self, rhs: usize) -\u003e Self::Output {\n        (self.0 + rhs)\n            .try_into()\n            .unwrap_or_else(|err| panic!(\"{} using: {} + {}\", err, self.0, rhs))\n    }\n}\n\nimpl std::ops::Sub\u003cusize\u003e for Accumulator {\n    type Output = Self;\n\n    fn sub(self, rhs: usize) -\u003e Self::Output {\n        (self.0 - rhs)\n            .try_into()\n            .unwrap_or_else(|err| panic!(\"{} using: {} - {}\", err, self.0, rhs))\n    }\n}\n\n#[derive(Clone, Copy, Debug, Default, PartialEq)]\npub struct IndexRegister(Accumulator);\n\nimpl IndexRegister {\n    pub fn is_indexable(\u0026self) -\u003e bool {\n        self.0 .0 != 0\n    }\n}\n\nimpl AsBits for IndexRegister {\n    fn as_bits(\u0026self) -\u003e u32 {\n        self.0.as_bits()\n    }\n}\n\nimpl MemoryRef for IndexRegister {\n    type Target = IndexRegister;\n\n    fn index(\u0026self) -\u003e usize {\n        self.0.index()\n    }\n}\n\nimpl TryFrom\u003cusize\u003e for IndexRegister {\n    type Error = Error;\n\n    fn try_from(value: usize) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        value.try_into().map(IndexRegister)\n    }\n}\n\n#[derive(Clone, Copy, Debug, Default, PartialEq)]\npub struct Indirect(bool);\n\nimpl AsBits for Indirect {\n    fn as_bits(\u0026self) -\u003e u32 {\n        self.0 as u32\n    }\n}\n\nimpl From\u003cbool\u003e for Indirect {\n    fn from(value: bool) -\u003e Self {\n        Indirect(value)\n    }\n}\n\n#[derive(Clone, Copy, Debug, Default, PartialEq)]\npub struct Page(usize);\n\nimpl AsBits for Page {\n    fn as_bits(\u0026self) -\u003e u32 {\n        self.0 as u32\n    }\n}\n\nimpl TryFrom\u003cusize\u003e for Page {\n    type Error = Error;\n\n    #[allow(clippy::absurd_extreme_comparisons)]\n    fn try_from(value: usize) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        (value \u003c= Instruction::PAGE_LIMIT)\n            .then_some(Page(value))\n            .ok_or(Error::InvalidPage(value))\n    }\n}\n\n#[derive(Clone, Copy, Debug, Default, PartialEq)]\npub struct Address(usize);\n\nimpl AsBits for Address {\n    fn as_bits(\u0026self) -\u003e u32 {\n        self.0 as u32\n    }\n}\n\nimpl MemoryRef for Address {\n    type Target = Address;\n\n    fn index(\u0026self) -\u003e usize {\n        self.0\n    }\n}\n\nimpl TryFrom\u003cusize\u003e for Address {\n    type Error = Error;\n\n    fn try_from(value: usize) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        (value \u003c= Instruction::ADDRESS_LIMIT)\n            .then_some(Address(value))\n            .ok_or(Error::InvalidAddress(value))\n    }\n}\n\nimpl AddAssign\u003cisize\u003e for Address {\n    fn add_assign(\u0026mut self, rhs: isize) {\n        self.0 = (self.index() as isize + rhs) as usize\n    }\n}\n\n#[derive(Clone, Copy, Debug, Default, PartialEq)]\npub struct Instruction {\n    function: Function,\n    accumulator: Accumulator,\n    index_register: IndexRegister,\n    indirect: Indirect,\n    page: Page,\n    address: Address,\n}\n\nimpl Instruction {\n    const ACCUMULATOR_LIMIT: usize = (1 \u003c\u003c 3) - 1;\n    const ADDRESS_LIMIT: usize = (1 \u003c\u003c 10) - 1;\n    const PAGE_LIMIT: usize = 0;\n\n    pub fn new(function: Function) -\u003e Self {\n        Self {\n            function,\n            ..Default::default()\n        }\n    }\n\n    pub fn function(\u0026self) -\u003e Function {\n        self.function\n    }\n\n    pub fn accumulator(\u0026self) -\u003e Accumulator {\n        self.accumulator\n    }\n\n    pub fn index_register(\u0026self) -\u003e IndexRegister {\n        self.index_register\n    }\n\n    pub fn indirect(\u0026self) -\u003e Indirect {\n        self.indirect\n    }\n\n    pub fn is_indirect(\u0026self) -\u003e bool {\n        self.indirect.0\n    }\n\n    pub fn page(\u0026self) -\u003e Page {\n        self.page\n    }\n\n    pub fn address(\u0026self) -\u003e Address {\n        self.address\n    }\n}\n\n#[derive(Default)]\npub struct Builder {\n    instruction: Instruction,\n}\n\nimpl Builder {\n    pub fn new(function: Function) -\u003e Self {\n        let instruction = Instruction::new(function);\n        Self { instruction }\n    }\n\n    pub fn with_accumulator\u003cT\u003e(mut self, accumulator: T) -\u003e Self\n    where\n        T: TryInto\u003cAccumulator\u003e,\n        T::Error: std::fmt::Debug,\n    {\n        self.instruction.accumulator = accumulator.try_into().expect(\"valid accumulator required\");\n        self\n    }\n\n    pub fn with_index_register\u003cT\u003e(mut self, index_register: T) -\u003e Self\n    where\n        T: TryInto\u003cIndexRegister\u003e,\n        T::Error: std::fmt::Debug,\n    {\n        self.instruction.index_register = index_register\n            .try_into()\n            .expect(\"valid index register required\");\n        self\n    }\n\n    pub fn with_indirect\u003cT\u003e(mut self, indirect: T) -\u003e Self\n    where\n        T: TryInto\u003cIndirect\u003e,\n        T::Error: std::fmt::Debug,\n    {\n        self.instruction.indirect = indirect.try_into().expect(\"valid indirect register\");\n        self\n    }\n\n    pub fn with_page\u003cT\u003e(mut self, page: T) -\u003e Self\n    where\n        T: TryInto\u003cPage\u003e,\n        T::Error: std::fmt::Debug,\n    {\n        self.instruction.page = page.try_into().expect(\"valid page required\");\n        self\n    }\n\n    pub fn with_address\u003cT\u003e(mut self, address: T) -\u003e Self\n    where\n        T: TryInto\u003cAddress\u003e,\n        T::Error: std::fmt::Debug,\n    {\n        self.instruction.address = address.try_into().expect(\"valid address required\");\n        self\n    }\n\n    pub fn build(\u0026self) -\u003e Instruction {\n        self.instruction\n    }\n}\n","traces":[{"line":21,"address":[1824320],"length":1,"stats":{"Line":3}},{"line":22,"address":[1824325],"length":1,"stats":{"Line":1}},{"line":28,"address":[1824336],"length":1,"stats":{"Line":3}},{"line":29,"address":[1824341],"length":1,"stats":{"Line":3}},{"line":36,"address":[1824352],"length":1,"stats":{"Line":1}},{"line":37,"address":[1824376,1824421],"length":1,"stats":{"Line":6}},{"line":39,"address":[1824407],"length":1,"stats":{"Line":1}},{"line":46,"address":[1824448],"length":1,"stats":{"Line":0}},{"line":47,"address":[1824462,1824527],"length":1,"stats":{"Line":0}},{"line":49,"address":[1373264,1373502,1373593,1373379],"length":1,"stats":{"Line":0}},{"line":56,"address":[1824544],"length":1,"stats":{"Line":1}},{"line":57,"address":[1824629,1824558],"length":1,"stats":{"Line":1}},{"line":59,"address":[1373827,1374041,1373712,1373950],"length":1,"stats":{"Line":0}},{"line":67,"address":[1824656],"length":1,"stats":{"Line":1}},{"line":68,"address":[1824661],"length":1,"stats":{"Line":3}},{"line":73,"address":[1824672],"length":1,"stats":{"Line":1}},{"line":74,"address":[1824677],"length":1,"stats":{"Line":3}},{"line":81,"address":[1824688],"length":1,"stats":{"Line":0}},{"line":82,"address":[1824693],"length":1,"stats":{"Line":0}},{"line":89,"address":[1824704],"length":1,"stats":{"Line":1}},{"line":90,"address":[1824722],"length":1,"stats":{"Line":3}},{"line":98,"address":[1824768],"length":1,"stats":{"Line":3}},{"line":99,"address":[1824773],"length":1,"stats":{"Line":1}},{"line":104,"address":[1824784],"length":1,"stats":{"Line":1}},{"line":113,"address":[1824800],"length":1,"stats":{"Line":1}},{"line":114,"address":[1824805],"length":1,"stats":{"Line":3}},{"line":122,"address":[1824816],"length":1,"stats":{"Line":3}},{"line":123,"address":[1824840,1824885],"length":1,"stats":{"Line":2}},{"line":125,"address":[1824871],"length":1,"stats":{"Line":3}},{"line":133,"address":[1824912],"length":1,"stats":{"Line":3}},{"line":134,"address":[1824917],"length":1,"stats":{"Line":1}},{"line":141,"address":[1824928],"length":1,"stats":{"Line":3}},{"line":142,"address":[1824933],"length":1,"stats":{"Line":1}},{"line":149,"address":[1824944],"length":1,"stats":{"Line":1}},{"line":150,"address":[1824968,1825016],"length":1,"stats":{"Line":6}},{"line":152,"address":[1825002],"length":1,"stats":{"Line":1}},{"line":157,"address":[1825040],"length":1,"stats":{"Line":0}},{"line":158,"address":[1825103,1825063],"length":1,"stats":{"Line":0}},{"line":177,"address":[1825120],"length":1,"stats":{"Line":3}},{"line":184,"address":[1825232],"length":1,"stats":{"Line":1}},{"line":185,"address":[1825237],"length":1,"stats":{"Line":3}},{"line":188,"address":[1825248],"length":1,"stats":{"Line":3}},{"line":189,"address":[1825253],"length":1,"stats":{"Line":1}},{"line":192,"address":[1825264],"length":1,"stats":{"Line":1}},{"line":193,"address":[1825269],"length":1,"stats":{"Line":3}},{"line":196,"address":[1825280],"length":1,"stats":{"Line":3}},{"line":197,"address":[1825285],"length":1,"stats":{"Line":1}},{"line":200,"address":[1825296],"length":1,"stats":{"Line":3}},{"line":201,"address":[1825301],"length":1,"stats":{"Line":1}},{"line":204,"address":[1825312],"length":1,"stats":{"Line":1}},{"line":205,"address":[1825317],"length":1,"stats":{"Line":3}},{"line":208,"address":[1825328],"length":1,"stats":{"Line":3}},{"line":209,"address":[1825333],"length":1,"stats":{"Line":1}},{"line":219,"address":[1825344],"length":1,"stats":{"Line":3}},{"line":220,"address":[1825362],"length":1,"stats":{"Line":1}},{"line":224,"address":[1374160],"length":1,"stats":{"Line":1}},{"line":229,"address":[1374195],"length":1,"stats":{"Line":3}},{"line":230,"address":[1374247],"length":1,"stats":{"Line":1}},{"line":233,"address":[1374272],"length":1,"stats":{"Line":1}},{"line":238,"address":[1374307],"length":1,"stats":{"Line":3}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[1374360],"length":1,"stats":{"Line":1}},{"line":244,"address":[1374384],"length":1,"stats":{"Line":1}},{"line":249,"address":[1374414],"length":1,"stats":{"Line":3}},{"line":250,"address":[1374470],"length":1,"stats":{"Line":3}},{"line":253,"address":[1374496],"length":1,"stats":{"Line":3}},{"line":258,"address":[1374531],"length":1,"stats":{"Line":1}},{"line":259,"address":[1374584],"length":1,"stats":{"Line":3}},{"line":262,"address":[1374608],"length":1,"stats":{"Line":1}},{"line":267,"address":[1374643],"length":1,"stats":{"Line":3}},{"line":268,"address":[1374696],"length":1,"stats":{"Line":1}},{"line":271,"address":[1825408],"length":1,"stats":{"Line":3}},{"line":272,"address":[1825425],"length":1,"stats":{"Line":1}}],"covered":64,"coverable":74},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","memory","mod.rs"],"content":"mod convert;\nmod instruction;\nmod result;\nmod state;\nmod word;\n\npub use self::convert::word_to_instruction;\npub use self::instruction::{Accumulator, Address, Function, IndexRegister, Instruction};\npub use self::state::{Offset, State as Memory};\npub use self::word::{ops::*, *};\n\n#[cfg(test)]\npub use self::convert::instruction_to_word;\n\n#[cfg(test)]\npub use self::instruction::Builder as InstructionBuilder;\n\n#[cfg(test)]\npub use self::state::MEMORY_SIZE;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","memory","result.rs"],"content":"use thiserror::Error;\n\n#[derive(Clone, Debug, PartialEq, Error)]\npub enum Error {\n    #[error(\"cannot create IWord from {0}\")]\n    InvalidIWordValue(i64),\n\n    #[error(\"cannot create FWord from {0}\")]\n    InvalidFWordValue(f64),\n\n    #[error(\"cannot create SWord from {0}\")]\n    InvalidSWordValue(String),\n\n    #[error(\"invalid accumulator {0}\")]\n    InvalidAccumulator(usize),\n\n    #[error(\"invalid address {0}\")]\n    InvalidAddress(usize),\n\n    #[error(\"invalid page {0}\")]\n    InvalidPage(usize),\n\n    // TODO: Get rid of this...\n    #[error(\"cannot create Word from {0}\")]\n    CannotCreateWordFromStoreOperand(String),\n\n    #[error(\"error converting word into target value {0}\")]\n    CannotConvertFromWord(String),\n\n    #[error(\"cannot allocate memory\")]\n    OutOfMemory,\n}\n\npub(crate) type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","memory","state.rs"],"content":"use super::convert::{instruction_to_word, store_operand_to_word};\nuse super::instruction::*;\nuse super::result::{Error, Result};\nuse super::word::*;\n\nuse crate::bbcx::ast::{Location as AstLocation, SourceWord as AstSourceWord};\nuse crate::bbcx::Assembly;\n\npub type Offset = usize;\n\n#[derive(Clone, Debug, PartialEq)]\npub struct State(Vec\u003cWord\u003e);\n\nimpl State {\n    fn add_source_word(\n        mut self,\n        location: AstLocation,\n        source_word: \u0026AstSourceWord,\n        assembly: \u0026Assembly,\n    ) -\u003e Result\u003cSelf\u003e {\n        match source_word {\n            AstSourceWord::IWord(i) =\u003e {\n                self[location] = (*i).try_into()?;\n            }\n            AstSourceWord::FWord(f) =\u003e {\n                self[location] = (*f).try_into()?;\n            }\n            AstSourceWord::PWord(pword) =\u003e {\n                let operand = pword.store_operand();\n                let address = if operand.requires_storage() {\n                    let address = self.next_storage_address()?;\n                    self[address] = store_operand_to_word(\u0026operand)?;\n                    address\n                } else {\n                    assembly.address_used_by_store_operand(operand)\n                };\n\n                let instruction = Builder::new(pword.mnemonic())\n                    .with_accumulator(pword.accumulator().as_usize())\n                    .with_index_register(pword.index_register())\n                    .with_indirect(pword.indirect())\n                    .with_page(pword.page())\n                    .with_address(address)\n                    .build();\n                self[location] = instruction_to_word(\u0026instruction)?;\n            }\n            AstSourceWord::SWord(s) =\u003e self[location] = s.as_str().try_into()?,\n        };\n        Ok(self)\n    }\n\n    fn next_storage_address(\u0026self) -\u003e Result\u003cOffset\u003e {\n        self.0\n            .iter()\n            .rposition(Word::is_undefined)\n            .ok_or(Error::OutOfMemory)\n    }\n}\n\npub const MEMORY_SIZE: Offset = 128; // TODO Change to 1024\n\nimpl Default for State {\n    fn default() -\u003e Self {\n        Self(vec![Word::default(); MEMORY_SIZE])\n    }\n}\n\nimpl TryFrom\u003cAssembly\u003e for State {\n    type Error = Error;\n\n    fn try_from(value: Assembly) -\u003e Result\u003cSelf\u003e {\n        let linked_code = value.linked_code();\n        let mut keys = Vec::from_iter(linked_code.keys());\n        keys.sort();\n        keys.into_iter()\n            .try_fold(State::default(), |acc, location| {\n                let content = \u0026linked_code[location];\n                acc.add_source_word(*location, content, \u0026value)\n            })\n    }\n}\n\nimpl std::ops::Index\u003cusize\u003e for State {\n    type Output = Word;\n\n    fn index(\u0026self, index: usize) -\u003e \u0026Self::Output {\n        \u0026self.0[index]\n    }\n}\n\nimpl std::ops::IndexMut\u003cusize\u003e for State {\n    fn index_mut(\u0026mut self, index: usize) -\u003e \u0026mut Self::Output {\n        \u0026mut self.0[index]\n    }\n}\n\nimpl std::ops::Index\u003cAccumulator\u003e for State {\n    type Output = Word;\n\n    fn index(\u0026self, acc: Accumulator) -\u003e \u0026Self::Output {\n        \u0026self.0[acc.index()]\n    }\n}\n\nimpl std::ops::IndexMut\u003cAccumulator\u003e for State {\n    fn index_mut(\u0026mut self, acc: Accumulator) -\u003e \u0026mut Self::Output {\n        \u0026mut self.0[acc.index()]\n    }\n}\n\nimpl std::ops::Index\u003cIndexRegister\u003e for State {\n    type Output = Word;\n\n    fn index(\u0026self, index_register: IndexRegister) -\u003e \u0026Self::Output {\n        \u0026self.0[index_register.index()]\n    }\n}\n\nimpl std::ops::IndexMut\u003cIndexRegister\u003e for State {\n    fn index_mut(\u0026mut self, index_register: IndexRegister) -\u003e \u0026mut Self::Output {\n        \u0026mut self.0[index_register.index()]\n    }\n}\n\nimpl std::ops::Index\u003cAddress\u003e for State {\n    type Output = Word;\n\n    fn index(\u0026self, address: Address) -\u003e \u0026Self::Output {\n        \u0026self.0[address.index()]\n    }\n}\n\nimpl std::ops::IndexMut\u003cAddress\u003e for State {\n    fn index_mut(\u0026mut self, address: Address) -\u003e \u0026mut Self::Output {\n        \u0026mut self.0[address.index()]\n    }\n}\n","traces":[{"line":15,"address":[711671,710970,709216],"length":1,"stats":{"Line":3}},{"line":21,"address":[709295],"length":1,"stats":{"Line":3}},{"line":22,"address":[709449],"length":1,"stats":{"Line":3}},{"line":23,"address":[711210,711404,709464],"length":1,"stats":{"Line":6}},{"line":25,"address":[709403],"length":1,"stats":{"Line":2}},{"line":26,"address":[710995,711189,709418],"length":1,"stats":{"Line":4}},{"line":28,"address":[709369],"length":1,"stats":{"Line":3}},{"line":29,"address":[709385,709572],"length":1,"stats":{"Line":6}},{"line":30,"address":[710207,709647,709588],"length":1,"stats":{"Line":9}},{"line":31,"address":[709756,710907,709908,709820],"length":1,"stats":{"Line":6}},{"line":32,"address":[709893,709981,710905],"length":1,"stats":{"Line":6}},{"line":33,"address":[710199],"length":1,"stats":{"Line":3}},{"line":35,"address":[709771,709661],"length":1,"stats":{"Line":6}},{"line":38,"address":[710317,710365,709787,710465,710227,710496,710395],"length":1,"stats":{"Line":19}},{"line":39,"address":[710242],"length":1,"stats":{"Line":1}},{"line":40,"address":[710332],"length":1,"stats":{"Line":3}},{"line":41,"address":[710380],"length":1,"stats":{"Line":3}},{"line":42,"address":[710432],"length":1,"stats":{"Line":1}},{"line":43,"address":[710472],"length":1,"stats":{"Line":1}},{"line":45,"address":[710542,710891],"length":1,"stats":{"Line":3}},{"line":47,"address":[711666,711433,709494],"length":1,"stats":{"Line":4}},{"line":49,"address":[710808],"length":1,"stats":{"Line":3}},{"line":52,"address":[711696],"length":1,"stats":{"Line":3}},{"line":53,"address":[711781,711728],"length":1,"stats":{"Line":6}},{"line":56,"address":[711772],"length":1,"stats":{"Line":3}},{"line":63,"address":[711808],"length":1,"stats":{"Line":3}},{"line":64,"address":[711821],"length":1,"stats":{"Line":3}},{"line":71,"address":[711888,712362,712386],"length":1,"stats":{"Line":1}},{"line":72,"address":[711910],"length":1,"stats":{"Line":1}},{"line":73,"address":[711977,712028],"length":1,"stats":{"Line":2}},{"line":74,"address":[712048,712113],"length":1,"stats":{"Line":2}},{"line":75,"address":[712120,712257],"length":1,"stats":{"Line":2}},{"line":76,"address":[712185],"length":1,"stats":{"Line":4}},{"line":77,"address":[1657486,1657567],"length":1,"stats":{"Line":6}},{"line":78,"address":[1657572],"length":1,"stats":{"Line":3}},{"line":86,"address":[712400],"length":1,"stats":{"Line":1}},{"line":87,"address":[712414],"length":1,"stats":{"Line":1}},{"line":92,"address":[712432],"length":1,"stats":{"Line":3}},{"line":93,"address":[712446],"length":1,"stats":{"Line":3}},{"line":100,"address":[712464],"length":1,"stats":{"Line":1}},{"line":101,"address":[712488],"length":1,"stats":{"Line":1}},{"line":106,"address":[712528],"length":1,"stats":{"Line":3}},{"line":107,"address":[712552],"length":1,"stats":{"Line":3}},{"line":114,"address":[712592],"length":1,"stats":{"Line":0}},{"line":115,"address":[712616],"length":1,"stats":{"Line":0}},{"line":120,"address":[712656],"length":1,"stats":{"Line":0}},{"line":121,"address":[712680],"length":1,"stats":{"Line":0}},{"line":128,"address":[712720],"length":1,"stats":{"Line":3}},{"line":129,"address":[712744],"length":1,"stats":{"Line":1}},{"line":134,"address":[712784],"length":1,"stats":{"Line":1}},{"line":135,"address":[712808],"length":1,"stats":{"Line":1}}],"covered":47,"coverable":51},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","memory","word.rs"],"content":"use super::result::{Error, Result};\n\nuse crate::bbcx::charset::CharSet;\n\nuse num_enum::TryFromPrimitive;\n\n// The word's rawbits are u24, which could be held in a u32.\n// We use u64 to aide double length operations..\ntype RawBits = u64;\n\n#[derive(Clone, Copy, Debug, Default, PartialEq, TryFromPrimitive)]\n#[repr(u32)]\npub(crate) enum WordType {\n    #[default]\n    Undefined,\n    IWord,\n    FWord,\n    SWord,\n    PWord,\n}\n\n#[derive(Clone, Copy, Debug, Default, PartialEq)]\npub struct Word {\n    word_type: WordType,\n    raw_bits: RawBits,\n}\n\nimpl Word {\n    const SIZE: usize = 24;\n    const MASK: RawBits = (1 \u003c\u003c Word::SIZE) - 1;\n    const OVERFLOW_MASK: RawBits = !Word::MASK;\n    const SIZE2: usize = Word::SIZE + Word::SIZE;\n    const MASK2: RawBits = (1 \u003c\u003c Word::SIZE2) - 1;\n    const OVERFLOW_MASK2: RawBits = !Word::MASK2;\n\n    const FWORD_SIGN_MASK: RawBits = 0o4000_0000;\n    const FWORD_EXPONENT_MASK: RawBits = 0o3760_0000;\n    const FWORD_EXPONENT_BIAS: i32 = 63;\n    const FWORD_MANTISSA_MASK: RawBits = 0o0017_7777;\n\n    const F64_SIGN_MASK: RawBits = 0x8000_0000_0000_0000;\n    const F64_EXPONENT_MASK: RawBits = 0x7FF0_0000_0000_0000;\n    const F64_EXPONENT_BIAS: i32 = 1023;\n    const F64_MANTISSA_MASK: RawBits = 0x000F_FFFF_FFFF_FFFF;\n\n    const SWORD_CHAR_MASK: RawBits = 0o77;\n    const SWORD_CHAR_SIZE: usize = Self::SWORD_CHAR_MASK.trailing_ones() as usize;\n    const SWORD_MAX_CHARS: usize = Word::SIZE / Word::SWORD_CHAR_SIZE;\n\n    pub(crate) const PWORD_FUNCTION_MASK: RawBits = 0o7700_0000;\n    pub(crate) const PWORD_ACCUMULATOR_MASK: RawBits = 0o0070_0000;\n    pub(crate) const PWORD_INDEX_REGISTER_MASK: RawBits = 0o0007_0000;\n    pub(crate) const PWORD_INDIRECT_MASK: RawBits = 0o0000_4000;\n    pub(crate) const PWORD_PAGE_MASK: RawBits = 0o0000_2000;\n    pub(crate) const PWORD_ADDRESS_MASK: RawBits = 0o0000_1777;\n\n    pub(crate) fn new(word_type: WordType, raw_bits: RawBits) -\u003e Self {\n        Self {\n            word_type,\n            raw_bits,\n        }\n    }\n\n    pub fn is_undefined(\u0026self) -\u003e bool {\n        self.word_type == WordType::Undefined\n    }\n\n    pub fn is_instruction(\u0026self) -\u003e bool {\n        self.word_type == WordType::PWord\n    }\n\n    pub fn pword_function_bits(\u0026self) -\u003e RawBits {\n        assert!(self.word_type == WordType::PWord);\n        bits::get(self.raw_bits, Word::PWORD_FUNCTION_MASK) as RawBits\n    }\n\n    pub fn pword_accumulator_bits(\u0026self) -\u003e RawBits {\n        assert!(self.word_type == WordType::PWord);\n        bits::get(self.raw_bits, Word::PWORD_ACCUMULATOR_MASK) as RawBits\n    }\n\n    pub fn pword_index_register_bits(\u0026self) -\u003e RawBits {\n        assert!(self.word_type == WordType::PWord);\n        bits::get(self.raw_bits, Word::PWORD_INDEX_REGISTER_MASK) as RawBits\n    }\n\n    pub fn pword_indirect_bits(\u0026self) -\u003e RawBits {\n        assert!(self.word_type == WordType::PWord);\n        bits::get(self.raw_bits, Word::PWORD_INDIRECT_MASK) as RawBits\n    }\n\n    pub fn pword_page_bits(\u0026self) -\u003e RawBits {\n        assert!(self.word_type == WordType::PWord);\n        bits::get(self.raw_bits, Word::PWORD_PAGE_MASK) as RawBits\n    }\n\n    pub fn pword_address_bits(\u0026self) -\u003e RawBits {\n        assert!(self.word_type == WordType::PWord);\n        bits::get(self.raw_bits, Word::PWORD_ADDRESS_MASK) as RawBits\n    }\n\n    pub fn as_i64(\u0026self) -\u003e Result\u003ci64\u003e {\n        (self.word_type == WordType::IWord)\n            .then_some((self.raw_bits as i64) \u003c\u003c 40 \u003e\u003e 40)\n            .ok_or(Error::CannotConvertFromWord(format!(\"i64 from {}\", self)))\n    }\n\n    pub fn as_f64(\u0026self) -\u003e Result\u003cf64\u003e {\n        (self.word_type == WordType::FWord)\n            .then_some({\n                let raw_bits = self.raw_bits;\n\n                let zero_bits = raw_bits \u0026 (Word::FWORD_EXPONENT_MASK | Word::FWORD_MANTISSA_MASK);\n\n                if zero_bits != 0 {\n                    let sign = bits::get(raw_bits, Word::FWORD_SIGN_MASK);\n                    let exponent = bits::get(raw_bits, Word::FWORD_EXPONENT_MASK) as i32\n                        - Word::FWORD_EXPONENT_BIAS;\n                    let mantissa = bits::get(raw_bits, Word::FWORD_MANTISSA_MASK);\n\n                    let f64_exponent = exponent + Word::F64_EXPONENT_BIAS;\n                    let f64_mantissa = mantissa\n                        \u003c\u003c (Word::F64_MANTISSA_MASK.trailing_ones()\n                            - Word::FWORD_MANTISSA_MASK.trailing_ones());\n\n                    let bits = bits::set(sign, Word::F64_SIGN_MASK)\n                        | bits::set(f64_exponent as u64, Word::F64_EXPONENT_MASK)\n                        | bits::set(f64_mantissa, Word::F64_MANTISSA_MASK);\n\n                    f64::from_bits(bits)\n                } else {\n                    0.0\n                }\n            })\n            .ok_or(Error::CannotConvertFromWord(format!(\"f64 from {}\", self)))\n    }\n\n    pub fn as_char(\u0026self) -\u003e Result\u003cu8\u003e {\n        match self.word_type {\n            WordType::IWord | WordType::SWord =\u003e {\n                let bits = bits::get(self.raw_bits, Word::SWORD_CHAR_MASK);\n                let char = CharSet::bits_to_char(bits)\n                    .unwrap_or_else(|| panic!(\"Invalid character {}\", bits));\n                Ok(char)\n            }\n            _ =\u003e Err(Error::CannotConvertFromWord(format!(\"u8 from {}\", self))),\n        }\n    }\n\n    pub fn word_type(\u0026self) -\u003e Word {\n        Word::new(\n            WordType::IWord,\n            match self.word_type {\n                WordType::IWord =\u003e 0,\n                WordType::FWord =\u003e 1,\n                WordType::SWord =\u003e 2,\n                WordType::PWord =\u003e 3,\n                _ =\u003e panic!(\"Word type: Undefined\"),\n            },\n        )\n    }\n\n    pub fn set_word_type(\u0026mut self, operand: \u0026Word) {\n        let u32_word_type = ((operand.raw_bits \u0026 0b11) + 1) as u32;\n        self.word_type = WordType::try_from_primitive(u32_word_type).unwrap();\n    }\n\n    pub fn word_bits(\u0026self) -\u003e Word {\n        Word::new(WordType::IWord, self.raw_bits)\n    }\n\n    pub fn set_word_bits(\u0026mut self, operand: \u0026Word) {\n        self.raw_bits = operand.raw_bits;\n    }\n\n    pub fn rotate(\u0026mut self, n: i64) {\n        let mut n = n % (Word::SIZE as i64);\n        if n \u003c 0 {\n            n += Word::SIZE as i64\n        };\n\n        let shifted_bits = self.raw_bits \u003c\u003c n;\n        let overflow = bits::get(shifted_bits, Word::OVERFLOW_MASK);\n\n        self.raw_bits = shifted_bits \u0026 Word::MASK | overflow as RawBits;\n    }\n\n    pub fn power(\u0026mut self, other: \u0026Word) {\n        match (self.word_type, other.word_type) {\n            (WordType::IWord, WordType::IWord) =\u003e {\n                let x = self.as_i64().unwrap();\n                let n = other.as_i64().unwrap();\n                let result = x.pow(n as u32);\n                *self = result.try_into().unwrap();\n            }\n            (WordType::IWord, WordType::FWord) =\u003e {\n                let x = self.as_i64().unwrap();\n                let n = other.as_f64().unwrap();\n                let result = (x as f64).powf(n);\n                *self = if n == 0.0 {\n                    (result as i64).try_into().unwrap()\n                } else {\n                    result.try_into().unwrap()\n                };\n            }\n            (WordType::FWord, WordType::IWord) =\u003e {\n                let x = self.as_f64().unwrap();\n                let n = other.as_i64().unwrap();\n                let result = x.powi(n as i32);\n                *self = if n == 0 {\n                    (result as i64).try_into().unwrap()\n                } else {\n                    result.try_into().unwrap()\n                };\n            }\n            (WordType::FWord, WordType::FWord) =\u003e {\n                let x = self.as_f64().unwrap();\n                let n = other.as_f64().unwrap();\n                let result = x.powf(n);\n                *self = if n == 0.0 {\n                    (result as i64).try_into().unwrap()\n                } else {\n                    result.try_into().unwrap()\n                };\n            }\n            (lhs, rhs) =\u003e panic!(\"Operation not supported between {:?} and {:?}\", lhs, rhs),\n        };\n    }\n}\n\nimpl std::fmt::Display for Word {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?} {:#010o}\", self.word_type, self.raw_bits)\n    }\n}\n\nimpl TryFrom\u003ci64\u003e for Word {\n    type Error = Error;\n\n    fn try_from(value: i64) -\u003e Result\u003cSelf\u003e {\n        let raw_value = value \u0026 Word::MASK as i64;\n        let word = Word::new(WordType::IWord, raw_value as RawBits);\n        (word.as_i64().unwrap() == value)\n            .then_some(word)\n            .ok_or(Error::InvalidIWordValue(value))\n    }\n}\n\nimpl TryFrom\u003cf64\u003e for Word {\n    type Error = Error;\n\n    fn try_from(value: f64) -\u003e Result\u003cSelf\u003e {\n        fn can_represent_f24(value: f64) -\u003e bool {\n            let bad_initial_value = value.is_nan() || value.is_infinite();\n\n            let (_sign, exponent, _mantissa) = decompose_f64(value);\n\n            let valid_exponent =\n                (-Word::FWORD_EXPONENT_BIAS - 1..=Word::FWORD_EXPONENT_BIAS).contains(\u0026exponent);\n\n            !bad_initial_value \u0026\u0026 valid_exponent\n        }\n\n        fn decompose_f64(value: f64) -\u003e (u8, i32, u64) {\n            let bits = value.to_bits();\n\n            let sign = bits::get(bits, Word::F64_SIGN_MASK) as u8;\n            let exponent =\n                bits::get(bits, Word::F64_EXPONENT_MASK) as i32 - Word::F64_EXPONENT_BIAS;\n            let mantissa = bits::get(bits, Word::F64_MANTISSA_MASK);\n            (sign, exponent, mantissa)\n        }\n\n        fn convert_to_f24(value: f64) -\u003e Option\u003cRawBits\u003e {\n            can_represent_f24(value).then_some({\n                let (sign, exponent, mantissa) = decompose_f64(value);\n\n                let f24_exponent = exponent + Word::FWORD_EXPONENT_BIAS;\n                let f24_mantissa = mantissa\n                    \u003e\u003e (Word::F64_MANTISSA_MASK.trailing_ones()\n                        - Word::FWORD_MANTISSA_MASK.trailing_ones());\n\n                let raw_bits = bits::set(sign, Word::FWORD_SIGN_MASK)\n                    | bits::set(f24_exponent as u64, Word::FWORD_EXPONENT_MASK)\n                    | bits::set(f24_mantissa, Word::FWORD_MANTISSA_MASK);\n\n                println!(\"f24 raw_bits {:08o}\", raw_bits);\n\n                raw_bits as RawBits\n            })\n        }\n\n        if value != 0.0 {\n            convert_to_f24(value)\n                .map(|raw_bits| Word::new(WordType::FWord, raw_bits))\n                .ok_or(Error::InvalidFWordValue(value))\n        } else {\n            Ok(Word::new(WordType::FWord, 0))\n        }\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Word {\n    type Error = Error;\n\n    fn try_from(value: \u0026str) -\u003e Result\u003cSelf\u003e {\n        (value.len() \u003c= Word::SWORD_MAX_CHARS)\n            .then_some(Word::new(\n                WordType::SWord,\n                value\n                    .as_bytes()\n                    .iter()\n                    .map(|c| CharSet::char_to_bits(*c).unwrap())\n                    .fold(RawBits::default(), |raw, c| {\n                        (raw \u003c\u003c Word::SWORD_CHAR_SIZE) | c as RawBits\n                    }),\n            ))\n            .ok_or(Error::InvalidSWordValue(value.to_string()))\n    }\n}\n\npub mod ops {\n    use super::*;\n\n    impl std::ops::BitOrAssign for Word {\n        fn bitor_assign(\u0026mut self, rhs: Self) {\n            self.raw_bits |= rhs.raw_bits;\n        }\n    }\n\n    impl std::ops::BitXorAssign for Word {\n        fn bitxor_assign(\u0026mut self, rhs: Self) {\n            self.raw_bits ^= rhs.raw_bits;\n        }\n    }\n\n    impl std::ops::BitAndAssign for Word {\n        fn bitand_assign(\u0026mut self, rhs: Self) {\n            self.raw_bits \u0026= rhs.raw_bits;\n        }\n    }\n\n    macro_rules! binary_operation {\n        ($lhs:expr, $op:tt, $rhs:expr) =\u003e {\n            match ($lhs.word_type, $rhs.word_type) {\n                (WordType::IWord, WordType::IWord) =\u003e ($lhs.as_i64().unwrap() $op $rhs.as_i64().unwrap()).try_into(),\n                (WordType::IWord, WordType::FWord) =\u003e ($lhs.as_i64().unwrap() as f64 $op $rhs.as_f64().unwrap()).try_into(),\n                (WordType::FWord, WordType::IWord) =\u003e ($lhs.as_f64().unwrap() $op $rhs.as_i64().unwrap() as f64).try_into(),\n                (WordType::FWord, WordType::FWord) =\u003e ($lhs.as_f64().unwrap() $op $rhs.as_f64().unwrap()).try_into(),\n                (lhs, rhs) =\u003e panic!(\"Operation not supported between {:?} and {:?}\", lhs, rhs),\n            }.expect(\"Operation $op failed\")\n        }\n    }\n\n    impl std::ops::AddAssign for Word {\n        fn add_assign(\u0026mut self, rhs: Self) {\n            *self = binary_operation!(self, +, rhs);\n        }\n    }\n\n    impl std::ops::SubAssign for Word {\n        fn sub_assign(\u0026mut self, rhs: Self) {\n            *self = binary_operation!(self, -, rhs);\n        }\n    }\n\n    impl std::ops::MulAssign for Word {\n        fn mul_assign(\u0026mut self, rhs: Self) {\n            *self = binary_operation!(self, *, rhs);\n        }\n    }\n\n    impl std::ops::DivAssign for Word {\n        fn div_assign(\u0026mut self, rhs: Self) {\n            *self = binary_operation!(self, /, rhs);\n        }\n    }\n\n    impl std::ops::Neg for Word {\n        type Output = Word;\n\n        fn neg(self) -\u003e Self::Output {\n            match self.word_type {\n                WordType::IWord =\u003e self\n                    .as_i64()\n                    .and_then(|i| (-i).try_into())\n                    .unwrap_or_else(|err| panic!(\"NEG failed: {} using: {}\", err, self)),\n                WordType::FWord =\u003e self\n                    .as_f64()\n                    .and_then(|f| (-f).try_into())\n                    .unwrap_or_else(|err| panic!(\"NEG failed: {} using: {}\", err, self)),\n                _ =\u003e panic!(\"NEG operation not supported for {:?}\", self),\n            }\n        }\n    }\n\n    impl std::ops::Not for Word {\n        type Output = Word;\n\n        fn not(self) -\u003e Self::Output {\n            Word::new(self.word_type, (!self.raw_bits) \u0026 Word::MASK)\n        }\n    }\n\n    impl PartialOrd for Word {\n        fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\n            match (self.word_type, other.word_type) {\n                (WordType::IWord, WordType::IWord) =\u003e {\n                    self.as_i64().unwrap().partial_cmp(\u0026other.as_i64().unwrap())\n                }\n                (WordType::IWord, WordType::FWord) =\u003e {\n                    (self.as_i64().unwrap() as f64).partial_cmp(\u0026other.as_f64().unwrap())\n                }\n                (WordType::FWord, WordType::IWord) =\u003e self\n                    .as_f64()\n                    .unwrap()\n                    .partial_cmp(\u0026(other.as_i64().unwrap() as f64)),\n                (WordType::FWord, WordType::FWord) =\u003e {\n                    self.as_f64().unwrap().partial_cmp(\u0026other.as_f64().unwrap())\n                }\n                (lhs, rhs) =\u003e panic!(\"Operation not supported between {:?} and {:?}\", lhs, rhs),\n            }\n        }\n    }\n\n    impl std::ops::ShlAssign for Word {\n        fn shl_assign(\u0026mut self, rhs: Self) {\n            let n = rhs.as_i64().unwrap();\n            self.raw_bits \u003c\u003c= n;\n            self.raw_bits \u0026= Word::MASK;\n        }\n    }\n\n    fn msw_lsw_to_u64(msw: \u0026Word, lsw: \u0026Word) -\u003e u64 {\n        msw.raw_bits \u003c\u003c Word::SIZE | (lsw.raw_bits \u0026 Word::MASK)\n    }\n\n    fn u64_to_msw_lsw(value: u64) -\u003e (Word, Word) {\n        let msw = bits::get(value, Word::OVERFLOW_MASK as i64 as u64);\n        let lsw = bits::get(value, Word::MASK);\n\n        (\n            Word::new(WordType::Undefined, msw as RawBits \u0026 Word::MASK),\n            Word::new(WordType::Undefined, lsw as RawBits \u0026 Word::MASK),\n        )\n    }\n\n    fn msw_lsw_to_i64(msw: \u0026Word, lsw: \u0026Word) -\u003e i64 {\n        let signed_msw = msw.as_i64().unwrap() as u64;\n        ((signed_msw \u003c\u003c Word::SIZE) | lsw.raw_bits) as i64\n    }\n\n    fn i64_to_msw_lsw(value: i64) -\u003e (Word, Word) {\n        u64_to_msw_lsw(value as u64)\n    }\n\n    pub fn double_shift_left(msw: \u0026Word, lsw: \u0026Word, operand: \u0026Word) -\u003e Result\u003c(Word, Word)\u003e {\n        let n: i64 = operand.as_i64()?;\n        let lhs: u64 = msw_lsw_to_u64(msw, lsw);\n        let shifted_lhs = lhs \u003c\u003c n;\n        Ok(u64_to_msw_lsw(shifted_lhs))\n    }\n\n    pub fn double_rotate_left(msw: \u0026Word, lsw: \u0026Word, operand: \u0026Word) -\u003e Result\u003c(Word, Word)\u003e {\n        let mut n: i64 = operand.as_i64()? % Word::SIZE2 as i64;\n        if n \u003c 0 {\n            n += Word::SIZE2 as i64\n        };\n\n        let lhs = msw_lsw_to_u64(msw, lsw);\n\n        let shifted_bits = lhs \u003c\u003c n;\n        let overflow = bits::get(shifted_bits, Word::OVERFLOW_MASK2);\n        let raw = shifted_bits \u0026 Word::MASK2 | overflow;\n\n        Ok(u64_to_msw_lsw(raw))\n    }\n\n    pub fn double_mult(msw: \u0026Word, lsw: \u0026Word, operand: \u0026Word) -\u003e Result\u003c(Word, Word)\u003e {\n        let lhs: i64 = msw_lsw_to_i64(msw, lsw);\n        let result = lhs * operand.as_i64().unwrap();\n        Ok(i64_to_msw_lsw(result))\n    }\n\n    pub fn double_div(msw: \u0026Word, lsw: \u0026Word, operand: \u0026Word) -\u003e Result\u003c(Word, Word)\u003e {\n        let lhs: i64 = msw_lsw_to_i64(msw, lsw);\n        let result = lhs / operand.as_i64().unwrap();\n        Ok(i64_to_msw_lsw(result))\n    }\n\n    pub fn squash(msw: \u0026Word, lsw: \u0026Word) -\u003e Result\u003c(Word, Word)\u003e {\n        let sign = msw.as_i64().unwrap();\n        let lhs = lsw.as_i64().unwrap();\n\n        assert!(if lhs \u003e= 0 { sign == 0 } else { sign == -1 });\n        Ok(i64_to_msw_lsw(lhs))\n    }\n}\n\npub mod bits {\n    pub fn get\u003cV, M\u003e(value: V, mask: M) -\u003e u64\n    where\n        V: 'static + Into\u003cu64\u003e,\n        M: 'static + Into\u003cu64\u003e,\n    {\n        let value: u64 = value.into();\n        let mask: u64 = mask.into();\n        let shift = mask.trailing_zeros();\n        (value \u0026 mask) \u003e\u003e shift\n    }\n\n    pub fn set\u003cV, M\u003e(value: V, mask: M) -\u003e u64\n    where\n        V: 'static + Into\u003cu64\u003e,\n        M: 'static + Into\u003cu64\u003e,\n    {\n        let value: u64 = value.into();\n        let mask: u64 = mask.into();\n        let shift = mask.trailing_zeros();\n        (value \u0026 (mask \u003e\u003e shift)) \u003c\u003c shift\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use pretty_assertions::assert_eq;\n\n    #[test]\n    fn will_create_undefined_word_by_default() {\n        assert_eq!(Word::default(), Word::new(WordType::Undefined, 0))\n    }\n\n    #[test]\n    fn will_convert_from_int() {\n        let test_int = |i, expected| {\n            let result = Word::try_from(i);\n            assert_eq!(result, Ok(Word::new(WordType::IWord, expected)));\n            assert_eq!(result.unwrap().as_i64(), Ok(i));\n        };\n        test_int(42, 0o00000052);\n        test_int(-42, 0o77777726);\n    }\n\n    #[test]\n    fn will_not_convert_from_int_when_out_of_range() {\n        let value = 10_000_000;\n        assert_eq!(Word::try_from(value), Err(Error::InvalidIWordValue(value)))\n    }\n\n    #[test]\n    fn will_convert_from_float() {\n        let test_float = |f, expected| {\n            let result = Word::try_from(f);\n            assert_eq!(result, Ok(Word::new(WordType::FWord, expected)));\n            assert_eq!(result.unwrap().as_f64(), Ok(f));\n        };\n        test_float(42.0, 0o21050000);\n        test_float(-42.0, 0o61050000);\n        test_float(0.0, 0o00000000);\n        test_float(1.0, 0o17600000);\n    }\n\n    #[test]\n    fn will_not_convert_from_float_when_out_of_range() {\n        let value = 1844672.0e19;\n        assert_eq!(Word::try_from(value), Err(Error::InvalidFWordValue(value)));\n    }\n\n    #[test]\n    fn will_convert_from_str() {\n        let test_string = |s: String, expected| {\n            let result = Word::try_from(s.as_str());\n            assert_eq!(result, Ok(Word::new(WordType::SWord, expected)));\n            let raw_bits = result.unwrap().raw_bits;\n            assert_eq!(raw_bits, raw_bits \u0026 Word::MASK);\n        };\n        test_string(\"ABCD\".to_string(), 0o01020304);\n        test_string(\"AB\".to_string(), 0o00000102);\n        test_string(\"AB\\0\\0\".to_string(), 0o01020000);\n        test_string(\"WXYZ\".to_string(), 0o27303132);\n    }\n\n    #[test]\n    fn will_not_convert_from_str_when_out_of_range() {\n        let value = \"ABCDEF\";\n        assert_eq!(\n            Word::try_from(value),\n            Err(Error::InvalidSWordValue(value.into()))\n        );\n    }\n}\n","traces":[{"line":57,"address":[1902864],"length":1,"stats":{"Line":3}},{"line":64,"address":[1902880],"length":1,"stats":{"Line":3}},{"line":65,"address":[1902885],"length":1,"stats":{"Line":3}},{"line":68,"address":[1902912],"length":1,"stats":{"Line":1}},{"line":69,"address":[1902917],"length":1,"stats":{"Line":1}},{"line":72,"address":[1902944],"length":1,"stats":{"Line":1}},{"line":73,"address":[1902958],"length":1,"stats":{"Line":3}},{"line":74,"address":[1903011],"length":1,"stats":{"Line":1}},{"line":77,"address":[1903040],"length":1,"stats":{"Line":3}},{"line":78,"address":[1903054],"length":1,"stats":{"Line":1}},{"line":79,"address":[1903107],"length":1,"stats":{"Line":3}},{"line":82,"address":[1903136],"length":1,"stats":{"Line":1}},{"line":83,"address":[1903150],"length":1,"stats":{"Line":3}},{"line":84,"address":[1903203],"length":1,"stats":{"Line":1}},{"line":87,"address":[1903232],"length":1,"stats":{"Line":3}},{"line":88,"address":[1903246],"length":1,"stats":{"Line":1}},{"line":89,"address":[1903299],"length":1,"stats":{"Line":3}},{"line":92,"address":[1903328],"length":1,"stats":{"Line":1}},{"line":93,"address":[1903342],"length":1,"stats":{"Line":3}},{"line":94,"address":[1903395],"length":1,"stats":{"Line":1}},{"line":97,"address":[1903424],"length":1,"stats":{"Line":3}},{"line":98,"address":[1903438],"length":1,"stats":{"Line":1}},{"line":99,"address":[1903491],"length":1,"stats":{"Line":3}},{"line":102,"address":[1903520],"length":1,"stats":{"Line":3}},{"line":103,"address":[1903864,1903542,1903579],"length":1,"stats":{"Line":9}},{"line":104,"address":[1903563],"length":1,"stats":{"Line":3}},{"line":105,"address":[1903701,1903825],"length":1,"stats":{"Line":6}},{"line":108,"address":[1903888],"length":1,"stats":{"Line":1}},{"line":109,"address":[1904390,1904055,1903910],"length":1,"stats":{"Line":3}},{"line":111,"address":[1903935],"length":1,"stats":{"Line":1}},{"line":113,"address":[1903956],"length":1,"stats":{"Line":1}},{"line":115,"address":[1903985,1903970],"length":1,"stats":{"Line":3}},{"line":116,"address":[1903992],"length":1,"stats":{"Line":1}},{"line":117,"address":[1904425,1904020,1904482],"length":1,"stats":{"Line":2}},{"line":119,"address":[1904432],"length":1,"stats":{"Line":1}},{"line":121,"address":[1904462,1904619,1904502],"length":1,"stats":{"Line":2}},{"line":122,"address":[1904811,1904639,1904679],"length":1,"stats":{"Line":2}},{"line":123,"address":[1904649,1904605],"length":1,"stats":{"Line":1}},{"line":126,"address":[1904756,1904699,1904784],"length":1,"stats":{"Line":3}},{"line":127,"address":[1904726],"length":1,"stats":{"Line":1}},{"line":128,"address":[1904764],"length":1,"stats":{"Line":1}},{"line":130,"address":[1904795],"length":1,"stats":{"Line":1}},{"line":132,"address":[1903976],"length":1,"stats":{"Line":2}},{"line":135,"address":[1904184,1904330],"length":1,"stats":{"Line":2}},{"line":138,"address":[1904832],"length":1,"stats":{"Line":1}},{"line":139,"address":[1904854],"length":1,"stats":{"Line":1}},{"line":141,"address":[1905161],"length":1,"stats":{"Line":1}},{"line":142,"address":[1905184],"length":1,"stats":{"Line":1}},{"line":143,"address":[1747758,1747696,1747708],"length":1,"stats":{"Line":0}},{"line":144,"address":[1905234],"length":1,"stats":{"Line":1}},{"line":146,"address":[1905085,1904977],"length":1,"stats":{"Line":0}},{"line":150,"address":[1905264,1905310],"length":1,"stats":{"Line":1}},{"line":152,"address":[1905273],"length":1,"stats":{"Line":1}},{"line":153,"address":[1905281],"length":1,"stats":{"Line":1}},{"line":154,"address":[1905312],"length":1,"stats":{"Line":1}},{"line":155,"address":[1905323],"length":1,"stats":{"Line":1}},{"line":156,"address":[1905334],"length":1,"stats":{"Line":1}},{"line":157,"address":[1905345],"length":1,"stats":{"Line":1}},{"line":158,"address":[1905356],"length":1,"stats":{"Line":0}},{"line":163,"address":[1905424],"length":1,"stats":{"Line":1}},{"line":164,"address":[1905442,1905597],"length":1,"stats":{"Line":1}},{"line":165,"address":[1905478,1905589],"length":1,"stats":{"Line":2}},{"line":168,"address":[1905616],"length":1,"stats":{"Line":1}},{"line":169,"address":[1905625],"length":1,"stats":{"Line":1}},{"line":172,"address":[1905664],"length":1,"stats":{"Line":1}},{"line":173,"address":[1905674],"length":1,"stats":{"Line":1}},{"line":176,"address":[1905696],"length":1,"stats":{"Line":1}},{"line":177,"address":[1905720,1905772],"length":1,"stats":{"Line":1}},{"line":178,"address":[1905762,1905848],"length":1,"stats":{"Line":1}},{"line":179,"address":[1905819,1905850],"length":1,"stats":{"Line":0}},{"line":182,"address":[1905793,1905876,1905939],"length":1,"stats":{"Line":2}},{"line":183,"address":[1905892],"length":1,"stats":{"Line":1}},{"line":185,"address":[1905921],"length":1,"stats":{"Line":1}},{"line":188,"address":[1905968],"length":1,"stats":{"Line":1}},{"line":189,"address":[1906001,1906311],"length":1,"stats":{"Line":2}},{"line":191,"address":[1906392,1906592],"length":1,"stats":{"Line":2}},{"line":192,"address":[1906600,1906795],"length":1,"stats":{"Line":2}},{"line":193,"address":[1906803],"length":1,"stats":{"Line":1}},{"line":194,"address":[1906821,1907030],"length":1,"stats":{"Line":2}},{"line":197,"address":[1907246,1907046],"length":1,"stats":{"Line":0}},{"line":198,"address":[1907254,1907457],"length":1,"stats":{"Line":0}},{"line":199,"address":[1907466],"length":1,"stats":{"Line":0}},{"line":200,"address":[1908025,1907500],"length":1,"stats":{"Line":0}},{"line":201,"address":[1908005,1907760],"length":1,"stats":{"Line":0}},{"line":203,"address":[1907734,1907530],"length":1,"stats":{"Line":0}},{"line":207,"address":[1908259,1908056],"length":1,"stats":{"Line":0}},{"line":208,"address":[1908268,1908469],"length":1,"stats":{"Line":0}},{"line":209,"address":[1908477],"length":1,"stats":{"Line":0}},{"line":210,"address":[1909501,1908504],"length":1,"stats":{"Line":0}},{"line":211,"address":[1909006,1909251],"length":1,"stats":{"Line":0}},{"line":213,"address":[1909481,1909277],"length":1,"stats":{"Line":0}},{"line":217,"address":[1908524,1908727],"length":1,"stats":{"Line":2}},{"line":218,"address":[1908939,1908736],"length":1,"stats":{"Line":2}},{"line":219,"address":[1908948],"length":1,"stats":{"Line":1}},{"line":220,"address":[1910025,1908976],"length":1,"stats":{"Line":2}},{"line":221,"address":[1910005,1909763],"length":1,"stats":{"Line":0}},{"line":223,"address":[1909533,1909737],"length":1,"stats":{"Line":2}},{"line":226,"address":[1906058,1906221],"length":1,"stats":{"Line":0}},{"line":232,"address":[1910064],"length":1,"stats":{"Line":3}},{"line":233,"address":[1910757,1910262,1910525,1910092],"length":1,"stats":{"Line":12}},{"line":240,"address":[1910896],"length":1,"stats":{"Line":3}},{"line":241,"address":[1910922],"length":1,"stats":{"Line":3}},{"line":242,"address":[1910934],"length":1,"stats":{"Line":3}},{"line":243,"address":[1911139,1911191,1910960],"length":1,"stats":{"Line":9}},{"line":245,"address":[1911177],"length":1,"stats":{"Line":3}},{"line":252,"address":[1911216],"length":1,"stats":{"Line":2}},{"line":253,"address":[1911376],"length":1,"stats":{"Line":2}},{"line":254,"address":[1911392],"length":1,"stats":{"Line":2}},{"line":256,"address":[1911431],"length":1,"stats":{"Line":2}},{"line":258,"address":[1911467,1911515],"length":1,"stats":{"Line":2}},{"line":261,"address":[1911535,1911506],"length":1,"stats":{"Line":4}},{"line":264,"address":[1911568],"length":1,"stats":{"Line":2}},{"line":265,"address":[1911588],"length":1,"stats":{"Line":2}},{"line":267,"address":[1911606],"length":1,"stats":{"Line":2}},{"line":268,"address":[1911634,1911733],"length":1,"stats":{"Line":2}},{"line":270,"address":[1911676],"length":1,"stats":{"Line":2}},{"line":271,"address":[1911718],"length":1,"stats":{"Line":2}},{"line":274,"address":[1911760],"length":1,"stats":{"Line":2}},{"line":275,"address":[1912604,1911782],"length":1,"stats":{"Line":4}},{"line":276,"address":[1911797],"length":1,"stats":{"Line":2}},{"line":278,"address":[1911984,1911851],"length":1,"stats":{"Line":2}},{"line":279,"address":[1912004,1912628,1912043],"length":1,"stats":{"Line":4}},{"line":280,"address":[1911970,1912014],"length":1,"stats":{"Line":2}},{"line":283,"address":[1912139,1912062,1912113],"length":1,"stats":{"Line":6}},{"line":284,"address":[1912087],"length":1,"stats":{"Line":2}},{"line":285,"address":[1912126],"length":1,"stats":{"Line":2}},{"line":287,"address":[1912215,1912463],"length":1,"stats":{"Line":4}},{"line":293,"address":[1911295,1911241],"length":1,"stats":{"Line":3}},{"line":294,"address":[1911346,1911302],"length":1,"stats":{"Line":4}},{"line":295,"address":[1747824,1747836],"length":1,"stats":{"Line":4}},{"line":296,"address":[1911331],"length":1,"stats":{"Line":2}},{"line":298,"address":[1911252],"length":1,"stats":{"Line":1}},{"line":306,"address":[1912656],"length":1,"stats":{"Line":2}},{"line":307,"address":[1912712,1912813,1912908],"length":1,"stats":{"Line":6}},{"line":308,"address":[1912797],"length":1,"stats":{"Line":2}},{"line":309,"address":[1912738],"length":1,"stats":{"Line":2}},{"line":310,"address":[1912762],"length":1,"stats":{"Line":2}},{"line":313,"address":[1747872,1747885,1747937],"length":1,"stats":{"Line":6}},{"line":314,"address":[1747952],"length":1,"stats":{"Line":2}},{"line":315,"address":[1747970],"length":1,"stats":{"Line":2}},{"line":318,"address":[1912845],"length":1,"stats":{"Line":2}},{"line":326,"address":[1912944],"length":1,"stats":{"Line":1}},{"line":327,"address":[1912958],"length":1,"stats":{"Line":1}},{"line":332,"address":[1912976],"length":1,"stats":{"Line":1}},{"line":333,"address":[1912990],"length":1,"stats":{"Line":1}},{"line":338,"address":[1913008],"length":1,"stats":{"Line":1}},{"line":339,"address":[1913022],"length":1,"stats":{"Line":1}},{"line":345,"address":[1915277,1920004,1921023,1915588,1913069,1913380,1918753,1914336,1916544,1917796,1919693,1917485],"length":1,"stats":{"Line":18}},{"line":346,"address":[1913856,1915669,1920085,1920480,1914308,1918072,1918725,1916516,1920930,1916064,1913656,1915864,1913461,1920280,1918272,1917877],"length":1,"stats":{"Line":24}},{"line":347,"address":[1920500,1920690,1913883,1918300,1918490,1914287,1920904,1916091,1916281,1916495,1914073,1918704],"length":1,"stats":{"Line":0}},{"line":348,"address":[1916600,1919208,1921478,1916798,1914392,1914791,1919007,1921277,1918809,1921079,1914590,1916999],"length":1,"stats":{"Line":0}},{"line":349,"address":[1921704,1921903,1919237,1915216,1919434,1917028,1915017,1917424,1917225,1919633,1914820,1921507],"length":1,"stats":{"Line":4}},{"line":350,"address":[1919751,1919914,1913127,1913290,1915335,1917706,1915498,1917543],"length":1,"stats":{"Line":0}},{"line":356,"address":[1913040],"length":1,"stats":{"Line":2}},{"line":357,"address":[1914373],"length":1,"stats":{"Line":2}},{"line":362,"address":[1915248],"length":1,"stats":{"Line":1}},{"line":363,"address":[1916581],"length":1,"stats":{"Line":1}},{"line":368,"address":[1917456],"length":1,"stats":{"Line":2}},{"line":369,"address":[1918790],"length":1,"stats":{"Line":2}},{"line":374,"address":[1919664],"length":1,"stats":{"Line":1}},{"line":375,"address":[1921060],"length":1,"stats":{"Line":1}},{"line":382,"address":[1921936],"length":1,"stats":{"Line":1}},{"line":383,"address":[1921952],"length":1,"stats":{"Line":1}},{"line":384,"address":[1922126],"length":1,"stats":{"Line":1}},{"line":386,"address":[1902087,1902064],"length":1,"stats":{"Line":2}},{"line":387,"address":[1902160,1902382,1902262],"length":1,"stats":{"Line":0}},{"line":388,"address":[1922189],"length":1,"stats":{"Line":1}},{"line":390,"address":[1902497,1902480],"length":1,"stats":{"Line":2}},{"line":391,"address":[1902544,1902646,1902766],"length":1,"stats":{"Line":0}},{"line":392,"address":[1922054],"length":1,"stats":{"Line":0}},{"line":400,"address":[1922288],"length":1,"stats":{"Line":1}},{"line":401,"address":[1922312],"length":1,"stats":{"Line":1}},{"line":406,"address":[1922336],"length":1,"stats":{"Line":1}},{"line":407,"address":[1922664,1922369],"length":1,"stats":{"Line":2}},{"line":409,"address":[1922739,1922918,1923097],"length":1,"stats":{"Line":0}},{"line":412,"address":[1923131,1923530,1923325],"length":1,"stats":{"Line":0}},{"line":414,"address":[1923581,1923777,1923989],"length":1,"stats":{"Line":0}},{"line":417,"address":[1923975,1923786],"length":1,"stats":{"Line":0}},{"line":419,"address":[1924220,1924417,1924024],"length":1,"stats":{"Line":6}},{"line":421,"address":[1922417,1922574],"length":1,"stats":{"Line":0}},{"line":427,"address":[1924480],"length":1,"stats":{"Line":1}},{"line":428,"address":[1924506,1924660],"length":1,"stats":{"Line":2}},{"line":429,"address":[1924665,1924717],"length":1,"stats":{"Line":1}},{"line":430,"address":[1924696],"length":1,"stats":{"Line":1}},{"line":434,"address":[1325488],"length":1,"stats":{"Line":1}},{"line":435,"address":[1325498],"length":1,"stats":{"Line":2}},{"line":438,"address":[1325520],"length":1,"stats":{"Line":1}},{"line":439,"address":[1325550],"length":1,"stats":{"Line":1}},{"line":440,"address":[1325576],"length":1,"stats":{"Line":1}},{"line":443,"address":[1325601],"length":1,"stats":{"Line":1}},{"line":444,"address":[1325639],"length":1,"stats":{"Line":1}},{"line":448,"address":[1325712],"length":1,"stats":{"Line":1}},{"line":449,"address":[1325736,1325882],"length":1,"stats":{"Line":2}},{"line":450,"address":[1325887],"length":1,"stats":{"Line":1}},{"line":453,"address":[1325904],"length":1,"stats":{"Line":1}},{"line":454,"address":[1325921],"length":1,"stats":{"Line":1}},{"line":457,"address":[1325936],"length":1,"stats":{"Line":1}},{"line":458,"address":[1326000,1326116],"length":1,"stats":{"Line":1}},{"line":459,"address":[1326075],"length":1,"stats":{"Line":1}},{"line":460,"address":[1326100,1326283,1326193],"length":1,"stats":{"Line":2}},{"line":461,"address":[1326208],"length":1,"stats":{"Line":1}},{"line":464,"address":[1326320],"length":1,"stats":{"Line":1}},{"line":465,"address":[1326384,1326586],"length":1,"stats":{"Line":1}},{"line":466,"address":[1326576,1326680],"length":1,"stats":{"Line":1}},{"line":467,"address":[1326651,1326682],"length":1,"stats":{"Line":0}},{"line":470,"address":[1326612],"length":1,"stats":{"Line":1}},{"line":472,"address":[1326630,1326853,1326708],"length":1,"stats":{"Line":2}},{"line":473,"address":[1326727],"length":1,"stats":{"Line":1}},{"line":474,"address":[1326754],"length":1,"stats":{"Line":1}},{"line":476,"address":[1326778],"length":1,"stats":{"Line":1}},{"line":479,"address":[1326896],"length":1,"stats":{"Line":1}},{"line":480,"address":[1326965],"length":1,"stats":{"Line":1}},{"line":481,"address":[1326988,1327163,1327259],"length":1,"stats":{"Line":2}},{"line":482,"address":[1327188],"length":1,"stats":{"Line":1}},{"line":485,"address":[1327280],"length":1,"stats":{"Line":1}},{"line":486,"address":[1327349],"length":1,"stats":{"Line":1}},{"line":487,"address":[1327704,1327546,1327372],"length":1,"stats":{"Line":2}},{"line":488,"address":[1327633],"length":1,"stats":{"Line":1}},{"line":491,"address":[1327728],"length":1,"stats":{"Line":1}},{"line":492,"address":[1327766,1327951],"length":1,"stats":{"Line":2}},{"line":493,"address":[1327959,1328139],"length":1,"stats":{"Line":2}},{"line":495,"address":[1328147],"length":1,"stats":{"Line":1}},{"line":496,"address":[1328231],"length":1,"stats":{"Line":1}},{"line":501,"address":[1288480,1288710],"length":1,"stats":{"Line":3}},{"line":506,"address":[1288570,1288499],"length":1,"stats":{"Line":4}},{"line":507,"address":[1288575],"length":1,"stats":{"Line":1}},{"line":508,"address":[1288653],"length":1,"stats":{"Line":3}},{"line":509,"address":[1288657,1288690],"length":1,"stats":{"Line":1}},{"line":512,"address":[1289012,1289312,1289581,1289024,1289294,1288736],"length":1,"stats":{"Line":5}},{"line":517,"address":[1289113,1288831,1289331,1289402,1288757,1289042],"length":1,"stats":{"Line":12}},{"line":518,"address":[1288836,1289118,1289407],"length":1,"stats":{"Line":7}},{"line":519,"address":[1288904,1289186,1289475],"length":1,"stats":{"Line":5}},{"line":520,"address":[1288908,1289190,1289563,1289276,1288994,1289479],"length":1,"stats":{"Line":7}}],"covered":203,"coverable":233},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","mod.rs"],"content":"mod assembler;\nmod assembly;\nmod ast;\nmod charset;\nmod executor;\nmod grammar;\nmod memory;\nmod parser;\nmod result;\n\nuse self::assembler::Assembler;\nuse self::assembly::Assembly;\nuse self::ast::SourceLine;\nuse self::executor::Executor;\nuse self::parser::Parser;\n\nuse crate::args::Args;\nuse crate::list_writer::ListWriter;\nuse crate::model::*;\nuse crate::result::{Error, Result};\n\nuse std::path::Path;\n\npub struct BbcX {\n    args: Args,\n}\n\nimpl BbcX {\n    pub fn new(args: \u0026Args) -\u003e BbcX {\n        let args = args.clone();\n        Self { args }\n    }\n\n    fn impl_parse(\u0026self, path: \u0026Path) -\u003e Result\u003cVec\u003cResult\u003cSourceLine\u003e\u003e\u003e {\n        let lines = file_lines(path)?;\n        let results = lines.iter().map(|line| Parser::parse_line(line));\n        Ok(results.collect())\n    }\n\n    fn impl_assemble(\u0026self, path: \u0026Path) -\u003e Result\u003cAssembly\u003e {\n        let parsed_lines = self.impl_parse(path)?;\n\n        let parsed_lines_len = parsed_lines.len();\n        let ast = parsed_lines\n            .iter()\n            .filter_map(|l| l.as_ref().ok())\n            .cloned()\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let all_ok = parsed_lines_len == ast.len();\n\n        if all_ok {\n            Assembler::assemble(\u0026ast)\n        } else {\n            let lines = file_lines(path)?;\n            let all_results = parsed_lines\n                .iter()\n                .zip(lines.iter())\n                .map(|(r, l)| match (r, l) {\n                    (Ok(_), l) =\u003e format!(\"        {}\", l),\n                    (Err(Error::FailedToParse(e)), l) =\u003e format!(\" *****  {}\\n         {}\", l, e),\n                    _ =\u003e unreachable!(),\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\\n\");\n            Err(Error::FailedToAssemble(all_results))\n        }\n    }\n\n    fn impl_run(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        let assembly = self.impl_assemble(path)?;\n        let executor = Executor::new();\n        _ = executor\n            .execute(\u0026assembly)\n            .map_err(|err| Error::FailedToRun(err.to_string()))?;\n        Ok(())\n    }\n\n    fn impl_list(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        let mut writer = ListWriter::new(path, \u0026self.args);\n        let lines = file_lines(path)?;\n        let results = lines.iter().map(|line| Parser::parse_line(line));\n        for line in results {\n            let line = match line {\n                Ok(line) =\u003e format!(\"        {}\", line),\n                Err(Error::FailedToParse(error)) =\u003e format!(\" *****  {}\", error),\n                _ =\u003e unreachable!(),\n            };\n            writer.add_lines_to_listing(\u0026line);\n        }\n        writer\n            .write_content_to_file()\n            .map_err(|e| Error::CannotToWriteFile(path.display().to_string(), e.to_string()))\n    }\n}\n\nfn file_lines(path: \u0026Path) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n    let filename = path.display().to_string();\n\n    let content =\n        std::fs::read(path).map_err(|e| Error::CannotReadFile(filename.clone(), e.to_string()))?;\n\n    let content = String::from_utf8(content)\n        .map_err(|e| Error::CannotReadFile(filename.clone(), e.to_string()))?;\n\n    Ok(content.lines().map(|line| line.to_owned()).collect())\n}\n\nimpl LanguageModel for BbcX {\n    fn assemble(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        _ = self.impl_assemble(path)?;\n        Ok(())\n    }\n\n    fn run(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        self.impl_run(path)\n    }\n\n    fn list(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e {\n        _ = self.impl_list(path);\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use tempdir::TempDir;\n\n    #[test]\n    fn will_assemble() {\n        let args = vec![\"bbc-x\", \"--lang=bbc-x\", \"./examples/test/bbcx/nthg.bbc\"]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let model = BbcX::new(\u0026args);\n        let result = model.assemble(\u0026args.files().next().unwrap());\n        assert!(result.is_ok())\n    }\n\n    #[test]\n    fn will_run() {\n        let args = vec![\n            \"bbc-x\",\n            \"--lang=bbc-x\",\n            \"--run\",\n            \"./examples/test/bbcx/nil.bbc\",\n        ]\n        .into_iter()\n        .map(|s| s.to_string())\n        .collect();\n        let args = Args::from(args);\n        let model = BbcX::new(\u0026args);\n        let result = model.run(\u0026args.files().next().unwrap());\n        assert!(result.is_ok())\n    }\n\n    #[test]\n    fn will_list() {\n        let temp_folder = TempDir::new(\"bbcx-tests-bbcx\").unwrap();\n\n        let temp_target = temp_folder.path().join(\"nthg.bbc\");\n        let temp_target_str = temp_target.display().to_string();\n\n        std::fs::copy(\"./examples/test/bbcx/nthg.bbc\", temp_target).unwrap();\n\n        let args = vec![\"bbc-x\", \"--lang=bbc-x\", \"--list\", \u0026temp_target_str]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let model = BbcX::new(\u0026args);\n        let _ = model.list(\u0026args.files().next().unwrap());\n\n        let list_target = temp_folder.path().join(\"nthg.lst\");\n        assert!(list_target.exists());\n    }\n}\n","traces":[{"line":29,"address":[1754064],"length":1,"stats":{"Line":1}},{"line":30,"address":[1754082],"length":1,"stats":{"Line":1}},{"line":34,"address":[1754593,1754128],"length":1,"stats":{"Line":1}},{"line":35,"address":[1754330,1754195],"length":1,"stats":{"Line":1}},{"line":36,"address":[872899,872864],"length":1,"stats":{"Line":4}},{"line":37,"address":[1754514],"length":1,"stats":{"Line":1}},{"line":40,"address":[1756095,1754624,1756190],"length":1,"stats":{"Line":1}},{"line":41,"address":[1754687,1754834],"length":1,"stats":{"Line":1}},{"line":43,"address":[1754941,1754819],"length":1,"stats":{"Line":2}},{"line":44,"address":[1754957],"length":1,"stats":{"Line":1}},{"line":46,"address":[872928,872953],"length":1,"stats":{"Line":2}},{"line":50,"address":[1755130,1755195],"length":1,"stats":{"Line":2}},{"line":52,"address":[1755213],"length":1,"stats":{"Line":1}},{"line":53,"address":[1755256,1756166],"length":1,"stats":{"Line":2}},{"line":55,"address":[1755292,1755425,1755241],"length":1,"stats":{"Line":0}},{"line":56,"address":[1755693,1755827,1755568,1755397],"length":1,"stats":{"Line":0}},{"line":58,"address":[1755605],"length":1,"stats":{"Line":0}},{"line":59,"address":[873016,872976,873279],"length":1,"stats":{"Line":0}},{"line":60,"address":[873183,873072,873277],"length":1,"stats":{"Line":0}},{"line":61,"address":[873309,873716,873563],"length":1,"stats":{"Line":0}},{"line":62,"address":[873721],"length":1,"stats":{"Line":0}},{"line":66,"address":[1755930],"length":1,"stats":{"Line":0}},{"line":70,"address":[1756903,1756208],"length":1,"stats":{"Line":1}},{"line":71,"address":[1756248,1756495],"length":1,"stats":{"Line":1}},{"line":72,"address":[1756488],"length":1,"stats":{"Line":1}},{"line":73,"address":[1756835,1756609],"length":1,"stats":{"Line":1}},{"line":75,"address":[873760,873783],"length":1,"stats":{"Line":1}},{"line":76,"address":[1756861],"length":1,"stats":{"Line":1}},{"line":79,"address":[1758156,1756928,1758876],"length":1,"stats":{"Line":1}},{"line":80,"address":[1756995],"length":1,"stats":{"Line":1}},{"line":81,"address":[1757050,1757113,1757247],"length":1,"stats":{"Line":2}},{"line":82,"address":[873904,873939],"length":1,"stats":{"Line":4}},{"line":83,"address":[1758691,1757464,1757576],"length":1,"stats":{"Line":3}},{"line":84,"address":[1757875,1757626],"length":1,"stats":{"Line":1}},{"line":85,"address":[1758064,1757903,1757729],"length":1,"stats":{"Line":2}},{"line":86,"address":[1758366,1758165,1758531],"length":1,"stats":{"Line":0}},{"line":89,"address":[1758136,1758615],"length":1,"stats":{"Line":2}},{"line":91,"address":[1757677,1757564],"length":1,"stats":{"Line":2}},{"line":93,"address":[873968,873999],"length":1,"stats":{"Line":0}},{"line":97,"address":[1759906,1759853,1758896],"length":1,"stats":{"Line":1}},{"line":98,"address":[1758955],"length":1,"stats":{"Line":1}},{"line":100,"address":[874272,874296],"length":1,"stats":{"Line":2}},{"line":103,"address":[1759626,1759862,1759409,1759196],"length":1,"stats":{"Line":2}},{"line":104,"address":[874512,874536],"length":1,"stats":{"Line":0}},{"line":106,"address":[874805,874752],"length":1,"stats":{"Line":4}},{"line":110,"address":[1759920],"length":1,"stats":{"Line":1}},{"line":111,"address":[1759961,1760088],"length":1,"stats":{"Line":1}},{"line":112,"address":[1760079],"length":1,"stats":{"Line":1}},{"line":115,"address":[1760160],"length":1,"stats":{"Line":1}},{"line":116,"address":[1760187],"length":1,"stats":{"Line":1}},{"line":119,"address":[1760208],"length":1,"stats":{"Line":1}},{"line":120,"address":[1760237],"length":1,"stats":{"Line":1}},{"line":121,"address":[1760267],"length":1,"stats":{"Line":1}}],"covered":42,"coverable":53},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","parser.rs"],"content":"use super::ast::*;\nuse super::grammar::*;\n\nuse crate::result::{Error, Result};\n\npub struct Parser;\n\nimpl Parser {\n    pub fn parse_line(input: \u0026str) -\u003e Result\u003cSourceLine\u003e {\n        Grammar::bbcx_line()\n            .parse(input.trim().as_bytes())\n            .map_err(|_| Error::FailedToParse(input.into()))\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use pretty_assertions::assert_eq;\n\n    type SourceProgram = Vec\u003cResult\u003cSourceLine\u003e\u003e;\n\n    fn parse(input: \u0026str) -\u003e SourceProgram {\n        input\n            .to_string()\n            .lines()\n            .map(Parser::parse_line)\n            .collect::\u003cSourceProgram\u003e()\n    }\n\n    fn from_pwords(pwords: \u0026[PWord]) -\u003e SourceProgram {\n        pwords\n            .iter()\n            .enumerate()\n            .map(|(i, p)| {\n                Ok(SourceLine::new(\n                    i + 1,\n                    Label::from(None),\n                    SourceWord::PWord(p.clone()),\n                    \"\".into(),\n                ))\n            })\n            .collect::\u003cSourceProgram\u003e()\n    }\n\n    #[test]\n    fn locations_labels_and_comments() {\n        let program = r#\"\n0001                \"    \"\n0002                \"  C1\"      ; Comment 1\n0003    LABEL1:     \"    \"\n0004    LABEL2:     \"  C2\"      ; Comment 2\n\"#;\n        let actual = parse(program);\n        let expected = vec![\n            Ok(SourceLine::new(\n                1,\n                Label::from(None),\n                SourceWord::SWord(\"    \".into()),\n                \"\".into(),\n            )),\n            Ok(SourceLine::new(\n                2,\n                Label::from(None),\n                SourceWord::SWord(\"  C1\".into()),\n                \"; Comment 1\".into(),\n            )),\n            Ok(SourceLine::new(\n                3,\n                Label::from(\"LABEL1\".to_string()),\n                SourceWord::SWord(\"    \".into()),\n                \"\".into(),\n            )),\n            Ok(SourceLine::new(\n                4,\n                Label::from(\"LABEL2\".to_string()),\n                SourceWord::SWord(\"  C2\".into()),\n                \"; Comment 2\".into(),\n            )),\n        ]\n        .into_iter()\n        .collect::\u003cSourceProgram\u003e();\n        assert_eq!(actual[1..], expected);\n    }\n\n    #[test]\n    fn sword() {\n        let program = r#\"0001   \"TEXT\"\n\"#;\n        let actual = parse(program);\n        let expected = vec![Ok(SourceLine::new(\n            1,\n            Label::from(None),\n            SourceWord::SWord(\"TEXT\".into()),\n            \"\".into(),\n        ))]\n        .into_iter()\n        .collect::\u003cSourceProgram\u003e();\n        assert_eq!(actual, expected)\n    }\n\n    #[test]\n    fn pword_take_type() {\n        let program = r#\"\n0001    ADD     ADDR1\n0002    ADD 2,  ADDR2\n0003    SKAG    ADDR3\n0004    SKAG 2, ADDR4\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::new(\n                Mnemonic::ADD,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::new(\n                Mnemonic::ADD,\n                '2'.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR2\".into())),\n                    None,\n                )),\n            ),\n            PWord::new(\n                Mnemonic::SKAG,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR3\".into())),\n                    None,\n                )),\n            ),\n            PWord::new(\n                Mnemonic::SKAG,\n                '2'.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR4\".into())),\n                    None,\n                )),\n            ),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn pword_put_type() {\n        let program = r#\"\n0001    ADDX    ADDR1\n0002    INCR    ADDR2\n0003    JUMP2,   ADDR4\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::new(\n                Mnemonic::ADDX,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::new(\n                Mnemonic::INCR,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR2\".into())),\n                    None,\n                )),\n            ),\n            PWord::new(\n                Mnemonic::JUMP,\n                '2'.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR4\".into())),\n                    None,\n                )),\n            ),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn pword_library_mnemonic() {\n        let program = r#\"\n0001    SQRT\n0002    LN\n0003    EXP\n0004    READ\n0005    PRINT\n0006    SIN\n0007    COS\n0008    TAN\n0009    ATN\n0010    STOP\n0011    LINE\n0012    INT\n0013    FRAC\n0014    FLOAT\n0015    CAPTN\n0016    PAGE\n0017    RND\n0018    ABS\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::new(Mnemonic::SQRT, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::LN, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::EXP, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::READ, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::PRINT, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::SIN, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::COS, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::TAN, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::ATN, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::STOP, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::LINE, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::INT, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::FRAC, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::FLOAT, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::CAPTN, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::PAGE, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::RND, None.into(), StoreOperand::None),\n            PWord::new(Mnemonic::ABS, None.into(), StoreOperand::None),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn fword() {\n        let program = r#\"\n0001   3.14\n\"#;\n        let actual = parse(program);\n        let expected = vec![Ok(SourceLine::new(\n            1,\n            None.into(),\n            SourceWord::FWord(3.14),\n            \"\".into(),\n        ))];\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn iword() {\n        let program = r#\"\n0001   +42\n\"#;\n        let actual = parse(program);\n        let expected = vec![Ok(SourceLine::new(\n            1,\n            None.into(),\n            SourceWord::IWord(42),\n            \"\".into(),\n        ))];\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn addressing_modes() {\n        let program = r#\"\n0001    ADD     ADDR1\n0002    ADD2,   ADDR2[42]\n0003    ADD     *ADDR3\n0004    ADD2,   *ADDR4[42]\n0005    ADD     512\n0006    ADD     -42\n0007    ADD2,   +3.14\n0008    ADD2,   \"TEXT\"\n\"#;\n        let actual = parse(program);\n        let pwords = vec![\n            PWord::new(\n                Mnemonic::ADD,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                    None,\n                )),\n            ),\n            PWord::new(\n                Mnemonic::ADD,\n                '2'.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR2\".into())),\n                    Some(42),\n                )),\n            ),\n            PWord::new(\n                Mnemonic::ADD,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::IndirectAddress(Address::Identifier(\"ADDR3\".into())),\n                    None,\n                )),\n            ),\n            PWord::new(\n                Mnemonic::ADD,\n                '2'.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::IndirectAddress(Address::Identifier(\"ADDR4\".into())),\n                    Some(42),\n                )),\n            ),\n            PWord::new(\n                Mnemonic::ADD,\n                None.into(),\n                StoreOperand::AddressOperand(AddressOperand::new(\n                    SimpleAddressOperand::DirectAddress(Address::NumericAddress(512)),\n                    None,\n                )),\n            ),\n            PWord::new(\n                Mnemonic::ADD,\n                None.into(),\n                StoreOperand::ConstOperand(ConstOperand::SignedIWord(-42)),\n            ),\n            PWord::new(\n                Mnemonic::ADD,\n                '2'.into(),\n                StoreOperand::ConstOperand(ConstOperand::SignedFWord(3.14)),\n            ),\n            PWord::new(\n                Mnemonic::ADD,\n                '2'.into(),\n                StoreOperand::ConstOperand(ConstOperand::SWord(\"TEXT\".into())),\n            ),\n        ];\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual[1..], expected)\n    }\n\n    #[test]\n    fn mnemonics() {\n        let program = r#\"\n0001    NIL         ADDR1\n0002    NTHG        ADDR1\n0003    OR          ADDR1\n0004    NEQV        ADDR1\n0005    AND         ADDR1\n0006    ADD         ADDR1\n0007    SUBT        ADDR1\n0008    MULT        ADDR1\n0009    MPLY        ADDR1\n0010    DVD         ADDR1\n0011    TAKE        ADDR1\n0012    TSTR        ADDR1\n0013    TNEG        ADDR1\n0014    TNOT        ADDR1\n0015    TTYP        ADDR1\n0016    TTYZ        ADDR1\n0017    TTTT        ADDR1\n0018    TOUT        ADDR1\n0019    SKIP        ADDR1\n0020    SKAE        ADDR1\n0021    SKAN        ADDR1\n0022    SKET        ADDR1\n0023    SKAL        ADDR1\n0024    SKAG        ADDR1\n0025    SKED        ADDR1\n0026    SKEI        ADDR1\n0027    SHL         ADDR1\n0028    ROT         ADDR1\n0029    DSHL        ADDR1\n0030    DROT        ADDR1\n0031    POWR        ADDR1\n0032    DMULT       ADDR1\n0033    DIV         ADDR1\n0034    DDIV        ADDR1\n0035    NILX        ADDR1\n0036    SWAP        ADDR1\n0037    ORX         ADDR1\n0038    NEQVX       ADDR1\n0039    ANDX        ADDR1\n0040    ADDX        ADDR1\n0041    SUBTX       ADDR1\n0042    MULTX       ADDR1\n0043    MPLYX       ADDR1\n0044    DVDX        ADDR1\n0045    PUT         ADDR1\n0046    PSQU        ADDR1\n0047    PNEG        ADDR1\n0048    PNOT        ADDR1\n0049    PTYP        ADDR1\n0050    PTYZ        ADDR1\n0051    PFFP        ADDR1\n0052    PIN         ADDR1\n0053    JUMP        ADDR1\n0054    JEZ         ADDR1\n0055    JNZ         ADDR1\n0056    JAT         ADDR1\n0057    JLZ         ADDR1\n0058    JGZ         ADDR1\n0059    JZD         ADDR1\n0060    JZI         ADDR1\n0061    DECR        ADDR1\n0062    INCR        ADDR1\n0063    MOCKP       ADDR1\n0064    MOCKS       ADDR1\n0065    DBYTE       ADDR1\n0066    EXEC        ADDR1\n0067    EXTRA       ADDR1\n0068    SQRT\n0069    LN\n0070    EXP\n0071    READ\n0072    PRINT\n0073    SIN\n0074    COS\n0075    TAN\n0076    ATN\n0077    STOP\n0078    LINE\n0079    INT\n0080    FRAC\n0081    FLOAT\n0082    CAPTN\n0083    PAGE\n0084    RND\n0085    ABS\n\"#;\n        let actual = parse(program);\n        let store_operand_mnemonics = vec![\n            Mnemonic::NIL,\n            Mnemonic::NIL,\n            Mnemonic::OR,\n            Mnemonic::NEQV,\n            Mnemonic::AND,\n            Mnemonic::ADD,\n            Mnemonic::SUBT,\n            Mnemonic::MULT,\n            Mnemonic::MULT,\n            Mnemonic::DVD,\n            Mnemonic::TAKE,\n            Mnemonic::TSTR,\n            Mnemonic::TNEG,\n            Mnemonic::TNOT,\n            Mnemonic::TTYP,\n            Mnemonic::TTYZ,\n            Mnemonic::TTTT,\n            Mnemonic::TOUT,\n            Mnemonic::SKIP,\n            Mnemonic::SKAE,\n            Mnemonic::SKAN,\n            Mnemonic::SKET,\n            Mnemonic::SKAL,\n            Mnemonic::SKAG,\n            Mnemonic::SKED,\n            Mnemonic::SKEI,\n            Mnemonic::SHL,\n            Mnemonic::ROT,\n            Mnemonic::DSHL,\n            Mnemonic::DROT,\n            Mnemonic::POWR,\n            Mnemonic::DMULT,\n            Mnemonic::DIV,\n            Mnemonic::DDIV,\n            Mnemonic::NILX,\n            Mnemonic::NILX,\n            Mnemonic::ORX,\n            Mnemonic::NEQVX,\n            Mnemonic::ANDX,\n            Mnemonic::ADDX,\n            Mnemonic::SUBTX,\n            Mnemonic::MULTX,\n            Mnemonic::MULTX,\n            Mnemonic::DVDX,\n            Mnemonic::PUT,\n            Mnemonic::PSQU,\n            Mnemonic::PNEG,\n            Mnemonic::PNOT,\n            Mnemonic::PTYP,\n            Mnemonic::PTYZ,\n            Mnemonic::PFFP,\n            Mnemonic::PIN,\n            Mnemonic::JUMP,\n            Mnemonic::JEZ,\n            Mnemonic::JNZ,\n            Mnemonic::JAT,\n            Mnemonic::JLZ,\n            Mnemonic::JGZ,\n            Mnemonic::JZD,\n            Mnemonic::JZI,\n            Mnemonic::DECR,\n            Mnemonic::INCR,\n            Mnemonic::MOCKP,\n            Mnemonic::MOCKS,\n            Mnemonic::DBYTE,\n            Mnemonic::EXEC,\n            Mnemonic::EXTRA,\n        ];\n        let mut store_operand_pwords = store_operand_mnemonics\n            .into_iter()\n            .map(|m| {\n                PWord::new(\n                    m,\n                    None.into(),\n                    StoreOperand::AddressOperand(AddressOperand::new(\n                        SimpleAddressOperand::DirectAddress(Address::Identifier(\"ADDR1\".into())),\n                        None,\n                    )),\n                )\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let library_operand_mnemonics = vec![\n            Mnemonic::SQRT,\n            Mnemonic::LN,\n            Mnemonic::EXP,\n            Mnemonic::READ,\n            Mnemonic::PRINT,\n            Mnemonic::SIN,\n            Mnemonic::COS,\n            Mnemonic::TAN,\n            Mnemonic::ATN,\n            Mnemonic::STOP,\n            Mnemonic::LINE,\n            Mnemonic::INT,\n            Mnemonic::FRAC,\n            Mnemonic::FLOAT,\n            Mnemonic::CAPTN,\n            Mnemonic::PAGE,\n            Mnemonic::RND,\n            Mnemonic::ABS,\n        ];\n        let mut library_operand_pwords = library_operand_mnemonics\n            .into_iter()\n            .map(|m| PWord::new(m, None.into(), StoreOperand::None))\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        let mut pwords = vec![];\n        pwords.append(\u0026mut store_operand_pwords);\n        pwords.append(\u0026mut library_operand_pwords);\n\n        let expected = from_pwords(\u0026pwords);\n        assert_eq!(actual.len(), expected.len() + 1);\n        let results = actual.iter().skip(1).zip(expected.iter());\n        for (line, expected) in results {\n            // Line by line assert easier to detect errors.\n            assert_eq!(line, expected)\n        }\n    }\n\n    //     #[test]\n    //     fn invalid_syntax() {\n    //         let program = r#\"\n    // 0001\n    // 0002    Invalid One\n    // 0003\n    // 0004    SQRT        ; Valid\n    // 0005\n    // 0006    Invalid Two\n    // \"#;\n    //         let actual = parse(program);\n    //         let expected = vec![\n    //             Err(Error::FailedToParse(\"0001\".into())),\n    //             Err(Error::FailedToParse(\"0002    Invalid One\".into())),\n    //             Err(Error::FailedToParse(\"0003\".into())),\n    //             Ok(SourceProgramLine::new(4, SourceProgramWord::PWord(PWord::new(Mnemonic::SQRT)), \"; Valid\".into())),\n    //             Err(Error::FailedToParse(\"0005\".into())),\n    //             Err(Error::FailedToParse(\"0006    Invalid Two\".into())),\n    //         ];\n    //         assert_eq!(actual[1..], expected)\n    //     }\n}\n","traces":[{"line":9,"address":[1538784,1539024],"length":1,"stats":{"Line":1}},{"line":10,"address":[1538964,1538827],"length":1,"stats":{"Line":4}},{"line":11,"address":[1538858],"length":1,"stats":{"Line":1}},{"line":12,"address":[1894189,1894160],"length":1,"stats":{"Line":4}}],"covered":4,"coverable":4},{"path":["/","home","runner","work","bbc-x","bbc-x","src","bbcx","result.rs"],"content":"use thiserror::Error;\n\n#[derive(Clone, Debug, PartialEq, Error)]\npub enum Error {\n    #[error(\"cannot convert word to intruction: {0}\")]\n    CannotConvertWordToInstruction(String),\n\n    #[error(\"cannot determine operand: reason: {0}\")]\n    CannotDetermineOperand(String),\n\n    #[error(\"failed to create execution context: reason {0}\")]\n    FailedToCreateExecutionContext(String),\n}\n\npub(crate) type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","bbc-x","bbc-x","src","core.rs"],"content":"use crate::args::{Args, Language as LanguageArg};\nuse crate::bbc3::Bbc3;\nuse crate::bbcx::BbcX;\nuse crate::language::Language;\nuse crate::result::{Error, Result};\n\npub struct Core {}\n\nimpl Core {\n    pub fn build_all(args: \u0026Args) -\u003e Result\u003c()\u003e {\n        let language = match args.language() {\n            LanguageArg::Bbc3 =\u003e Language::Bbc3(Bbc3::new(args)),\n            LanguageArg::BbcX =\u003e Language::BbcX(BbcX::new(args)),\n        };\n\n        let mut results = vec![];\n\n        for file in args.files() {\n            let result = language.assemble(\u0026file).and_then(|_| {\n                if args.run() {\n                    language.run(\u0026file)\n                } else {\n                    Ok(())\n                }\n            });\n            results.push(result);\n\n            let _ = language.list(\u0026file);\n        }\n\n        let results = results\n            .into_iter()\n            .filter_map(Result::err)\n            .collect::\u003cVec\u003cError\u003e\u003e();\n\n        if results.is_empty() {\n            Ok(())\n        } else {\n            Err(Error::BuildErrors(results))\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use tempdir::TempDir;\n\n    #[test]\n    fn program_parsed_ok() {\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"./examples/test/bbc3/nthg.bbc\"]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let result = Core::build_all(\u0026args);\n        assert!(result.is_ok())\n    }\n\n    #[test]\n    fn program_parsed_error() {\n        let args = vec![\n            \"bbc-x\",\n            \"--lang=bbc3\",\n            \"./examples/test/bbc3/invalid_syntax.bbc\",\n        ]\n        .into_iter()\n        .map(|s| s.to_string())\n        .collect();\n        let args = Args::from(args);\n        let result = Core::build_all(\u0026args);\n        assert!(result.is_err())\n    }\n\n    #[test]\n    fn program_assembled_ok() {\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"./examples/test/bbc3/nthg.bbc\"]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let result = Core::build_all(\u0026args);\n        assert!(result.is_ok())\n    }\n\n    #[test]\n    fn program_assembled_error() {\n        let args = vec![\n            \"bbc-x\",\n            \"--lang=bbc3\",\n            \"./examples/test/bbc3/invalid_semantics.bbc\",\n        ]\n        .into_iter()\n        .map(|s| s.to_string())\n        .collect();\n        let args = Args::from(args);\n        let result = Core::build_all(\u0026args);\n        assert!(result.is_err())\n    }\n\n    #[test]\n    fn list_file_not_created() {\n        let temp_folder = TempDir::new(\"bbcx-tests\").unwrap();\n\n        let temp_target = temp_folder.path().join(\"nthg.bbc\");\n        let temp_target_str = temp_target.display().to_string();\n\n        std::fs::copy(\"./examples/test/bbc3/nthg.bbc\", temp_target).unwrap();\n\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \u0026temp_target_str]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let _ = Core::build_all(\u0026args);\n\n        let list_target = temp_folder.path().join(\"nthg.lst\");\n        assert!(!list_target.exists());\n    }\n\n    #[test]\n    fn list_file_created() {\n        let temp_folder = TempDir::new(\"bbcx-tests\").unwrap();\n\n        let temp_target = temp_folder.path().join(\"nthg.bbc\");\n        let temp_target_str = temp_target.display().to_string();\n\n        std::fs::copy(\"./examples/test/bbc3/nthg.bbc\", temp_target).unwrap();\n\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"--list\", \u0026temp_target_str]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let _ = Core::build_all(\u0026args);\n\n        let list_target = temp_folder.path().join(\"nthg.lst\");\n        assert!(list_target.exists());\n    }\n\n    #[test]\n    fn list_file_created_when_parsed_error() {\n        let temp_folder = TempDir::new(\"bbcx-tests\").unwrap();\n\n        let temp_target = temp_folder.path().join(\"invalid_syntax.bbc\");\n        let temp_target_str = temp_target.display().to_string();\n\n        std::fs::copy(\"./examples/test/bbc3/invalid_syntax.bbc\", temp_target).unwrap();\n\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"--list\", \u0026temp_target_str]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let _ = Core::build_all(\u0026args);\n\n        let list_target = temp_folder.path().join(\"invalid_syntax.lst\");\n        assert!(list_target.exists());\n    }\n\n    #[test]\n    fn list_file_created_when_assembled_error() {\n        let temp_folder = TempDir::new(\"bbcx-tests\").unwrap();\n\n        let temp_target = temp_folder.path().join(\"invalid_semantics.bbc\");\n        let temp_target_str = temp_target.display().to_string();\n\n        std::fs::copy(\"./examples/test/bbc3/invalid_semantics.bbc\", temp_target).unwrap();\n\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"--list\", \u0026temp_target_str]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let _ = Core::build_all(\u0026args);\n\n        let list_target = temp_folder.path().join(\"invalid_semantics.lst\");\n        assert!(list_target.exists());\n    }\n\n    #[test]\n    fn list_file_created_at_specified_path() {\n        let temp_folder = TempDir::new(\"bbcx-tests\").unwrap();\n\n        let temp_target = temp_folder.path();\n        let temp_target_str = temp_target.display().to_string();\n\n        let args = vec![\n            \"bbc-x\",\n            \"--lang=bbc3\",\n            \"--list\",\n            \"--list-path\",\n            \u0026temp_target_str,\n            \"./examples/test/bbc3/nthg.bbc\",\n        ]\n        .into_iter()\n        .map(|s| s.to_string())\n        .collect();\n        let args = Args::from(args);\n        let _ = Core::build_all(\u0026args);\n\n        let list_target = temp_folder.path().join(\"nthg.lst\");\n        assert!(list_target.exists());\n    }\n\n    #[test]\n    fn list_file_lists_all_operations() {\n        let temp_folder = TempDir::new(\"bbcx-tests\").unwrap();\n\n        let temp_target = temp_folder.path().join(\"instruction_set.bbc\");\n        let temp_target_str = temp_target.display().to_string();\n\n        std::fs::copy(\"./examples/test/bbc3/instruction_set.bbc\", temp_target).unwrap();\n\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"--list\", \u0026temp_target_str]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let args = Args::from(args);\n        let _ = Core::build_all(\u0026args);\n\n        let list_target = temp_folder.path().join(\"instruction_set.lst\");\n        assert!(list_target.exists());\n    }\n\n    #[test]\n    fn program_bbc3_not_executed() {\n        let args = vec![\n            \"bbc-x\",\n            \"--lang=bbc3\",\n            \"--run\",\n            \"./examples/test/bbc3/nthg.bbc\",\n        ]\n        .into_iter()\n        .map(|s| s.to_string())\n        .collect();\n        let args = Args::from(args);\n        let result = Core::build_all(\u0026args);\n        assert!(result.is_err())\n    }\n\n    #[test]\n    #[ignore]\n    fn program_bbcx_executed() {}\n\n    #[test]\n    #[ignore]\n    fn trace_file_not_created() {}\n\n    #[test]\n    #[ignore]\n    fn trace_file_created() {}\n\n    #[test]\n    #[ignore]\n    fn trace_file_created_at_specified_path() {}\n}\n","traces":[{"line":10,"address":[871184,872078,872365],"length":1,"stats":{"Line":3}},{"line":11,"address":[871222],"length":1,"stats":{"Line":1}},{"line":12,"address":[871275],"length":1,"stats":{"Line":1}},{"line":13,"address":[871331],"length":1,"stats":{"Line":0}},{"line":16,"address":[871388],"length":1,"stats":{"Line":3}},{"line":18,"address":[871510,871674,871437],"length":1,"stats":{"Line":7}},{"line":19,"address":[872154,871714],"length":1,"stats":{"Line":5}},{"line":20,"address":[872403,872427],"length":1,"stats":{"Line":2}},{"line":21,"address":[872434],"length":1,"stats":{"Line":1}},{"line":23,"address":[872420],"length":1,"stats":{"Line":1}},{"line":26,"address":[872250],"length":1,"stats":{"Line":1}},{"line":28,"address":[872265],"length":1,"stats":{"Line":1}},{"line":31,"address":[871750,871611],"length":1,"stats":{"Line":6}},{"line":36,"address":[871851,872000,871796],"length":1,"stats":{"Line":7}},{"line":37,"address":[872007],"length":1,"stats":{"Line":2}},{"line":39,"address":[871866],"length":1,"stats":{"Line":1}}],"covered":15,"coverable":16},{"path":["/","home","runner","work","bbc-x","bbc-x","src","language.rs"],"content":"use crate::bbc3::Bbc3;\nuse crate::bbcx::BbcX;\nuse crate::model::LanguageModel;\nuse crate::result::Result;\n\nuse std::path::Path;\n\npub enum Language {\n    Bbc3(Bbc3),\n    BbcX(BbcX),\n}\n\nimpl Language {\n    pub fn assemble(\u0026self, file: \u0026Path) -\u003e Result\u003c()\u003e {\n        match self {\n            Language::Bbc3(model) =\u003e model.assemble(file),\n            Language::BbcX(model) =\u003e model.assemble(file),\n        }\n    }\n\n    pub fn run(\u0026self, file: \u0026Path) -\u003e Result\u003c()\u003e {\n        match self {\n            Language::Bbc3(model) =\u003e model.run(file),\n            Language::BbcX(model) =\u003e model.run(file),\n        }\n    }\n\n    pub fn list(\u0026self, file: \u0026Path) -\u003e Result\u003c()\u003e {\n        match self {\n            Language::Bbc3(model) =\u003e model.list(file),\n            Language::BbcX(model) =\u003e model.list(file),\n        }\n    }\n    \n}","traces":[{"line":14,"address":[1063344],"length":1,"stats":{"Line":3}},{"line":15,"address":[1063388],"length":1,"stats":{"Line":3}},{"line":16,"address":[1063414],"length":1,"stats":{"Line":1}},{"line":17,"address":[1063450],"length":1,"stats":{"Line":0}},{"line":21,"address":[1063488],"length":1,"stats":{"Line":1}},{"line":22,"address":[1063532],"length":1,"stats":{"Line":1}},{"line":23,"address":[1063558],"length":1,"stats":{"Line":1}},{"line":24,"address":[1063594],"length":1,"stats":{"Line":0}},{"line":28,"address":[1063632],"length":1,"stats":{"Line":1}},{"line":29,"address":[1063676],"length":1,"stats":{"Line":2}},{"line":30,"address":[1063702],"length":1,"stats":{"Line":3}},{"line":31,"address":[1063738],"length":1,"stats":{"Line":0}}],"covered":9,"coverable":12},{"path":["/","home","runner","work","bbc-x","bbc-x","src","list_writer.rs"],"content":"use crate::args::Args;\n\nuse std::path::{Path, PathBuf};\n\npub struct ListWriter {\n    list_file: Option\u003cPathBuf\u003e,\n    listing: Vec\u003cString\u003e,\n}\n\nimpl ListWriter {\n\n    pub fn new(file: \u0026Path, args: \u0026Args) -\u003e Self {\n        let list_file = ListWriter::get_list_file(file, args);\n        let listing = Vec::new();\n        let mut me = Self { list_file, listing };\n        me.add_title_to_listing(file);\n        me.add_line_to_listing(\"\");\n        me\n    }\n\n    fn get_list_file(file: \u0026Path, args: \u0026Args) -\u003e Option\u003cPathBuf\u003e {\n        if args.list() {\n            let parent = file.parent().unwrap().to_path_buf();\n            let parent = args.list_path().unwrap_or(parent);\n            let stem = file.file_stem().unwrap();\n            let list_filename = parent.join(stem).with_extension(\"lst\");\n            Some(list_filename)\n        } else {\n            None\n        }\n    }\n\n    fn add_title_to_listing(\u0026mut self, file: \u0026Path) {\n        let filename = file.display().to_string();\n        let format = time::format_description::parse(\n            \"[weekday repr:short] [day] [month repr:short] [year] [hour]:[minute]\",)\n            .unwrap();\n        let now = time::OffsetDateTime::now_utc()\n            .format(\u0026format)\n            .unwrap()\n            .to_string();\n        self.add_line_to_listing(\u0026format!(\"{:\u003c14}{:\u003c42} {}\\n\", \"\", filename, now).to_uppercase());\n    }\n\n    pub fn add_lines_to_listing(\u0026mut self, text: \u0026str) {\n        let text = text.split('\\n');\n        text.into_iter().for_each(|s| self.add_line_to_listing(s));\n    }\n    \n    fn add_line_to_listing(\u0026mut self, text: \u0026str) {\n        let line_number = self.listing.len() + 1;\n        let text = format!(\"{:\u003e5} {}\", line_number, text);\n        self.listing.push(text.trim_end().into())\n    }\n\n    #[inline]\n    pub fn write_content_to_file(\u0026self) -\u003e std::result::Result\u003c(), std::io::Error\u003e {\n        if let Some(list_file) = \u0026self.list_file {\n            std::fs::write(list_file, self.listing.join(\"\\n\"))\n        } else {\n            Ok(())\n        }\n    }\n    \n}\n","traces":[{"line":12,"address":[1894669,1894336],"length":1,"stats":{"Line":1}},{"line":13,"address":[1894386],"length":1,"stats":{"Line":1}},{"line":14,"address":[1894412],"length":1,"stats":{"Line":1}},{"line":15,"address":[1894478],"length":1,"stats":{"Line":1}},{"line":16,"address":[1894563],"length":1,"stats":{"Line":1}},{"line":17,"address":[1894621],"length":1,"stats":{"Line":1}},{"line":18,"address":[1894633],"length":1,"stats":{"Line":1}},{"line":21,"address":[1894720,1895635],"length":1,"stats":{"Line":1}},{"line":22,"address":[1894819,1895630,1894784],"length":1,"stats":{"Line":3}},{"line":23,"address":[1894834,1894925],"length":1,"stats":{"Line":2}},{"line":24,"address":[1894960,1895021],"length":1,"stats":{"Line":2}},{"line":25,"address":[1895099,1895283],"length":1,"stats":{"Line":2}},{"line":26,"address":[1895323],"length":1,"stats":{"Line":1}},{"line":27,"address":[1895548],"length":1,"stats":{"Line":1}},{"line":29,"address":[1894806],"length":1,"stats":{"Line":3}},{"line":33,"address":[1898171,1895680],"length":1,"stats":{"Line":1}},{"line":34,"address":[1895742],"length":1,"stats":{"Line":1}},{"line":38,"address":[1896462,1896220,1896113],"length":1,"stats":{"Line":3}},{"line":42,"address":[1897222,1897454,1896894,1897674,1897898],"length":1,"stats":{"Line":5}},{"line":45,"address":[1898208],"length":1,"stats":{"Line":1}},{"line":46,"address":[1898244],"length":1,"stats":{"Line":1}},{"line":47,"address":[1848114,1848096],"length":1,"stats":{"Line":3}},{"line":50,"address":[1899399,1898304],"length":1,"stats":{"Line":1}},{"line":51,"address":[1898334,1899236],"length":1,"stats":{"Line":1}},{"line":52,"address":[1898768,1898504,1898988],"length":1,"stats":{"Line":3}},{"line":53,"address":[1899303,1899219],"length":1,"stats":{"Line":2}},{"line":57,"address":[1899424],"length":1,"stats":{"Line":1}},{"line":58,"address":[1899438],"length":1,"stats":{"Line":1}},{"line":59,"address":[1899496],"length":1,"stats":{"Line":1}},{"line":61,"address":[1899551],"length":1,"stats":{"Line":3}}],"covered":30,"coverable":30},{"path":["/","home","runner","work","bbc-x","bbc-x","src","main.rs"],"content":"pub mod args;\npub mod bbc3;\npub mod bbcx;\npub mod core;\npub mod language;\npub mod list_writer;\npub mod model;\npub mod result;\n\nuse crate::args::Args;\nuse crate::core::Core;\nuse crate::result::Result;\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    let args = std::env::args().collect::\u003cVec\u003cString\u003e\u003e();\n    match bbc_x(args) {\n        Ok(_) =\u003e {}\n        Err(e) =\u003e println!(\"Error: {:?}\", e),\n    }\n}\n\nfn bbc_x(args: Vec\u003cString\u003e) -\u003e Result\u003c()\u003e {\n    let args = Args::from(args);\n    Core::build_all(\u0026args)\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn invoke_core() {\n        let args = vec![\"bbc-x\", \"--lang=bbc3\", \"./examples/test/bbc3/nthg.bbc\"]\n            .into_iter()\n            .map(|s| s.to_string())\n            .collect();\n        let result = bbc_x(args);\n        assert!(result.is_ok())\n    }\n}\n","traces":[{"line":23,"address":[1370144,1370236],"length":1,"stats":{"Line":1}},{"line":24,"address":[1370167],"length":1,"stats":{"Line":1}},{"line":25,"address":[1370182],"length":1,"stats":{"Line":1}}],"covered":3,"coverable":3},{"path":["/","home","runner","work","bbc-x","bbc-x","src","model.rs"],"content":"/// The language model enables concrete implementations of the model to parse, assemble \n/// and execute source code.\n/// \nuse crate::result::*;\n\nuse std::path::Path;\n\npub trait LanguageModel {\n    fn assemble(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e;\n    fn run(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e;\n    fn list(\u0026self, path: \u0026Path) -\u003e Result\u003c()\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","bbc-x","bbc-x","src","result.rs"],"content":"use thiserror::Error;\n\n#[derive(Clone, Debug, PartialEq, Error)]\npub enum Error {\n    #[error(\"cannot read file: {0} {1}\")]\n    CannotReadFile(String, String),\n\n    #[error(\"failed to parse {0}\")]\n    FailedToParse(String),\n\n    #[error(\"failed to assemble {0}\")]\n    FailedToAssemble(String),\n\n    #[error(\"failed to run {0}\")]\n    FailedToRun(String),\n\n    #[error(\"multiple build errors\")]\n    BuildErrors(Vec\u003cError\u003e),\n\n    #[error(\"cannot write file: {0} {1}\")]\n    CannotToWriteFile(String, String),\n}\n\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n","traces":[{"line":24,"address":[2937863,2938358,2938404,2937761,2937812,2936926],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>